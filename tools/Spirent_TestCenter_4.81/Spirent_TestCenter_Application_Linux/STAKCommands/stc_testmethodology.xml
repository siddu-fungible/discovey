<?xml version="1.0" ?>
<stc:meta package="spirent.methodology" plugin="plcommands" version="0.0.0-0" xmlns:stc="urn:www.spirentcom.com:XMLSchema.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

<stc:class
    name="IterationWhileCommand"
    baseClass="stak.StakWhileCommand"
    displayName="Iteration While Command"
    bllDirectInterface="true"
    isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Methodology iteration loop."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Iteration Framework"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="EnableIterationTestReport" displayName="Enable Iteration Test Report" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True enables generation of an iteration test report (JSON format).  False disables generation of an iteration test report.  Set this to false if the iterator is not being used in the context of a test loop." />
    </stc:property>
    <stc:property category="input" name="EnableApplyVerdict" displayName="Enable Apply Iteration Verdict To Iterator" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True enables application of the iteration verdict to the iterator's state (ie for binary search).  False prevents the iteration verdict from affecting the iterator's state." />
    </stc:property>
    <stc:property category="input" name="IterationName" displayName="Iteration Description" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Short string description of what the iteration is iterating over.  This string must not contain spaces or special characters as it will be used in iteration JSON report filenames." />
      <stc:regExpValidation pattern="^[A-Za-z0-9.]{0,20}$" errorMsg="Not a valid IterationName."/>
    </stc:property>
    <stc:property category="input" name="IteratorDisplayName" displayName="Iterator Description For Display" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Short human-readable string description of what the iterator is iterating over.  This will be used in iteration JSON report rendering.  If unset, the IterationName property will be used." />
    </stc:property>
<!-- CATEGORY: Framework: Iteration -->
</stc:class>

<!-- The IterationGroupCommand is to be deprecated -->
<stc:class
    name="IterationGroupCommand"
    baseClass="stak.StakGroupCommand"
    displayName="Iteration Group Command"
    bllDirectInterface="true"
    isInternal="false">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Base iteration framework command that chains the iterator, configurator, and validators under it."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Iteration Framework"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
<!-- CATEGORY: Framework: Iteration -->
</stc:class>

<!-- Wait for Property Value Command (more generic than Verify Results Value but probably for internal use only) -->
<stc:class name="WaitForPropertyValueCommand" displayName="Wait For Property Value Command" bllDirectInterface="true" isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Waits for the value of a property on one or more objects of a given type to meet a specified expression." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="true" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:enumeration name="EnumPropertyValueType">
      <stc:enum name="NUMBER"     value="0" displayName="Number" />
      <stc:enum name="BOOL"        value="1" displayName="Bool" />
      <stc:enum name="STRING"      value="2" displayName="String" />
      <stc:enum name="ENUM"        value="3" displayName="Enum" />
    </stc:enumeration>

    <stc:enumeration name="EnumOperationType">
      <stc:enum name="EQUALS"                   value="0" displayName="Equals" />
      <stc:enum name="NOT_EQUALS"               value="1" displayName="Not Equal" />
      <stc:enum name="GREATER_THAN"             value="2" displayName="Greater" />
      <stc:enum name="LESS_THAN"                value="3" displayName="Less" />
      <stc:enum name="GREATER_THAN_OR_EQUALS"   value="4" displayName="Greater or Equal" />
      <stc:enum name="LESS_THAN_OR_EQUALS"      value="5" displayName="Less or Equal" />
    </stc:enumeration>

    <stc:property category="input" name="ParentList" displayName="Parent List" type="handle" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of object handles to check the specified property on." />
      <stc:attribute type="core.ValidHandleTypes" value="EmulatedDevice" internalType="string" />
    </stc:property>
    <stc:property category="input" name="TagList" displayName="Tag List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tag names to check the specified property on." />
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="core.ValidHandleTypes" value="Tag" />
    </stc:property>
    <stc:property category="input" name="ObjectClassName" displayName="Object Class Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Class name of the object(s) specified in ParentList." />
    </stc:property>
    <stc:property category="input" name="PropertyName" displayName="Property Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Name of the property to check." />
    </stc:property>
    <stc:property category="input" name="PropertyValue" displayName="Property Value" type="string" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Value to compare against the value of the object's property." />
    </stc:property>
    <stc:property category="input" name="PropertyValueType" displayName="Property Value Type" type="u8" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Data type of the specified property.  Acceptable values are: NUMBER, BOOL, STRING, or ENUM." />
      <stc:enumerationRef ref="EnumPropertyValueType"/>
    </stc:property>
    <stc:property category="input" name="OperationType" displayName="Operation Type" type="u8" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Expression used to compare the value of the object's property to the value specified by PropertyValue.  Acceptable values are: EQUALS, NOT_EQUALS, GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUALS, or LESS_THAN_OR_EQUALS." />
      <stc:enumerationRef ref="EnumOperationType"/>
    </stc:property>
    <stc:property category="input" name="PollInterval" displayName="Poll Interval" type="u32" default="10">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Interval in seconds to poll the state of the specified expression." />
    </stc:property>
    <stc:property category="input" name="MaxWaitTime" displayName="Maximum Wait Time" type="u32" default="10">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Maximum amount of time in seconds to wait for the specified expression to be met." />
    </stc:property>

<!-- CATEGORY: Wait -->

</stc:class>


<!-- Iterator command base class -->
<stc:class name="IteratorCommand" displayName="Iterator Command" bllDirectInterface="true" isInternal="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Base class for all Iterator commands, which determine how an iteration progresses." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Iteration Framework"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="BreakOnFail" displayName="Break on fail" type="bool" default="false" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True will break out of the test or sequence when an iteration fails.  False will continue the test or sequence if an iteration fails." />
    </stc:property>
    <stc:property category="input" name="MinVal" displayName="Minimum value" type="double" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Minimum possible value to be used in an iteration." />
    </stc:property>
    <stc:property category="input" name="MaxVal" displayName="Maximum value" type="double" default="100">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Maximum possible value to be used in an iteration." />
    </stc:property>
    <stc:property category="input" name="PrevIterVerdict" displayName="Previous iteration result" type="bool" default="true" isInternal="false" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Result of the previous iteration." />
    </stc:property>

    <stc:property category="state" name="Iteration" displayName="Iteration" type="u32" default="0" isInternal="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Index (1-based) of the current iteration." />
    </stc:property>
    <stc:property category="state" name="CurrVal" displayName="Current value" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Value the configurator(s) should use in the current iteration." />
    </stc:property>
    <stc:property category="state" name="ResetState" displayName="Reset State" type="bool" default="false" isInternal="true" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True resets the state of the command and its properties.  False retains the state of the command and the values of its properties." />
    </stc:property>

</stc:class>


<!-- Iterate over discrete objects -->
<stc:class name="ObjectIteratorCommand" displayName="Object Iterator Command" baseClass="spirent.methodology.IteratorCommand" bllDirectInterface="true" isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Iterates over a finite set of values." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Iteration Framework//Iterators"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:enumeration name="EnumIterMode">
      <stc:enum name="STEP"         value="1" displayName="Step" />
      <stc:enum name="BINARY"       value="2" displayName="Binary" />
    </stc:enumeration>

    <stc:enumeration name="EnumValueType">
      <stc:enum name="RANGE"        value="1" displayName="Range" />
      <stc:enum name="LIST"         value="2" displayName="List" />
    </stc:enumeration>

    <stc:enumeration name="EnumStepMode">
      <stc:enum name="PERCENT"       value="1" displayName="Percent" />
      <stc:enum name="ABSOLUTE"      value="2" displayName="Absolute" />
    </stc:enumeration>

    <stc:property category="input" name="IterMode" displayName="Iteration Mode" type="u8" default="STEP" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Method that determines the next value to be used in the iteration.  Acceptable values are: STEP or BINARY." />
      <stc:enumerationRef ref="EnumIterMode"/>
    </stc:property>
    <stc:property category="input" name="StepVal" displayName="Step value" type="double" default="10">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Amount to step to determine next finite value in the iteration.  Used when ValueType is set to RANGE." />
    </stc:property>
    <stc:property category="input" name="StepMode" displayName="Step Mode" type="u8" default="ABSOLUTE">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Specifies the way the Step Value will be handled.  When ABSOLUTE the search space will be discretized into steps of size Step Value.  When PERCENT, the search space will be discretized into steps of size ((search space)/100.0 * (Step Value)).  Used when ValueType is set to RANGE.  Acceptable values are: PERCENT or ABSOLUTE." />
      <stc:enumerationRef ref="EnumStepMode"/>
    </stc:property>

    <!-- Move both of these to the IteratorCommand eventually -->
    <stc:property category="input" name="EnableInitialVal" displayName="Enable Initial Value" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True enables use of a configurable initial value for rate search.  False disables configurable initial value use.  When set to false, the midpoint between MinVal and MaxVal will be used as the initial value." />
    </stc:property>
    <stc:property category="input" name="InitialVal" displayName="Initial Value" type="double" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="The initial value to use when doing binary search.  This is only used when EnableInitialVal is set to true.  InitialVal must fall on a step/resolution boundary within the search space or the command will error.  When using a LIST ValueType, the InitialVal must be specified as a valid, 0-based list index." />
    </stc:property>

    <stc:property category="input" name="ValueType" displayName="Value type" type="u8" default="RANGE" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Type that determines the finite set of values being iterated over.  Acceptable values are: LIST or RANGE.  LIST uses ValueList to define the finite set of values.  RANGE uses MinVal, MaxVal, and StepVal to define the finite set of values." />
      <stc:enumerationRef ref="EnumValueType"/>
    </stc:property>
    <stc:property category="input" name="ValueList" displayName="List of values" type="string" default="" minOccurs="0" maxOccurs="unbounded" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List that defines a finite set of values being iterated over.  Used when ValueType is set to LIST." />
    </stc:property>

    <stc:property category="state" name="CurrIndex" displayName="Current Index" type="u32" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Current index number of ValueList.  Used when ValueType is LIST." />
    </stc:property>
    <stc:property category="state" name="MinFail" displayName="Minimum fail value" type="double" default="null" nullable="true" isInternal="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Current smallest failing value seen during the iteration." />
    </stc:property>
    <stc:property category="state" name="MaxPass" displayName="Maximum pass value" type="double" default="null" nullable="true" isInternal="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Current largest passing value seen during the iteration." />
    </stc:property>

    <stc:property category="output" name="IsConverged" displayName="Is Converged" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True means the iterator was able to converge on a value.  False means the iterator was unable to converge.  Convergence is MinFail/MaxPass falling within resolution range." />
    </stc:property>
    <stc:property category="output" name="ConvergedVal" displayName="Converged Value" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Value the iterator converged on." />
    </stc:property>

<!-- CATEGORY: Framework: Iteration -->

</stc:class>


<!-- Iterate over continuous values like rates (ie RFC 2544 style throughput search) -->
<stc:class name="RateIteratorCommand" displayName="Rate Iterator Command" baseClass="spirent.methodology.IteratorCommand" bllDirectInterface="true" isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Iterate over an infinite set of values between two specified points, such as Rates." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Iteration Framework//Iterators"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:enumeration name="EnumResolutionMode">
      <stc:enum name="PERCENT"       value="1" displayName="Percent" />
      <stc:enum name="ABSOLUTE"      value="2" displayName="Absolute" />
    </stc:enumeration>

    <stc:property category="input" name="Resolution" displayName="Resolution" type="double" default="1">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Value to determine precision to the true value." />
    </stc:property>
    <stc:property category="input" name="ResolutionMode" displayName="Resolution Mode" type="u8" default="PERCENT">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Mode to determine the type for the Resolution value.  Acceptable values are: PERCENT or ABSOLUTE." />
      <stc:enumerationRef ref="EnumResolutionMode"/>
    </stc:property>
    <stc:property category="input" name="RoundingResolution" displayName="Rounding Resolution" type="double" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Value to determine rounding precision. 0 means no rounding." />
    </stc:property>

    <stc:property category="state" name="MinFail" displayName="Minimum fail value" type="double" default="" isInternal="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Current smallest failing value seen during the iteration." />
    </stc:property>
    <stc:property category="state" name="MaxPass" displayName="Maximum pass value" type="double" default="" isInternal="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Current largest passing value seen during the iteration." />
    </stc:property>

    <!-- Move both of these to the IteratorCommand eventually -->
    <stc:property category="input" name="EnableInitialVal" displayName="Enable Initial Value" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True enables use of a configurable initial value for rate search.  False disables configurable initial value use.  When set to false, the midpoint between MinVal and MaxVal will be used as the initial value." />
    </stc:property>
    <stc:property category="input" name="InitialVal" displayName="Initial Value" type="double" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="The initial value to use when doing binary search.  This is only used when EnableInitialVal is set to true." />
    </stc:property>

    <stc:property category="output" name="IsConverged" displayName="Is Converged" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True means the iterator was able to converge on a value.  False means the iterator was unable to converge.  Convergence is MinFail/MaxPass falling within resolution range." />
    </stc:property>
    <stc:property category="output" name="ConvergedVal" displayName="Converged Value" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Value the iterator converged on." />
    </stc:property>
<!-- CATEGORY: Framework: Iteration -->
</stc:class>


<!-- Reverse iterator for stability search -->
<stc:class
    name="StabilityBackoffIteratorCommand"
    displayName="Stability Backoff Iterator Command"
    baseClass="spirent.methodology.IteratorCommand"
    bllDirectInterface="true"
    isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Iterates backwards over a finite set of values via a Step method, repeating each test value for stability." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Iteration Framework//Iterators"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:enumeration name="EnumValueType">
      <stc:enum name="RANGE"        value="1" displayName="Range" />
      <stc:enum name="LIST"         value="2" displayName="List" />
    </stc:enumeration>

    <stc:property category="input" name="StepVal" displayName="Step value" type="double" default="10">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Amount to step backwards to determine the next value in the iteration." />
    </stc:property>
    <stc:property category="input" name="RepeatCount" displayName="Repeat Count" type="u32" default="5">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Number of times to repeat the test value." />
    </stc:property>
    <stc:property category="input" name="SuccessPercent" displayName="Success Percent" type="double" default="100">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Percentage of times a repeated test value must pass to be considered stable." />
    </stc:property>
    <stc:property category="input" name="ValueType" displayName="Value type" type="u8" default="RANGE" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Type that determines the finite set of values being iterated over.  Acceptable values are: LIST or RANGE.  LIST uses ValueList to define the finite set of values.  RANGE uses MinVal, MaxVal, and StepVal to define the finite set of values." />
      <stc:enumerationRef ref="EnumValueType"/>
    </stc:property>
    <stc:property category="input" name="ValueList" displayName="List of values" type="string" default="" minOccurs="0" maxOccurs="unbounded" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List that defines a finite set of values being iterated over.  Used when ValueType is set to LIST." />
    </stc:property>

    <stc:property category="state" name="CurrIndex" displayName="Current Index" type="u32" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Current index number of ValueList.  Used when ValueType is LIST." />
    </stc:property>
    <stc:property category="state" name="MinFail" displayName="Minimum fail value" type="double" default="" isInternal="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Current smallest failing value seen during the iteration." />
    </stc:property>
    <stc:property category="state" name="MaxPass" displayName="Maximum pass value" type="double" default="" isInternal="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Current largest passing value seen during the iteration." />
    </stc:property>
    <stc:property category="state" name="SuccessCount" displayName="Success Count" type="u32" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Number of successful trials for the current test value." />
    </stc:property>
    <stc:property category="state" name="TrialNum" displayName="Trial Number" type="u32" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Trial number for the current test value." />
    </stc:property>

    <stc:property category="output" name="StableValue" displayName="Stable value" type="string" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Value the iterator determined to be stable." />
    </stc:property>
    <stc:property category="output" name="FoundStableValue" displayName="Found a stable value" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True when able to determine a stable value.  False when unable to determine a stable value." />
    </stc:property>
<!-- CATEGORY: Framework: Iteration -->
</stc:class>


<!-- Object Iterator + Stability Backoff Iterator -->
<stc:class
    name="BenchmarkStabilityIteratorCommand"
    displayName="Benchmark Stability Iterator Command"
    baseClass="spirent.methodology.IteratorCommand"
    bllDirectInterface="true"
    isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Iterates over a finite set of values.  If/when a converged value is found, a stability test may be performed.  When the stability test is performed, the iterator repeats values and steps backwards until it finds a value that is stable." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Iteration Framework//Iterators"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:enumeration name="EnumIterMode">
      <stc:enum name="STEP"         value="1" displayName="Step" />
      <stc:enum name="BINARY"       value="2" displayName="Binary" />
    </stc:enumeration>

    <stc:enumeration name="EnumValueType">
      <stc:enum name="RANGE"        value="1" displayName="Range" />
      <stc:enum name="LIST"         value="2" displayName="List" />
    </stc:enumeration>

    <stc:enumeration name="EnumIterState">
      <stc:enum name="SEARCH"       value="1" displayName="Goal Seeking" />
      <stc:enum name="STABILITY"    value="2" displayName="Stability Backoff" />
    </stc:enumeration>

    <!-- Generic properties -->
    <stc:property category="input" name="EnableStabilityBackoff" displayName="Enable Stability Backoff" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True enables the stability test when a converged value is found.  False disables the stability test and ends the iteration when a converged value is found." />
    </stc:property>

    <!-- ObjectIterator properties -->
    <stc:property category="input" name="IterMode" displayName="Iteration Mode" type="u8" default="STEP" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Method that determines the next value to be used in the iteration.  Acceptable values are: STEP or BINARY." />
      <stc:enumerationRef ref="EnumIterMode"/>
    </stc:property>
    <stc:property category="input" name="StepVal" displayName="Step value" type="double" default="10">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Amount to step to determine next finite value in the iteration.  Used when ValueType is set to RANGE." />
    </stc:property>
    <stc:property category="input" name="ValueType" displayName="Value type" type="u8" default="RANGE" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Type that determines the finite set of values being iterated over.  Acceptable values are: LIST or RANGE.  LIST uses ValueList to define the finite set of values.  RANGE uses MinVal, MaxVal, and StepVal to define the finite set of values." />
      <stc:enumerationRef ref="EnumValueType"/>
    </stc:property>
    <stc:property category="input" name="ValueList" displayName="List of values" type="string" default="" minOccurs="0" maxOccurs="unbounded" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List that defines a finite set of values being iterated over.  Used when ValueType is set to LIST." />
    </stc:property>

    <!-- StabilityBackoffIterator properties -->
    <stc:property category="input" name="RepeatCount" displayName="Repeat Count" type="u32" default="5">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Number of times to repeat the test value when searching for a stable value. Not used if EnableStabilityBackoff is false." />
    </stc:property>
    <stc:property category="input" name="SuccessPercent" displayName="Success Percent" type="double" default="100">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Percentage of times a repeated test value must pass to be considered stable." />
    </stc:property>

    <!-- Internal state properties -->
    <stc:property category="state" name="CurrIndex" displayName="Current Index" type="u32" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Current index number of ValueList.  Used when ValueType is LIST." />
    </stc:property>
    <stc:property category="state" name="IterState" displayName="Iterator state" type="u8" default="SEARCH" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="State of the search algorithm of the iterator.  States are: SEARCH (Goal-Seeking) or STABILITY (Stability Backoff)" />
      <stc:enumerationRef ref="EnumIterState"/>
    </stc:property>

    <!-- ObjectIteratorCommand State Properties -->
    <stc:property category="state" name="SearchIteration" displayName="Goal-seeking Test Iteration Number" type="u32" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Iteration number in the SEARCH (Goal-Seeking) state of the testing." />
    </stc:property>
    <stc:property category="state" name="SearchMinFail" displayName="Minimum fail value" type="double" nullable="true" default="null" isInternal="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Current smallest failing value seen during the SEARCH (Goal-Seeking) state." />
    </stc:property>
    <stc:property category="state" name="SearchMaxPass" displayName="Maximum pass value" type="double" nullable="true" default="null" isInternal="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Current largest passing value seen during the SEARCH (Goal-Seeking) state." />
    </stc:property>

    <!-- StabilityBackoffIterator Command State Properties -->
    <stc:property category="state" name="StabilityIteration" displayName="Stability Test Iteration Number" type="u32" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Iteration number in the STABILITY (Stability Backoff) state of the testing." />
    </stc:property>
    <stc:property category="state" name="StabilityTrialNum" displayName="Stability Test Trial Number" type="u32" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Trial number for a test value during the STABILITY (Stability Backoff) state." />
    </stc:property>
    <stc:property category="state" name="StabilitySuccessCount" displayName="Stability Success Count" type="u32" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Number of successful trials for a test value during the STABILITY (Stability Backoff) state." />
    </stc:property>

    <!-- Output properties -->
    <stc:property category="output" name="IsConverged" displayName="Is Converged" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True means the iterator was able to converge on a value.  False means the iterator was unable to converge.  Convergence is MinFail/MaxPass falling within resolution range." />
    </stc:property>
    <stc:property category="output" name="ConvergedVal" displayName="Converged Value" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Value the iterator converged on." />
    </stc:property>

    <stc:property category="output" name="StableValue" displayName="Stable value" type="string" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Value the iterator determined to be stable." />
    </stc:property>
    <stc:property category="output" name="FoundStableValue" displayName="Found a stable value" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True when able to determine a stable value.  False when unable to determine a stable value." />
    </stc:property>

<!-- CATEGORY: Framework: Iteration -->

</stc:class>


<!-- Iterate over tagged objects -->
<stc:class name="TaggedObjectsIteratorCommand"
           displayName="Tagged Objects Iterator Command"
           baseClass="spirent.methodology.IteratorCommand"
           bllDirectInterface="true" isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Iterates over a list of tagged objects." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Iteration Framework//Iterators"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:enumeration name="EnumObjectOrder">
      <stc:enum name="SCALAR"   value="1" displayName="Scalar" />
      <stc:enum name="TUPLE"    value="2" displayName="Tuple" />
    </stc:enumeration>

    <stc:property category="input" name="ObjectOrder" displayName="Iteration Mode" type="u8" default="SCALAR" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Output format of the objects being iterated over.  Acceptable values are: SCALAR or TUPLE.  If SCALAR, each tagged object is output by handle one at a time.  If TUPLE, the tagged objects are output as CSV list." />
      <stc:enumerationRef ref="EnumObjectOrder"/>
    </stc:property>
    <stc:property category="input" name="TagNameList" displayName="List of Tag Names" type="string" default="" minOccurs="0" maxOccurs="unbounded" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tag names of objects being iterated over." />
    </stc:property>
<!-- CATEGORY: Framework: Iteration -->
</stc:class>


<!-- Configurator base class -->
<stc:class name="IteratorConfigCommand" displayName="Iterator Config Command" bllDirectInterface="true" isInternal="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Base class for all Iterator Config commands, which determine how and what to configure each iteration." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Iteration Framework//Configurators"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="ObjectList" displayName="Object List" type="handle" default="" minOccurs="0" maxOccurs="unbounded" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of handles of objects being configured." />
    </stc:property>
    <stc:property category="input" name="TagList" displayName="Tag List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tag names of objects being configured." />
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="core.ValidHandleTypes" value="Tag" />
    </stc:property>
    <stc:property category="input" name="CurrVal" displayName="Current value" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Value to use in the current iteration." />
    </stc:property>
    <stc:property category="input" name="Iteration" displayName="Iteration" type="u32" default="0" isInternal="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Index (1-based) of the current iteration." />
    </stc:property>
</stc:class>

<stc:class name="IteratorConfigPropertyValueCommand"
           displayName="Iterator Config Property Value Command"
           baseClass="spirent.methodology.IteratorConfigCommand"
           bllDirectInterface="true"
           isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Uses the output of the iterator to configure the property for objects of a given type." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Iteration Framework//Configurators"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="ClassName" displayName="Class Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Name of the object's class." />
    </stc:property>
    <stc:property category="input" name="EnableObjectRecursiveSearch" displayName="Enable Tagged Object Recursive Search" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True enables recursive search from (and including) tagged objects for objects of type ClassName.  False disables recursive search so only the tagged objects are used." />
    </stc:property>
    <stc:property category="input" name="PropertyName" displayName="Property Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Name of the object's property to configure." />
    </stc:property>
<!-- CATEGORY: Framework: Iteration -->
</stc:class>

<stc:class name="IteratorConfigJsonPropertyValueCommand"
           displayName="Iterator Config JSON Property Value Command"
           baseClass="spirent.methodology.IteratorConfigPropertyValueCommand"
           bllDirectInterface="true"
           isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Configure the JSON property for objects of a given type" />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Iteration Framework//Configurators"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
    <stc:property category="input" name="KeyList" displayName="List of JSON value keys" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Dot separated path to JSON value" />
    </stc:property>
    <stc:property category="input" name="UseIterationNum" displayName="Use Iteration Number" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Use Iteration instead of CurrVal to configure target" />
    </stc:property>
<!-- CATEGORY: Framework: Iteration -->
</stc:class>

<stc:class name="IteratorConfigFromDbCommand" displayName="Iterator Config From Database Command" baseClass="spirent.methodology.IteratorConfigPropertyValueCommand" bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Configures a target object's property with a value from a cell in a database. Input CurrVal is used as the row index." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Iteration Framework//Configurators"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="DatabaseName" displayName="Database Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="The name of the database which contains the data that will be used to configure the sequencer commands." />
    </stc:property>

    <stc:property category="input" name="TableName" displayName="Table Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="The name of the table which contains the data that will be used to configure the sequencer commands." />
    </stc:property>

    <stc:property category="input" name="ColumnName" displayName="Column Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="The name of the column which contains the data that will be used to configure the sequencer commands." />
    </stc:property>

    <stc:property category="input" name="KeyColumnName" displayName="Key Column Name" type="string" default="Id">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="The name of the column which contains the key that will be used to find the data for that iteration." />
    </stc:property>
<!-- CATEGORY: Framework: Iteration -->
<!-- CATEGORY: Results: Database and SQL -->
</stc:class>

<stc:class name="IteratorConfigRotateTrafficMixWeightsCommand" displayName="Iterator Config Rotate Traffic Mix Weights Command" baseClass="spirent.methodology.IteratorConfigCommand" bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Configures the Traffic Mix's load weights by rotating the weights list to the right by CurrVal.  Negating this value will rotate the weights list to the left." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Iteration Framework//Configurators"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
<!-- CATEGORY: Framework: Iteration -->
</stc:class>


<stc:class name="ResetRotateTrafficMixWeightsCommand" displayName="Reset Rotate Traffic Mix Weights Command" bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Resets the Traffic Mix's load weights list to its original order." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Iteration Framework//Configurators"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="ObjectList" displayName="Object List" type="handle" default="" minOccurs="1" maxOccurs="unbounded" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of handles of Traffic Mix objects being configured." />
    </stc:property>
    <stc:property category="input" name="TrafficMixTagList" displayName="Traffic Mix Tag List" type="string" default="" minOccurs="0" maxOccurs="unbounded" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tag names of the Traffic Mix objects being configured." />
    </stc:property>
<!-- CATEGORY: Traffic -->
</stc:class>

<stc:class name="IteratorConfigFrameSizeCommand" displayName="Iterator Config Frame Size Command" baseClass="spirent.methodology.IteratorConfigCommand" bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Configures the frame size on a group of tagged streamblocks." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Iteration Framework//Configurators"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
<!-- CATEGORY: Framework: Iteration -->
</stc:class>


<stc:class name="IteratorConfigTrafficLoadCommand" displayName="Iterator Config Traffic Load Command" baseClass="spirent.methodology.IteratorConfigCommand" bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Configures the traffic load on a group of tagged streamblocks." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Iteration Framework//Configurators"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="LoadUnit" displayName="Load Units" type="u8" default="PERCENT_LINE_RATE" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Unit type of traffic load.  Acceptable values are: PERCENT_LINE_RATE, FRAMES_PER_SECOND, INTER_BURST_GAP, MEGABITS_PER_SECOND, KILOBITS_PER_SECOND, or BITS_PER_SECOND." />
      <stc:enumerationRef ref="StreamBlock.EnumLoadUnit"/>
    </stc:property>
<!-- CATEGORY: Framework: Iteration -->
</stc:class>


<stc:class name="TagObjectConfigCommand"
           displayName="Tag Object Config Command"
           baseClass="spirent.methodology.IteratorConfigCommand"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Sets tag(s) to only reference specified object handle(s).  This command has a base class of IteratorConfigCommand." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Iteration Framework//Configurators"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
<!-- CATEGORY: Framework: Data Model -->
</stc:class>


<!-- Validator base class -->
<stc:class name="IteratorValidateCommand" displayName="Iterator Validate Command" bllDirectInterface="true" isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Base class for all Iterator Validate commands, which determine if and how an iteration should continue to iterate." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Iteration Framework//Validators"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="Iteration" displayName="Iteration" type="u32" default="0" isInternal="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Index (1-based) of the current iteration." />
    </stc:property>

    <!-- PASS == True, FAIL == False -->
    <stc:property category="output" name="Verdict" displayName="Verdict" type="bool" default="True">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True means the most recent verdict in the current iteration is a PASS and to continue on to the next value in the iteration loop (if all other requirements of the iterator are met).  False means the most recent verdict is a FAIL and the iterator will act accordingly." />
    </stc:property>
<!-- CATEGORY: Framework: Iteration -->
</stc:class>


<!-- Template based topology commands -->
<stc:class
    name="LoadTemplateCommand"
    baseClass="stak.StakGroupCommand"
    displayName="Load Template Command"
    bllDirectInterface="true"
    isInternal="false">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Loads an XML template into an StmTemplateConfig object." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Topology Template"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="CopiesPerParent" displayName="Number of copies to make per Target Tag object." type="u32" default="1">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Number of copies of the template being created per Target Tag object." />
    </stc:property>

    <stc:property category="input" name="SrcTagList" displayName="Source Tag List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tag names corresponding to tagged elements in the XML.  If specified, these elements (and their children) are loaded.  If not specified, the serializationBase parameter in the template determines from where the template will be loaded." />
    </stc:property>

    <stc:property category="input" name="TargetTagList" displayName="Target Tag List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tag names that tag objects in STC and is where the XML elements are loaded.  If unspecified, XML elements are loaded under Project.  Typically indicates the parent(s) of the objects created, except for EmulatedDevice, where a port group tag should be specified." />
    </stc:property>

    <stc:property category="input" name="TemplateXml" displayName="XML Template String" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="XML template being loaded as a string." />
    </stc:property>

    <stc:property category="input" name="TemplateXmlFileName" displayName="XML Template File" type="inputFilePath" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Location and filename of an XML template being loaded." />
      <stc:attribute type="framework.MangleRelativePath" value="false" internalType="bool" />
    </stc:property>

    <stc:property category="input" name="TagPrefix" displayName="Tag Prefix"
                  type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Prefix value prepended to all tags loaded from the XML Template." />
    </stc:property>

    <stc:property category="input" name="AutoExpandTemplate" displayName="Automatically Expand Template" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True expands the created StmTemplateConfig into objects, such as Emulated Devices, Streamblocks, etc.  False creates the StmTemplateConfig object, but does not expand it, which will need to be done by another command." />
    </stc:property>

    <stc:property category="input" name="StmTemplateMix" displayName="Parent StmTemplateMix object" type="handle" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Handle of an StmTemplateMix object being used as the parent for the created StmTemplateConfig object.  If unspecified, the parent will be project." />
    </stc:property>

    <stc:property category="input" name="EnableLoadFromFileName" displayName="Enable XML Template File" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True loads the XML Template specified by TemplateXmlFileName.  False loads the XML Template string specified by TemplateXML." />
    </stc:property>

    <stc:property category="output" name="StmTemplateConfig" displayName="XML container object (StmTemplateConfig)" type="handle" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Container object for the loaded XML."/>
    </stc:property>

<!-- CATEGORY: Framework: Template -->

</stc:class>

<stc:class name="ExpandTemplateCommand" displayName="Expand XML Template Command" bllDirectInterface="true" isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Expands XML templates into objects in STC.  These templates are stored in StmTemplateConfig objects." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Topology Template"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="StmTemplateConfigList" displayName="StmTemplateConfig List" type="handle" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of handles of StmTemplateConfig objects being expanded." />
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="core.ValidHandleTypes" value="Port" />
    </stc:property>
    <stc:property category="input" name="CopiesPerParent" displayName="Number of copies to make per Target Tag object." type="u32" default="1">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Number of copies of the template to make per Target Tag object" />
    </stc:property>
    <stc:property category="input" name="SrcTagList" displayName="Source Tag List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tags that indicate where in the XML template the configuration will be copied from." />
    </stc:property>
    <stc:property category="input" name="TargetTagList" displayName="Target Tag List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tags that indicate where in the STC configuration the template will be copied to.  If empty, the target will be assumed to be Project." />
    </stc:property>
<!-- CATEGORY: Framework: Template -->
</stc:class>

<stc:class name="ModifyTemplatePropertyCommand" displayName="Modify XML Template Command" bllDirectInterface="true" isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Modifies object (element) properties (attributes) in the XML template." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Topology Template"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="StmTemplateConfig" displayName="StmTemplateConfig" type="handle" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Handle of the StmTemplateConfig object being modified." />
    </stc:property>

    <stc:property category="input" name="TagNameList" displayName="Tag Name List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tag names of the objects being modified." />
    </stc:property>
    <stc:property category="input" name="PropertyList" displayName="Property List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of property IDs (ie classname.property) being modified with new values.  A property's index in this list MUST match the index of its new value in Valuelist." />
    </stc:property>
    <stc:property category="input" name="ValueList" displayName="Value List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of new values for the properties specified in PropertyList.  The index of a new value in this list MUST match the index of the property it is modifying in PropertyList." />
    </stc:property>
<!-- CATEGORY: Framework: Template -->
</stc:class>

<stc:class name="AddTemplateObjectCommand" displayName="Add Object To Template Command" bllDirectInterface="true" isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Adds a new STC object to the template stored in an StmTemplateConfig object." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Topology Template"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="StmTemplateConfig" displayName="StmTemplateConfig" type="handle" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Handle of the StmTemplateConfig object that contains the XML template that an object will be added to." />
    </stc:property>
    <stc:property category="input" name="ParentTagName" displayName="Parent Tag Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Tag name of the object that will serve as the parent to the object being added." />
    </stc:property>
    <stc:property category="input" name="TagName" displayName="Tag Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="New tag name to be created and attached to the object being added." />
    </stc:property>
    <stc:property category="input" name="ClassName" displayName="Class Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Class name of the object being added." />
    </stc:property>
    <stc:property category="input" name="PropertyList" displayName="Property List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of property IDs (ie classname.property) to be configured on the object being added.  A property's index in this list MUST match the index of its value in Valuelist." />
    </stc:property>
    <stc:property category="input" name="ValueList" displayName="Value List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of values for the properties specified in PropertyList.  The index of a value in this list MUST match the index of the property it is configuring in PropertyList." />
    </stc:property>
<!-- CATEGORY: Framework: Template -->
</stc:class>

<stc:class name="DeleteTemplateObjectCommand" displayName="Delete Object From Template Command" bllDirectInterface="true" isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Deletes an object and all of its children from the template stored in an StmTemplateConfig object." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Topology Template"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="StmTemplateConfig" displayName="StmTemplateConfig" type="handle" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Handle of the StmTemplateConfig object that contains the XML template that an object will be deleted from." />
    </stc:property>
    <!--- FIXME: Should we delete the tag too? -->
    <stc:property category="input" name="TagName" displayName="Tag Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Tag name of the object being deleted." />
    </stc:property>
     <stc:property category="input" name="ClassName" displayName="Class Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Class name of the object being deleted." />
    </stc:property>
<!-- CATEGORY: Framework: Template -->
 </stc:class>

<stc:class name="ConfigTemplateRelationCommand" displayName="Configure Relation In Template Command" bllDirectInterface="true" isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Adds or removes a relation between two objects in a template stored in an StmTemplateConfig object." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Topology Template"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="StmTemplateConfig" displayName="StmTemplateConfig" type="handle" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Handle of the StmTemplateConfig object that contains the XML template that a relation will be added to or removed from." />
    </stc:property>
    <stc:property category="input" name="SrcTagName" displayName="Source Tag Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Tag name of the source object that the relation is being configured on." />
    </stc:property>
    <stc:property category="input" name="TargetTagName" displayName="Target Tag Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Tag name of the target object that the relation is being configured on." />
    </stc:property>
    <stc:property category="input" name="RelationName" displayName="Relation Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Name of the relation being added or removed." />
    </stc:property>
    <stc:property category="input" name="RemoveRelation" displayName="Remove Relation" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True removes the relation specified.  False adds the relation specified." />
    </stc:property>
<!-- CATEGORY: Framework: Template -->
</stc:class>

<stc:class name="ConfigRelationCommand" displayName="Configure Relation Between Tagged Objects Command" bllDirectInterface="true" isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Adds or removes a relation between two tagged BLL objects." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Data Model Configuration"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:enumeration name="EnumRelationPattern">
      <stc:enum name="PAIR"        value="0" displayName="Pair" />
      <stc:enum name="BACKBONE"    value="1" displayName="Backbone" />
    </stc:enumeration>

    <stc:property category="input" name="SrcTagNames" displayName="List of Source Tag Names" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Tag name of the source object that the relation is being configured on." />
    </stc:property>
    <stc:property category="input" name="TargetTagNames" displayName="List of Target Tag Names" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Tag name of the target object that the relation is being configured on." />
    </stc:property>
    <stc:property category="input" name="RelationName" displayName="Relation Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Name of the relation being added or removed." />
    </stc:property>
    <stc:property category="input" name="RemoveRelation" displayName="Remove Relation" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True removes the relation specified.  False adds the relation specified." />
    </stc:property>
    <stc:property category="input" name="RelationPattern" displayName="Relation Pattern" type="u8" default="BACKBONE">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Pattern by which relations are constructed between sources and targets.  When PAIR is selected, some objects will not be related if the source and target object counts are not equal." />
      <stc:enumerationRef ref="EnumRelationPattern" />
    </stc:property>

<!-- CATEGORY: Framework: Data Model -->
</stc:class>

<stc:class name="DeleteTemplatesAndGeneratedObjectsCommand" displayName="Delete Templates and Generated Objects Command" bllDirectInterface="true" isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Deletes StmTemplateConfig objects and the objects generated from the expansion of their templates."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Topology Template"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="DeleteStmTemplateConfigs" displayName="Delete StmTemplateConfig objects" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True deletes the StmTemplateConfig objects.  False deletes only the generated objects and skips the StmTemplateConfig objects." />
    </stc:property>
    <stc:property category="input" name="TagList" displayName="Tag List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tag names used to find StmTemplateConfig or StmTemplateMix objects; if the TagList is empty, command will select all such objects under the Project" />
    </stc:property>
<!-- CATEGORY: Framework: Template -->
<!-- CATEGORY: Framework: Data Model -->
</stc:class>

<stc:class
    name="MergeTemplateCommand"
    displayName="Merge Template Command"
    bllDirectInterface="true"
    isInternal="false">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Merges XML from a source string or file into a template stored in an StmTemplateConfig object." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Topology Template"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="StmTemplateConfig" displayName="StmTemplateConfig (from LoadTemplateCommand)" type="handle" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Handle of the StmTemplateConfig object to merge the XML into."/>
    </stc:property>
    <stc:property category="input" name="SrcTagList" displayName="Source Tag List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tags of the elements from the XML string (TemplateXml) or file (TemplateXmlFileName) being merged into the StmTemplateConfig's TemplateXml." />
    </stc:property>
    <stc:property category="input" name="TargetTagList" displayName="Target Tag List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tags of the elements in the StmTemplateConfig's TemplateXml that the elements specified in SrcTagList will be inserted into." />
    </stc:property>
    <stc:property category="input" name="TagPrefix" displayName="Tag Prefix" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Prefix value prepended to all tags being merged from the XML string (TemplateXml) or file (TemplateXmlFileName)." />
    </stc:property>
    <stc:property category="input" name="TemplateXml" displayName="XML Template String" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="XML string that is a source for the elements being merged." />
    </stc:property>
    <stc:property category="input" name="TemplateXmlFileName" displayName="XML Template File" type="inputFilePath" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Location and filename of an XML template that is a source for the elements being merged." />
      <stc:attribute type="framework.MangleRelativePath" value="false" internalType="bool" />
    </stc:property>
    <stc:property category="input" name="EnableLoadFromFileName" displayName="Enable XML Template File" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True uses the XML Template specified by TemplateXmlFileName.  False uses the XML Template string specified by TemplateXML." />
    </stc:property>

<!-- CATEGORY: Framework: Template -->

</stc:class>


<stc:class name="ConfigTemplateStmPropertyModifierCommand" displayName="Configure XML Template StmPropertyModifier Command" bllDirectInterface="true" isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Adds or configures an StmPropertyModifier in a template stored in an StmTemplateConfig object." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Topology Template"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:enumeration name="EnumModifierType">
        <stc:enum name="RANGE"      value="0"   displayName="Range" />
<!--
        <stc:enum name="LIST"       value="1"   displayName="List" />
        <stc:enum name="TABLE"      value="2"   displayName="Table" />
-->
    </stc:enumeration>
    <stc:property category="input" name="StmTemplateConfig" displayName="StmTemplateConfig" type="handle" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Handle of the StmTemplateConfig object being modified." />
    </stc:property>
    <stc:property category="input" name="TagName" displayName="Tag Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Tag name of the StmPropertyModifier being added or configured." />
    </stc:property>
    <stc:property category="input" name="TargetObjectTagName" displayName="Target Object's Tag Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Tag name of the object being modified.  If configuring an existing modifier, this can be left empty." />
    </stc:property>
    <stc:property category="input" name="ObjectName" displayName="Object Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Class name of the object being modified.  If configuring an existing modifier, this can be left empty. " />
    </stc:property>
    <stc:property category="input" name="PropertyName" displayName="Property Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Name of the property being modified.  If configuring an existing modifier, this can be left empty. " />
    </stc:property>
    <stc:property category="input" name="PduXmlOffsetReference" displayName="PDU XML Offset Reference" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="PDU XML Offset reference in the form pdu_name.pdu_property.  This is used to identify an attribute in XML when the value being modified is a PDU XML string.  The OffsetReference must refer to an attribute that is already present in the XML string." />
    </stc:property>
    <stc:property category="input" name="StartList" displayName="Start Value List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of start values for the modifier.  For scalar properties, the list should contain only one item." />
    </stc:property>
    <stc:property category="input" name="StepList" displayName="Step Value List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of step values for the modifier." />
    </stc:property>
    <stc:property category="input" name="RepeatList" displayName="Repeat Value List" type="u32" default="0" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of repeat values for the modifier." />
    </stc:property>
    <stc:property category="input" name="RecycleList" displayName="Recycle Value List" type="u32" default="0" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of recycle values for the modifier." />
    </stc:property>
    <stc:property category="input" name="ModifierType" displayName="Modifier Type" type="u8" default="RANGE">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Type of modifier being added or configured. This will be assigned to an existing modifier if it does not match the current type." />
      <stc:enumerationRef ref="EnumModifierType"/>
    </stc:property>
    <stc:property category="input" name="TargetObjectStepList" displayName="Target Object Step List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of step values to apply to the start values (StartList) when a new target object is encountered." />
    </stc:property>
    <stc:property category="input" name="ResetOnNewTargetObject" displayName="Reset Start Value On New Target Object" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Reset the start value each time a new target object is encountered." />
    </stc:property>
<!-- CATEGORY: Framework: Template -->
</stc:class>





<stc:class  name="ProcessMethodologyTestReportCommand"
            displayName="Process Methodology Test Report"
            bllDirectInterface="true"
            isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="false"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Process the end of test report (JSON format) files, and generate a group of StmTestReport family of objects to hold the report information for automated query/analysis."/>

    <stc:property category="input" name="ReportFilename" displayName="Report File" type="inputFilePath" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription"
        value="Full path and name of the main report JSON file (the main file is testReport.json). The active test case is used if this property is blank. " />
    </stc:property>
<!-- CATEGORY: Results: Test Report -->
</stc:class>



<stc:class  name="ResultBaseCommand"
            displayName="Result Base Command"
            bllDirectInterface="true"
            canCreate="false"
            isInternal="true">

    <stc:enumeration name="EnumComparisonOperator">
        <stc:enum name="LESS_THAN"              value="0"   displayName="Less Than"/>
        <stc:enum name="LESS_THAN_OR_EQUAL"     value="1"   displayName="Less Than or Equal To"/>
        <stc:enum name="GREATER_THAN"           value="2"   displayName="Greater Than"/>
        <stc:enum name="GREATER_THAN_OR_EQUAL"  value="3"   displayName="Greater Than or Equal To"/>
        <stc:enum name="EQUAL"                  value="4"   displayName="Equal To"/>
        <stc:enum name="NOT_EQUAL"              value="5"   displayName="Not Equal To"/>
        <stc:enum name="BETWEEN"                value="6"   displayName="Between"/>
    </stc:enumeration>

    <stc:enumeration name="EnumReportGroup">
        <stc:enum name="SUMMARY"    value="0"   displayName="Summary"/>
        <stc:enum name="GROUP_1"    value="1"   displayName="Group 1"/>
        <stc:enum name="GROUP_2"    value="2"   displayName="Group 2"/>
        <stc:enum name="GROUP_3"    value="3"   displayName="Group 3"/>
        <stc:enum name="GROUP_4"    value="4"   displayName="Group 4"/>
        <stc:enum name="GROUP_5"    value="5"   displayName="Group 5"/>
        <stc:enum name="CONFIGURATION" value="6" displayName="Configuration"/>
    </stc:enumeration>

    <stc:property category="input" name="ReportGroup" displayName="Report Group" type="u8" default="GROUP_2">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Placement priority which determines the location the results will be displayed on the results page. Acceptable values (listed in order from highest priority to lowest) are: SUMMARY, GROUP_1, GROUP_2, GROUP_3, GROUP_4, or GROUP_5.  SUMMARY will be displayed at the top in the Summary section." />
            <stc:enumerationRef ref="spirent.methodology.ResultBaseCommand.EnumReportGroup"/>
    </stc:property>

</stc:class>


<stc:class  name="VerifyBaseCommand"
            displayName="Verify Base Command"
            baseClass="spirent.methodology.ResultBaseCommand"
            bllDirectInterface="true"
            canCreate="false"
            isInternal="true">

    <stc:property category="input" name="ApplyVerdictToSummary" displayName="Apply Verdict To Summary" type="bool" default="true">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True applies this verdict to the test verdict in the Summary section of the test results.  False does not use this verdict to determine the test verdict." />
    </stc:property>
    <stc:property category="input" name="ApplyVerdictToCommandPassFailState" displayName="Apply Verdict to Command's Pass/Fail State" type="bool" default="false">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True applies the verdict to the command's pass/fail state for use as en expression command within an IF or WHILE command. False will cause the command's pass/fail state to reflect the command's proper execution only." />
    </stc:property>

</stc:class>

<stc:class  name="VerifySingleBaseCommand"
            displayName="Verify Single Base Command"
            baseClass="spirent.methodology.VerifyBaseCommand"
            bllDirectInterface="true"
            canCreate="false"
            isInternal="true">

    <stc:property category="input" name="DisplayName" displayName="Display Name" type="string" default="">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Title to display for this result section in the test report file."/>
    </stc:property>

    <stc:property category="input" name="PassedVerdictExplanation" displayName="Passed Verdict Explanation" type="string" default="">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Statement explaining the verdict when the command passes."/>
    </stc:property>

    <stc:property category="input" name="FailedVerdictExplanation" displayName="Failed Verdict Explanation" type="string" default="">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Statement explaining the verdict when the command fails."/>
    </stc:property>

</stc:class>

<stc:class  name="VerifyMultiBaseCommand"
            displayName="Verify Single Base Command"
            baseClass="spirent.methodology.VerifyBaseCommand"
            bllDirectInterface="true"
            canCreate="false"
            isInternal="true">

    <stc:property category="input" name="DisplayNameList" displayName="Display Name List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of titles to display for this result section in the test report file.  Each title in the list should correspond with validation query/configuration."/>
    </stc:property>
    <stc:property category="input" name="PassedVerdictExplanationList" displayName="Passed Verdict Explanation List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of statements explaining the verdict when the command passes.  Each explanation in the list should correspond with validation query/configuration."/>
    </stc:property>

    <stc:property category="input" name="FailedVerdictExplanationList" displayName="Failed Verdict Explanation List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of statements explaining the verdict when the command fails.  Each explanation in the list should correspond with validation query/configuration.."/>
    </stc:property>

</stc:class>



<stc:class  name="VerifyResultBaseCommand"
            displayName="Verify Result Base Command"
            bllDirectInterface="true"
            canCreate="false"
            isInternal="true">


    <stc:enumeration name="EnumComparisonOperator">
        <stc:enum name="LESS_THAN"              value="0"   displayName="Less Than"/>
        <stc:enum name="LESS_THAN_OR_EQUAL"     value="1"   displayName="Less Than or Equal To"/>
        <stc:enum name="GREATER_THAN"           value="2"   displayName="Greater Than"/>
        <stc:enum name="GREATER_THAN_OR_EQUAL"  value="3"   displayName="Greater Than or Equal To"/>
        <stc:enum name="EQUAL"                  value="4"   displayName="Equal To"/>
        <stc:enum name="NOT_EQUAL"              value="5"   displayName="Not Equal To"/>
        <stc:enum name="BETWEEN"                value="6"   displayName="Between"/>
    </stc:enumeration>

    <stc:property category="input" name="PropertyValue" displayName="Property Value" type="double" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Number to compare the property's actual value to.  Comparison is based on OperationType (all types valid except for BETWEEN)." />
    </stc:property>
     <stc:property category="input" name="MinPropertyValue" displayName="Min Property Value" type="double" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Minimum acceptable property value when OperationType is BETWEEN." />
    </stc:property>
     <stc:property category="input" name="MaxPropertyValue" displayName="Max Property Value" type="double" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Maximum acceptable property value when OperationType is BETWEEN." />
    </stc:property>
    <stc:property category="input" name="OperationType" displayName="Operation Type" type="u8" default="GREATER_THAN">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Type of comparison operator being used.  Acceptable values are: LESS_THAN, LESS_THAN_OR_EQUAL, GREATER_THAN, GREATER_THAN_OR_EQUAL, EQUAL, NOT_EQUAL, or BETWEEN." />
      <stc:enumerationRef ref="EnumComparisonOperator"/>
    </stc:property>
    <stc:property category="input" name="PollInterval" displayName="Poll Interval (sec)" type="u32" default="10">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Interval in seconds to poll the state of the specified expression." />
    </stc:property>
    <stc:property category="input" name="MaxWaitTime" displayName="Maximum Wait Time (sec)" type="u32" default="10">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Maximum amount of time in seconds to wait for the specified expression to be met." />
    </stc:property>
</stc:class>


<stc:class  name="VerifyTrafficResultDemoCommand"
            displayName="Verify Traffic Result Demo Command"
            baseClass="spirent.methodology.VerifyResultBaseCommand"
            bllDirectInterface="true"
            isInternal="true">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Verified traffic results for a demonstration."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Results"/>

    <stc:enumeration name="EnumResultProperties">
        <stc:enum name="DROPPED_FRAME_COUNT"    value="0"   displayName="Dropped frame count"/>
        <stc:enum name="MIN_LATENCY"            value="1"   displayName="Min Latency (us)"/>
        <stc:enum name="MAX_LATENCY"            value="2"   displayName="Max Latency (us)"/>
    </stc:enumeration>

    <stc:property category="input" name="PropertyName" displayName="Property Name" type="u8" default="DROPPED_FRAME_COUNT">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Property name being compared.  Acceptable values are: DROPPED_FRAME_COUNT, MIN_LATENCY, or MAX_LATENCY." />
      <stc:enumerationRef ref="EnumResultProperties"/>
    </stc:property>
</stc:class>


<stc:class name="CompleteIterationCommand"
           displayName="Complete Iteration Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Collects and summarizes the results for the current iteration."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Iteration Framework"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
<!-- CATEGORY: Framework: Iteration -->
</stc:class>

<stc:class name="VerifyMultipleDbQueryCommand"
            displayName="Verify Multiple DB Queries"
            baseClass="spirent.methodology.VerifyMultiBaseCommand"
            bllDirectInterface="true">
        <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Verifies that each query in a list of SQL queries yields row count = 0."/>
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Results"/>

        <stc:property category="input" name="SqlQueryList" displayName="Sql Query List" type="string" default="" minOccurs="1" maxOccurs="unbounded">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of SQL queries to be executed."/>
        </stc:property>
        <stc:property category="input" name="UseMultipleResultsDatabases" displayName="Has Multiple Results Databases" type="bool" default="false">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True means there are multiple results databases (SaveResultsCommand LoopMode = Append) and all active results databases will be queried. False means there is only a single results database (SaveResultsCommand LoopMode = Overwrite), so if multiple databaes exist, an error will occur." />
        </stc:property>
        <stc:property category="input" name="UseSummary" displayName="Use Summary Database Only" type="bool" default="false">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True uses only the summary database.  False uses the iteration databases. Only valid if UseMultipleResultsDatabases is False." />
        </stc:property>
<!-- CATEGORY: Results: Database and SQL -->
<!-- CATEGORY: Results: Test Report -->
</stc:class>

<stc:class name="VerifyDbQueryCommand"
            displayName="Verify DB Query"
            baseClass="spirent.methodology.VerifySingleBaseCommand"
            bllDirectInterface="true">
        <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Verifies that an SQL query yields a row count that meets the specified criteria."/>
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Results"/>

        <stc:property category="input" name="SqlQuery" displayName="Sql Query" type="string" default="">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="SQL query string to be executed."/>
        </stc:property>
        <stc:property category="input" name="OperationType" displayName="Operation Type" type="u8" default="GREATER_THAN">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Type of comparison operator being used.  Acceptable values are: LESS_THAN, LESS_THAN_OR_EQUAL, GREATER_THAN, GREATER_THAN_OR_EQUAL, EQUAL, NOT_EQUAL, or BETWEEN." />
            <stc:enumerationRef ref="spirent.methodology.ResultBaseCommand.EnumComparisonOperator"/>
        </stc:property>
        <stc:property category="input" name="RowCount" displayName="Row Count" type="u64" default="0">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Number to compare the row count that the SQL query yields.  Comparison is based on OperationType (all types valid except for BETWEEN)." />
        </stc:property>
        <stc:property category="input" name="MinRowCount" displayName="Min Row Count (Inclusive)" type="u64" default="0">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Minimum acceptable row count of the SQL query when OperationType is BETWEEN." />
        </stc:property>
        <stc:property category="input" name="MaxRowCount" displayName="Max Row Count (Inclusive)" type="u64" default="0">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Maximum acceptable row count of the SQL query when OperationType is BETWEEN." />
        </stc:property>
        <stc:property category="input" name="UseMultipleResultsDatabases" displayName="Has Multiple Results Databases" type="bool" default="false">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True means there are multiple results databases (SaveResultsCommand LoopMode = Append) and all active results databases will be queried. False means there is only a single results database (SaveResultsCommand LoopMode = Overwrite), so if multiple databaes exist, an error will occur." />
        </stc:property>
        <stc:property category="input" name="UseSummary" displayName="Use the summary db only" type="bool" default="false">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True uses only the summary database.  False uses the iteration databases. Only valid if UseMultipleResultsDatabases is False." />
        </stc:property>
<!-- CATEGORY: Results: Database and SQL -->
<!-- CATEGORY: Results: Test Report -->
</stc:class>

<stc:class name="RunPyScriptCommand" displayName="Run a Python Script" bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Runs a python script."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>

    <stc:property category="input" name="ScriptFilename" displayName="Python script file" type="inputFilePath" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Location and filename (without the py extension) of the python script to be executed."/>
        <stc:attribute type="framework.MangleRelativePath" value="false" internalType="bool" />
    </stc:property>
    <stc:property category="input" name="MethodName" displayName="Method within the script" type="string" default="run">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Method in the python script to be executed."/>
    </stc:property>
    <stc:property category="input" name="TagName" displayName="Name of the tag associated with the target object(s)" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Tag name used to form a collection of objects for the script to act on."/>
    </stc:property>
    <stc:property category="input" name="Params" displayName="A string for the script" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="String parameter passed to the script for it to work with."/>
      <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>
    <stc:property category="output" name="ErrorMsg" displayName="Error Message" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Last error message recorded by the command."/>
    </stc:property>
<!-- CATEGORY: Run and Execute -->
</stc:class>

<stc:class 
    name="RunCustomerPyScriptCommand" 
    displayName="Run Customer Python Script" 
    bllDirectInterface="true" 
    pythonVirtualenv="spirent.methodology">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Run Customer Python Script."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>

    <stc:property category="input" name="EnableRunCustomerScript" displayName="Enable Run Customer Script" type="bool" default="false">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Enable or disable run customer script." />
    </stc:property>

    <stc:property category="input" name="ScriptFilename" displayName="Python script file" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Filename of the python script to be executed."/>
        <stc:attribute type="framework.MangleRelativePath" value="false" internalType="bool" />
    </stc:property>

    <stc:property category="input" name="MethodName" displayName="Method within the script" type="string" default="run">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Method in the python script to be executed."/>
    </stc:property>

    <stc:property category="input" name="Params" displayName="A string for the script" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="String parameter passed to the script for it to work with."/>
    </stc:property>

    <stc:property category="input" name="EnableRunOnRemoteMachine" displayName="Enable Run On Remote Machine" type="bool" default="false">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Enable or disable run customer script on a remote machine." />
    </stc:property>

    <stc:property category="input" name="RemoteMachineAddr" displayName="Remote Machine IP Address" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="IP Address of the remote machine."/>
    </stc:property>

    <stc:property category="input" name="UserName" displayName="User Name" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="User name of the remote machine."/>
    </stc:property>

    <stc:property category="input" name="Password" displayName="Password" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Password of the remote machine."/>
    </stc:property>

    <stc:property category="input" name="DestDir" displayName="Destinaton Directory" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Destinaton directory of the remote machine to run the script."/>
    </stc:property>

    <stc:property category="output" name="ErrorMsg" displayName="Error Message" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Last error message recorded by the command."/>
    </stc:property>
<!-- CATEGORY: Run and Execute -->
</stc:class>

<stc:class name="ModifyHandleListCommand" displayName="Modify a BLL command's handle list property" bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Modifies a property of a BLL command that contains a list of handles."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Data Model Configuration"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="BllCommandTagName" displayName="Tag that identifies target BLL Command" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Tag name of the target BLL command being modified."/>
    </stc:property>
    <stc:property category="input" name="PropertyName" displayName="Property To Modify" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Name of the property in the target BLL command being modified." />
    </stc:property>
    <stc:property category="input" name="TagList" displayName="Tag List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tags that will be expanded into BLL objects, and then passed in to the command.  Handles of the expanded objects will be appended to existing handles."/>
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="core.ValidHandleTypes" value="Host,Router,EmulatedDevice,StreamBlock,Tag" />
    </stc:property>
    <stc:property category="input" name="OverwriteProperty" displayName="Overwrite Property" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True overwrites the property.  False appends the property." />
    </stc:property>
<!-- CATEGORY: Framework: Data Model -->
</stc:class>

<stc:class  name="VerifyDynamicResultViewDataCommand"
            displayName="Verify Dynamic Result View Data Command"
            bllDirectInterface="true"
            baseClass="spirent.methodology.VerifySingleBaseCommand">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Verifies that a Dynamic Result View (DRV) yields a result count that meets the specified criteria."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Results"/>

    <stc:property category="input" name="DynamicResultViewName" displayName="Dynamic Result View Name" type="string" default="" minOccurs="1" maxOccurs="1">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Name of the Dynamic Result View to get the results from."/>
    </stc:property>

    <stc:property category="input" name="OperationType" displayName="Operation Type" type="u8" default="GREATER_THAN">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Type of comparison operator being used.  Acceptable values are: LESS_THAN, LESS_THAN_OR_EQUAL, GREATER_THAN, GREATER_THAN_OR_EQUAL, EQUAL, NOT_EQUAL, or BETWEEN." />
            <stc:enumerationRef ref="spirent.methodology.ResultBaseCommand.EnumComparisonOperator"/>
    </stc:property>

    <stc:property category="input" name="ResultCount" displayName="Result Count" type="u64" default="0">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Number to compare the result count that the DRV yields.  Comparison is based on OperationType (all types valid except for BETWEEN)." />
    </stc:property>

    <stc:property category="input" name="MinResultCount" displayName="Min Result Count (Inclusive)" type="u64" default="0">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Minimum acceptable result count of the DRV when OperationType is BETWEEN." />
    </stc:property>

    <stc:property category="input" name="MaxResultCount" displayName="Max Result Count (Inclusive)" type="u64" default="0">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Maximum acceptable result count of the DRV when OperationType is BETWEEN." />
    </stc:property>

<!-- CATEGORY: Results: Test Report -->

</stc:class>

<stc:class  name="ExportDynamicResultViewDataCommand"
            displayName="Export Dynamic Result View Data Command"
            bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Exports Dynamic Result View (DRV) data to the JSON test report file."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Results"/>

    <stc:property category="input" name="ApplyVerdictToSummary" displayName="Apply Verdict To Summary (ignored)" type="bool" default="true">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="This property is not used by this command and is present only for backward compatibility." />
    </stc:property>

    <stc:property category="input" name="DynamicResultViewNameList" displayName="Dynamic Result View Name List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of Dynamic Result View names being exported."/>
    </stc:property>

    <stc:property category="input" name="ExportDisabledAutoGroupData" displayName="Export Disabled Auto Group Data" type="bool" default="false">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True enables grouping by DisabledAutoGroup, where data is appended to the end of the group.  False disables grouping and data is appended to the current report regardless of the grouping level." />
    </stc:property>

    <stc:property category="input" name="DisplayNameList" displayName="Display Name List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of titles to display for this result section in the test report file.  Each title in the list should correspond to a DRV name in DynamicResultViewNameList. "/>
    </stc:property>

    <stc:property category="input" name="ReportGroup" displayName="Report Group" type="u8" default="GROUP_2">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Placement priority which determines the location the results will be displayed on the results page. Acceptable values (listed in order from highest priority to lowest) are: SUMMARY, GROUP_1, GROUP_2, GROUP_3, GROUP_4, or GROUP_5.  SUMMARY will be displayed at the top in the Summary section." />
            <stc:enumerationRef ref="spirent.methodology.ResultBaseCommand.EnumReportGroup"/>
    </stc:property>

    <stc:property category="input" name="EnableResultGrouping" displayName="Enable Result Grouping" type="bool" default="true">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True enables result grouping by column.  False disables result grouping by column." />
    </stc:property>

<!-- CATEGORY: Results: Test Report -->

</stc:class>

<stc:class name="CreateMethodologyChartCommand"
           displayName="Create Methodology Chart Command"
           baseClass="spirent.methodology.ResultBaseCommand"
           bllDirectInterface="true">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Exports chart information to the JSON test report file."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Results"/>

    <stc:enumeration name="EnumSourceDatabase">
        <stc:enum name="LAST_ITERATION" value="0" displayName="Last Iteration Database"/>
        <stc:enum name="SUMMARY" value="1" displayName="Summary Database"/>
        <stc:enum name="ALL_ITERATION" value="2" displayName="All Iteration Databases"/>
    </stc:enumeration>

    <stc:property category="input" name="ChartTemplateJsonFileName" displayName="Chart Template File" type="inputFilePath" default="Line_Template.json">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Location and filename of the JSON template for the chart.  Provided basic templates are: Line_Template.json and Column_Template.json." />
      <stc:attribute type="framework.MangleRelativePath" value="false" internalType="bool" />
    </stc:property>

    <stc:property category="input" name="Title" displayName="Chart Title" type="string" default="Result Node Param Handles">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Title of the Chart." />
    </stc:property>

    <stc:property category="input" name="XAxisTitle" displayName="X Axis Title" type="string" default="Id">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Title of the X-Axis." />
    </stc:property>

    <stc:property category="input" name="XAxisCategories" displayName="X Axis Categories" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Labels or values for the individual tick marks along the X-Axis.  This is a list of strings or SQL queries." />
    </stc:property>

    <stc:property category="input" name="YAxisTitle" displayName="Y Axis Title" type="string" default="Handle">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Title of the Y-Axis." />
    </stc:property>

    <stc:property category="input" name="YAxisCategories" displayName="Y Axis Categories" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Labels or values for the individual tick marks along the Y-Axis.  This is a list of strings or SQL queries." />
    </stc:property>

    <stc:property category="input" name="Series" displayName="Series' Data" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Set of data to be plotted on the chart.  This is a list of strings or SQL queries.  Format example for a SINGLE SeriesDataType: 1, 2, 3, 4.  Format example for a PAIR SeriesDataType: [1, 1], [2, 2]" />
    </stc:property>

    <stc:property category="input" name="TemplateModifier" displayName="Template Modifier" type="string" default='{"series":[{"name": "Handles"}]}'>
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON string to modify chart properties.  Syntax follows HighCharts API and will be appended to the JSON test result file.  Specified properties will be merged with and overwrite existing properties in the file.  SQL Queries can be inserted to the JSON string by delimiting the queries with {{ and }}." />
      <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>

    <stc:property category="input" name="SrcDatabase" displayName="Source Database" type="u8" default="SUMMARY">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Database(s) to execute the SQL queries on.  Acceptable values are: LAST_ITERATION, SUMMARY, or ALL_ITERATION." />
        <stc:enumerationRef ref="EnumSourceDatabase"/>
    </stc:property>

<!-- CATEGORY: Results: Test Report -->

</stc:class>

<stc:class name="InitRealTimeResultsCommand"
           displayName="Initialize Real Time Results Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Setup real time result subscriptions for a methodology."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>

    <stc:property category="input" name="InputJson" displayName="Input JSON" type="string" default='[]'>
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON string defining real time results subscriptions for the methodology framework. Information will be used to configure multiple subscriptions within an StmRtResult object." />
      <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>
    <stc:property category="input" name="InputJsonFileName" displayName="Input JSON File Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON string defining real time results subscriptions for the methodology framework. Information will be used to configure multiple subscriptions within an StmRtResult object." />
    </stc:property>
    <stc:property category="input" name="EnableLoadFromFileName" displayName="Enable JSON File" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True loads the JSON configuration specified by InputJsonFileName.  False loads the JSON string specified by InputJson." />
    </stc:property>

<!-- CATEGORY: Results: Real-Time Results -->

<!-- SAMPLE_JSON:
This sample shows the four basic combinations of table/chart with subscribe/query.

The ports that will be sampled will be those tagged with "SourcePorts" tag.
Subscribe samples: sampled frame rate for each port.
In the SubscribedChart definition, the generatorportresults result uses "legend" to rename the attribute list and "prefix_port_location" is set to "CHASSIS_IP" (default) to prefix the chassis location to the legend. In the analyzerportresults result, "legend" is not specified and the default display name of the attribute is used. Property "prefix_port_location" is set to "NONE" so the chassis location is not prefixed to the legend.

[
    {
        "enable": true,
        "result_id": "SubscribedTable",
        "type": "table",
        "source_type": "RESULTS_SUBSCRIBE",
        "definition": {
            "headers": ["Sample Time", "Frame Rate"],
            "rows": []
        },
        "subscribe": [
            {
                "config_type": "generator",
                "result_type": "generatorportresults",
                "view_attribute_list": ["generatorsigframerate"],
                "result_parent_tags": ["SourcePorts"],
                "interval": "6"
            }
        ]
    },
    {
        "enable": true,
        "result_id": "SubscribedChart",
        "type": "chart",
        "source_type": "RESULTS_SUBSCRIBE",
        "subscribe": [
            {
                "config_type": "generator",
                "result_type": "generatorportresults",
                "view_attribute_list": ["generatorsigframerate"],
                "legend": ["Tx Rate"],
                "prefix_port_location": "CHASSIS_IP",
                "result_parent_tags": ["SourcePorts"]
            },
            {
                "config_type": "analyzer",
                "result_type": "analyzerportresults",
                "view_attribute_list": ["sigframerate"],
                "prefix_port_location": "NONE",
                "result_parent_tags": ["TargetPorts"]
            }
        ],
        "definition": {
            "chart" :
            {
                "type" : "line"
            },
            "title" :
            {
                "text" : "System Level Tx/Rx Rates"
            },
            "subtitle" :
            {
                "text" : "Tx/Rx rate over time."
            },
            "xAxis" :
            {
                "title" :
                {
                    "text" : "Time (s)"
                },
                "gridLineWidth" : 1,
                "minPadding" : 0.2,
                "maxPadding" : 0.2
            },
            "yAxis" :
            {
                "title" :
                {
                    "text" : "Rate (fps)"
                },
                "minPadding" : 0.2,
                "maxPadding" : 0.2
            },
            "legend" :
            {
                "enabled" : true
            },
            "plotOptions" :
            {
                "series" :
                {
                    "lineWidth" : 1
                }
            },
            "tooltip" :
            {
                "headerFormat" : "<span style=\"font-size: 10px\">{point.key}s</span><br/>"
            },
            "series" : [
            ]
        }
    },
    {
        "enable": true,
        "result_id": "QueryTable",
        "type": "table",
        "source_type": "SUMMARY_DB",
        "definition": {
            "headers": ["Sample Time", "Frame Rate"],
            "rows": []
        },
        "query": {
            "timestamp_column_name": "timestamp",
            "data_column_names": [
                "timestamp", "framerate"
            ],
            "table": "SourceFrameRateTable"
        }
    },
    {
        "enable": true,
        "result_id": "QueryChart",
        "type": "chart",
        "source_type": "SUMMARY_DB",
        "query": {
            "timestamp_column_name": "timestamp",
            "data_column_names": [
                "timestamp", "tx", "rx"
            ],
            "table": "TxRxFrameRateTable"
        },
        "definition": {
            "chart" :
            {
                "type" : "line"
            },
            "title" :
            {
                "text" : "System Level Tx/Rx Rates"
            },
            "subtitle" :
            {
                "text" : "Tx/Rx rate over time."
            },
            "xAxis" :
            {
                "title" :
                {
                    "text" : "Time (s)"
                },
                "gridLineWidth" : 1,
                "minPadding" : 0.2,
                "maxPadding" : 0.2
            },
            "yAxis" :
            {
                "title" :
                {
                    "text" : "Rate (fps)"
                },
                "minPadding" : 0.2,
                "maxPadding" : 0.2
            },
            "legend" :
            {
                "enabled" : true
            },
            "plotOptions" :
            {
                "series" :
                {
                    "lineWidth" : 1
                }
            },
            "tooltip" :
            {
                "headerFormat" : "<span style=\"font-size: 10px\">{point.key}s</span><br/>"
            },
            "series" : [
            ]
        }
    }
]

-->
</stc:class>

<stc:class name="UpdateRealTimeResultsCommand"
           displayName="Update Real Time Results Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Polls a database or subscription (determined by ResultInfoJson of an StmRtResult object) and updates the StmRtResult object."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>

    <stc:property category="state" name="ErrorJsonString" displayName="List of error messages" type="string" default='[]'>
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="A list of error messages to avoid duplication of logging in the background timer context. Each error message is a single string in the list encoded as a JSON list of strings." />
      <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>
<!-- CATEGORY: Results: Real-Time Results -->
</stc:class>

<stc:class name="SetTestStatusCommand"
           displayName="Set Methodology Test Status Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Set methodology test status."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>

    <stc:property category="input" name="StatusMsg" displayName="Status Message" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Status Message" />
    </stc:property>
    <stc:property category="input" name="AddNfviEvent" displayName="Add Status as NFVI Event" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True adds this status as an NFVI event in the DB.  False does not add this status as an NFVI event." />
    </stc:property>

<!-- CATEGORY: Results: Real-Time Results -->
</stc:class>


<stc:class name="StartOfTestCommand"
           displayName="Start Of Test Command"
           bllDirectInterface="true">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Initializes the test results interface."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Results"/>

    <stc:property category="input" name="CreateDefaultNfviRealTimeResults" displayName="Create Default NFVi Real Time Results" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Creates the default NFVi real time result objects when InitRealTimeResultsCommand is executed with metrics agent resources configured.   After the first time default results are created, this property is ignored on subsequent calls of the command. The property should remain enabled unless specifying custom NFVi results." />
    </stc:property>

<!-- CATEGORY: Results: Test Report -->
</stc:class>

<stc:class name="EndOfTestCommand"
           displayName="End Of Test Command"
           bllDirectInterface="true">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Aggregates and writes out the test results."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Results"/>

    <stc:property category="input" name="SetUnknownVerdictToPass" displayName="Set An Unknown Verdict" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Set an UNKNOWN verdict to a PASSED verdict." />
    </stc:property>
<!-- CATEGORY: Results: Test Report -->
</stc:class>

<!-- Template group operations -->
<stc:class name="CreateTemplateMixCommand"
           displayName="Create Template Mix Command"
           baseClass="stak.StakGroupCommand" bllDirectInterface="true"
           canCreate="false" isInternal="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Create Template Mix Command"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Topology Template"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <!-- FIXME: Add this back in once inheritence works -->
    <!--
    <stc:property category="input" name="MixInfo" displayName="Mix Info" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription"
        value="JSON string representation of the mix (including table data)"/>
    </stc:property>
    <stc:property category="input" name="MixTagName" displayName="Mix Container Tag Name" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Mix Container Tag Name"/>
    </stc:property>
    <stc:property category="input" name="AutoExpandTemplateMix" displayName="Automatically expand templates in the mix" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Automatically expand templates." />
    </stc:property>
    <stc:property category="state" name="MixInfoJsonSchema" displayName="Table Data JSON Schema" type="string" default=''>
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription"
         value="JSON schema that will be used to validate the MixInfo property's value."/>
    </stc:property>
    -->
    <stc:property category="output" name="StmTemplateMix" displayName="XML Container Aggregator object (StmTemplateMix)" type="handle" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="StmTemplate Mix container aggregator object"/>
    </stc:property>
</stc:class>

<stc:class name="ExpandTemplateMixCommand"
           displayName="Expand Template Mix Command"
           bllDirectInterface="true" canCreate="false" isInternal="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Expand Template Mix Command"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Topology Template"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="StmTemplateMix" displayName="XML Container object (StmTemplateMix)" type="handle" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="StmTemplate Mix container object"/>
    </stc:property>
</stc:class>

<stc:class name="AddRowToDbTableCommand"
           displayName="Add Row To DB Table"
           bllDirectInterface="true"
	   isInternal="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Adds queried results to a new or existing table."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Results"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:enumeration name="EnumSourceDatabase">
        <stc:enum name="LAST_ITERATION" value="0" displayName="Last Iteration Database"/>
        <stc:enum name="SUMMARY" value="1" displayName="Summary Database"/>
        <stc:enum name="ALL_ITERATION" value="2" displayName="All Iteration Databases"/>
    </stc:enumeration>
    <stc:enumeration name="EnumDestinationDatabase">
        <stc:enum name="LAST_ITERATION" value="0" displayName="Last Iteration Database"/>
        <stc:enum name="SUMMARY" value="1" displayName="Summary Database"/>
    </stc:enumeration>

    <stc:property category="input" name="SrcDatabase" displayName="Source Database" type="u8" default="ALL_ITERATION">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Database(s) to execute the SQL queries on.  Acceptable values are: LAST_ITERATION, SUMMARY, or ALL_ITERATION." />
            <stc:enumerationRef ref="EnumSourceDatabase"/>
    </stc:property>
    <stc:property category="input" name="DstDatabase" displayName="Destination Database" type="u8" default="SUMMARY">
            <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Database where the new table is being added." />
            <stc:enumerationRef ref="EnumDestinationDatabase"/>
    </stc:property>
    <stc:property category="input" name="SqlCreateTable" displayName="Create Table Sql Statement" type="string"
                  default="CREATE TABLE NewTableName ('Column1' INTEGER, 'Column2' TIMESTAMP)">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="SQL statement to specify a new table name for an existing destination table OR to create a new destination table."/>
    </stc:property>
    <stc:property category="input" name="SqlQuery" displayName="Source Data Sql Query" type="string"
                  default="SELECT Id, CreatedTime From DataSet">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="SQL query to be performed on SrcDatabase.  The results will populate an existing or new table specified in SqlCreateTable.  The number of columns in the query must match the number of columns in the table."/>
    </stc:property>

</stc:class>

<!-- Tier 2 Template Commands -->
<stc:class
    name="BuildTemplateNetworkIfStackCommand"
    displayName="Build Template Network Interface Stack Command"
    bllDirectInterface="true"
    isInternal="false">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Builds a network interface stack under the specified device in a template." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Topology Template"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="StmTemplateConfig" displayName="StmTemplateConfig" type="handle" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Handle of the StmTemplateConfig object being modified." />
    </stc:property>
    <stc:property category="input" name="TagPrefix" displayName="Tag Prefix"
                  type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Prefix value that will be prepended to all interface tags generated from this command." />
    </stc:property>
    <stc:property category="input" name="ParentDeviceTagName" displayName="Parent Device Tag Name" type="string" default="ttEmulatedDevice">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Name of a tag that is tagging the emulated device that will serve as the parent for the created network interfaces." />
    </stc:property>
    <stc:property category="input" name="InputJson" displayName="JSON Input" type="string" default='[{"className": "EthIIIf", "tagName": "ttEthIIIf", "isLowestLayer": true}, {"className": "Ipv4If", "tagName": "ttIpv4If"}]'>
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON string representation of parameters to build the interface stack under the device in the StmTemplateConfig."/>
        <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>

<!-- CATEGORY: Framework: Template -->

<!-- SAMPLE_JSON:
This example builds the network interface stack for PPPoE resolve IPv4 and IPv6 addresses over two VLANs.
[
    {
        "useIf": true,
        "className": "EthIIIf",
        "tagName": "ttEthIIIf",
        "isLowestLayer": true
    },
    {
        "useIf": true,
        "className": "VlanIf",
        "tagName": "ttVlanIf"
    },
    {
        "useIf": false,
        "className": "VlanIf",
        "tagName": "ttInnerVlanIf"
    },
    {
        "useIf": true,
        "className": "PppoeIf",
        "tagName": "ttPppoeIf",
        "stackSplit": [
            [
                {
                    "className": "PppIf",
                    "tagName": "ttPppIf"
                },
                {
                    "className": "Ipv4If",
                    "tagName": "ttIpv4If",
                    "isTli": true,
                    "isPrimary": true
                }
            ],
            [
                {
                    "className": "PppIf",
                    "tagName": "ttIpv6PppIf"
                },
                {
                    "className": "Ipv6If",
                    "tagName": "ttIpv6If",
                    "isTli": true,
                    "isPrimary": true
                }
            ],
            [
                {
                    "className": "PppIf",
                    "tagName": "ttIpv6LinkLocalPppIf"
                },
                {
                    "className": "Ipv6If",
                    "tagName": "ttLinkLocalIf",
                    "isTli": true,
                    "isPrimary": false
                }
            ]
        ]
    }
]
-->
</stc:class>

<stc:class
    name="CreateTemplateConfigCommand"
    displayName="Create Template Config Command"
    bllDirectInterface="true"
    isInternal="false">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Creates an StmTemplateConfig by loading an XML template and modifying it." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Topology Template"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="AutoExpandTemplate" displayName="Automatically Expand Template" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True expands the template mix before command completes. False will not expand the template mix." />
    </stc:property>
    <stc:property category="input" name="StmTemplateMix" displayName="Parent StmTemplateMix object" type="handle" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Handle of an StmTemplateMix object to use for the parent of the created StmTemplateConfig." />
    </stc:property>
    <stc:property category="input" name="InputJson" displayName="JSON Input" type="string" default='{"baseTemplateFile": "IPv4_NoVlan.xml"}'>
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON string representation of parameters to load and modify template(s) into the StmTemplateConfig."/>
        <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>
    <stc:property category="input" name="CopiesPerParent" displayName="Number of copies to make per Target Tag object" type="u32" default="1">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Number of copies of the template to make per Target Tag object." />
    </stc:property>
    <stc:property category="input" name="SrcTagList" displayName="Source Tag List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tags that indicate where in the XML template the config will be expanded from." />
    </stc:property>
    <stc:property category="input" name="TargetTagList" displayName="Target Tag List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tags that indicate where in the STC configuration the template will be copied to.  If empty, the target will be assumed to be Project." />
    </stc:property>
    <stc:property category="input" name="TemplateTagName" displayName="Template Tag Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="If set, tag the created Template Config with the named tag"/>
    </stc:property>
    <stc:property category="output" name="StmTemplateConfig" displayName="XML container object (StmTemplateConfig)" type="handle" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="StmTemplateConfig container object"/>
    </stc:property>

<!-- CATEGORY: Framework: Template -->

<!-- SAMPLE_JSON:
This sample includes merging in an IsisRouterConfig, modifying property values, and adding a Vlan and setting up the
proper relations.
{
  "baseTemplateFile": "IPv4_NoVlan.xml",
  "modifyList": [
    {
      "operationList": [
        {
          "merge": {
            "mergeSourceTag": "ttIsisRouterConfig",
            "mergeSourceTemplateFile": "AllRouters.xml",
            "mergeTargetTag": "ttEmulatedDevice"
          }
        },
        {
          "propertyValue": {
            "className": "EmulatedDevice",
            "tagName": "ttEmulatedDevice",
            "propertyValueList": {
              "RouterId": "192.0.1.1"
            }
          }
        },
        {
          "addObject": {
            "className": "VlanIf",
            "parentTagName": "ttEmulatedDevice",
            "tagName": "ttVlanIf"
          }
        },
        {
          "stmPropertyModifier": {
            "className": "EmulatedDevice",
            "tagName": "ttEmulatedDevice.RouterId",
            "parentTagName": "ttEmulatedDevice",
            "propertyName": "RouterId",
            "propertyValueList": {
              "Start": "100.0.0.1",
              "Step": "0.0.0.1"
            }
          }
        },
        {
          "relation": {
            "relationType": "StackedOnEndpoint",
            "removeRelation": true,
            "targetTag": "ttIpv4If",
            "sourceTag": "ttEthIIIf"
          }
        },
        {
          "relation": {
            "relationType": "StackedOnEndpoint",
            "removeRelation": false,
            "targetTag": "ttVlanIf",
            "sourceTag": "ttIpv4If"
          }
        },
        {
          "relation": {
            "relationType": "StackedOnEndpoint",
            "removeRelation": false,
            "targetTag": "ttEthIIIf",
            "sourceTag": "ttVlanIf"
          }
        }
      ]
    }
  ]
}
-->
<!-- SAMPLE_JSON:
This sample includes adding a RangeModifier to a PDU and modifying a PDU with a pduModifierList.
{
  "baseTemplateFile": "Ipv4_Stream.xml",
  "modifyList": [
    {
      "operationList": [
        {
          "addObject": {
            "className": "RangeModifier",
            "parentTagName": "ttStreamBlock",
            "tagName": "ttRangeModifier"
          }
        },
        {
          "propertyValue": {
            "className": "RangeModifier",
            "tagName": "ttRangeModifier",
            "propertyValueList": {
              "ModifierMode": "INCR",
              "Mask": "255.255.255.255",
              "StepValue": "0.0.0.1",
              "RecycleCount": "10",
              "RepeatCount": "0",
              "Data": "192.0.2.1",
              "DataType": "NATIVE",
              "EnableStream": "TRUE",
              "Offset": "0",
              "OffsetReference": "ip_1.destAddr",
              "Active": "TRUE",
              "LocalActive": "TRUE",
              "Name": "IPv4 Modifier"
            }
          }
        },
        {
          "propertyValue": {
            "className": "StreamBlock",
            "tagName": "ttStreamBlock",
            "propertyValueList": {
              "FrameConfig": "<frame><config><pdus><pdu name=\"eth1\" pdu=\"ethernet:EthernetII\"></pdu><pdu name=\"ip_1\" pdu=\"ipv4:IPv4\"><totalLength>20</totalLength><checksum>14739</checksum><sourceAddr>192.85.1.3</sourceAddr><tosDiffserv name=\"anon_2646\"><tos name=\"anon_2647\"></tos></tosDiffserv></pdu></pdus></config></frame>"
            }
          }
        },
        {
          "pduModifier": {
            "templateElementTagName": "ttStreamBlock",
            "offsetReference": "ip_1.sourceAddr",
            "value": "33.3.3.3"
          }
        }
      ]
    }
  ]
}
-->
</stc:class>


<stc:class name="CreateProtocolMixCommand"
           displayName="Create Protocol Mix Command"
           baseClass="spirent.methodology.CreateTemplateMixCommand"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Command for creating mixtures of protocols on Emulated Device blocks."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>

    <stc:property category="input" name="MixInfo" displayName="Mix Info" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON string representation of the protocol mixes (including table data)"/>
        <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>
    <stc:property category="input" name="MixTagName" displayName="Mix Container Tag Name" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Name to use when tagging the output StmProtocolMix.  If left blank, StmProtocolMix will not be tagged."/>
    </stc:property>
    <stc:property category="input" name="PortGroupTagList" displayName="Port Group Tag" type="string" default="" minOccurs="0" maxOccurs="unbounded">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Tag name representing the port group on which devices and protocols should be expanded on."/>
    </stc:property>
    <stc:property category="state" name="GroupCommandTagInfo" displayName="Group Command Tag Info" type="string" default="" >
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON structure containing the names of the tags used to refer to commands in this group."/>
    </stc:property>

    <!-- This should be from the base class -->
    <stc:property category="input" name="AutoExpandTemplateMix" displayName="Automatically expand templates in the mix" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True expands the template mix before command completes. False will not expand the template mix." />
    </stc:property>

<!-- CATEGORY: Protocol -->

<!-- SAMPLE_JSON:
This sample includes 2 BGP IPv4 Routers, 2 OSPFv3 Routers, and 1 ISIS Dual Stack Router
{
  "deviceCount": 10,
  "table": [
    {
      "devicesPerBlock": 2,
      "tagPrefix": "Left_",
      "modifyList": [
        {
          "operationList": [
            {
              "merge": {
                "mergeSourceTag": "ttBgpRouterConfig",
                "mergeSourceTemplateFile": "AllRouters.xml",
                "mergeTargetTag": "ttEmulatedDevice",
                "operationList": [
                  {
                    "propertyValue": {
                      "className": "BgpRouterConfig",
                      "tagName": "ttBgpRouterConfig",
                      "propertyValueList": {
                        "IpVersion": "IPV4"
                      }
                    }
                  },
                  {
                    "stmPropertyModifier": {
                      "className": "BgpRouterConfig",
                      "propertyName": "DutAsNum",
                      "parentTagName": "ttBgpRouterConfig",
                      "tagName": "ttBgpRouterConfig.DutAsNum",
                      "propertyValueList": {
                        "Start": "100",
                        "Step": "1"
                      }
                    }
                  },
                  {
                    "stmPropertyModifier": {
                      "className": "BgpRouterConfig",
                      "propertyName": "AsNum",
                      "parentTagName": "ttBgpRouterConfig",
                      "tagName": "ttBgpRouterConfig.AsNum",
                      "propertyValueList": {
                        "Start": "100",
                        "Step": "1"
                      }
                    }
                  }
                ]
              }
            },
            {
              "stmPropertyModifier": {
                "className": "VlanIf",
                "propertyName": "VlanId",
                "parentTagName": "ttVlanIf",
                "tagName": "ttVlanIf.VlanId",
                "propertyValueList": {
                  "Start": "100",
                  "Step": "1"
                }
              }
            },
            {
              "stmPropertyModifier": {
                "className": "Ipv4If",
                "propertyName": "Gateway",
                "parentTagName": "ttIpv4If",
                "tagName": "ttIpv4If.Gateway",
                "propertyValueList": {
                  "Start": "1.1.1.2",
                  "Step": "0.0.1.0"
                }
              }
            },
            {
              "stmPropertyModifier": {
                "className": "Ipv4If",
                "propertyName": "Address",
                "parentTagName": "ttIpv4If",
                "tagName": "ttIpv4If.Address",
                "propertyValueList": {
                  "Start": "1.1.1.1",
                  "Step": "0.0.1.0"
                }
              }
            },
            {
              "stmPropertyModifier": {
                "className": "EmulatedDevice",
                "propertyName": "RouterId",
                "parentTagName": "ttEmulatedDevice",
                "tagName": "ttEmulatedDevice.RouterId",
                "propertyValueList": {
                  "Start": "100.0.0.1",
                  "Step": "0.0.0.1"
                }
              }
            },
            {
              "stmPropertyModifier": {
                "className": "EthIIIf",
                "propertyName": "SourceMac",
                "parentTagName": "ttEthIIIf",
                "tagName": "ttEthIIIf.SourceMac",
                "propertyValueList": {
                  "Start": "00:10:95:00:00:01",
                  "Step": "00:00:00:00:00:01"
                }
              }
            }
          ]
        }
      ],
      "weight": "20 %",
      "baseTemplateFile": "Dual_Vlan.xml"
    },
    {
      "devicesPerBlock": 1,
      "tagPrefix": "Right_",
      "modifyList": [
        {
          "operationList": [
            {
              "merge": {
                "operationList": [
                  {
                    "propertyValue": {
                      "className": "Ospfv3RouterConfig",
                      "tagName": "ttOspfv3RouterConfig",
                      "propertyValueList": {
                        "AreaId": "1.1.1.1"
                      }
                    }
                  }
                ],
                "mergeSourceTag": "ttOspfv3RouterConfig",
                "mergeSourceTemplateFile": "AllRouters.xml",
                "mergeTargetTag": "ttEmulatedDevice"
              }
            },
            {
              "stmPropertyModifier": {
                "className": "VlanIf",
                "propertyName": "VlanId",
                "parentTagName": "ttVlanIf",
                "tagName": "ttVlanIf.VlanId",
                "propertyValueList": {
                  "Start": "300",
                  "Step": "1"
                }
              }
            },
            {
              "stmPropertyModifier": {
                "className": "Ipv6If",
                "propertyName": "Gateway",
                "parentTagName": "ttIpv6If",
                "tagName": "ttIpv6If.Gateway",
                "propertyValueList": {
                  "Start": "2222::1",
                  "Step": "::1:0"
                }
              }
            },
            {
              "stmPropertyModifier": {
                "className": "Ipv6If",
                "propertyName": "Address",
                "parentTagName": "ttIpv6If",
                "tagName": "ttIpv6If.Address",
                "propertyValueList": {
                  "Start": "2222::2",
                  "Step": "::1:0"
                }
              }
            },
            {
              "stmPropertyModifier": {
                "className": "Ipv6If",
                "propertyName": "Address",
                "parentTagName": "ttLinkLocalIf",
                "tagName": "ttLinkLocalIf.Address",
                "propertyValueList": {
                  "Start": "fe80::1:2",
                  "Step": "::1:0"
                }
              }
            },
            {
              "stmPropertyModifier": {
                "className": "EmulatedDevice",
                "propertyName": "RouterId",
                "parentTagName": "ttEmulatedDevice",
                "tagName": "ttEmulatedDevice.RouterId",
                "propertyValueList": {
                  "Start": "100.1.0.1",
                  "Step": "0.0.0.1"
                }
              }
            },
            {
              "stmPropertyModifier": {
                "className": "EthIIIf",
                "propertyName": "SourceMac",
                "parentTagName": "ttEthIIIf",
                "tagName": "ttEthIIIf.SourceMac",
                "propertyValueList": {
                  "Start": "00:10:96:00:00:01",
                  "Step": "00:00:00:00:00:01"
                }
              }
            }
          ]
        }
      ],
      "weight": "2",
      "baseTemplateFile": "Dual_Vlan.xml"
    },
    {
      "devicesPerBlock": 1,
      "tagPrefix": "Right_",
      "modifyList": [
        {
          "operationList": [
            {
              "merge": {
                "operationList": [
                  {
                    "propertyValue": {
                      "className": "IsisRouterConfig",
                      "tagName": "ttIsisRouterConfig",
                      "propertyValueList": {
                        "IpVersion": "IPV4_AND_IPV6"
                      }
                    }
                  }
                ],
                "mergeSourceTag": "ttIsisRouterConfig",
                "mergeSourceTemplateFile": "AllRouters.xml",
                "mergeTargetTag": "ttEmulatedDevice"
              }
            },
            {
              "stmPropertyModifier": {
                "className": "VlanIf",
                "propertyName": "VlanId",
                "parentTagName": "ttVlanIf",
                "tagName": "ttVlanIf.VlanId",
                "propertyValueList": {
                  "Start": "500",
                  "Step": "1"
                }
              }
            },
            {
              "stmPropertyModifier": {
                "className": "Ipv4If",
                "propertyName": "Gateway",
                "parentTagName": "ttIpv4If",
                "tagName": "ttIpv4If.Gateway",
                "propertyValueList": {
                  "Start": "1.2.1.2",
                  "Step": "0.0.1.0"
                }
              }
            },
            {
              "stmPropertyModifier": {
                "className": "Ipv4If",
                "propertyName": "Address",
                "parentTagName": "ttIpv4If",
                "tagName": "ttIpv4If.Address",
                "propertyValueList": {
                  "Start": "1.2.1.1",
                  "Step": "0.0.1.0"
                }
              }
            },
            {
              "stmPropertyModifier": {
                "className": "Ipv6If",
                "propertyName": "Gateway",
                "parentTagName": "ttIpv6If",
                "tagName": "ttIpv6If.Gateway",
                "propertyValueList": {
                  "Start": "2223::1",
                  "Step": "::1:0"
                }
              }
            },
            {
              "stmPropertyModifier": {
                "className": "Ipv6If",
                "propertyName": "Address",
                "parentTagName": "ttIpv6If",
                "tagName": "ttIpv6If.Address",
                "propertyValueList": {
                  "Start": "2223::2",
                  "Step": "::1:0"
                }
              }
            },
            {
              "stmPropertyModifier": {
                "className": "Ipv6If",
                "propertyName": "Address",
                "parentTagName": "ttLinkLocalIf",
                "tagName": "ttLinkLocalIf.Address",
                "propertyValueList": {
                  "Start": "fe80::1:2",
                  "Step": "::1:0"
                }
              }
            },
            {
              "stmPropertyModifier": {
                "className": "EmulatedDevice",
                "propertyName": "RouterId",
                "parentTagName": "ttEmulatedDevice",
                "tagName": "ttEmulatedDevice.RouterId",
                "propertyValueList": {
                  "Start": "100.2.0.1",
                  "Step": "0.0.0.1"
                }
              }
            },
            {
              "stmPropertyModifier": {
                "className": "EthIIIf",
                "propertyName": "SourceMac",
                "parentTagName": "ttEthIIIf",
                "tagName": "ttEthIIIf.SourceMac",
                "propertyValueList": {
                  "Start": "00:10:97:00:00:01",
                  "Step": "00:00:00:00:00:01"
                }
              }
            }
          ]
        }
      ],
      "weight": "1",
      "baseTemplateFile": "Dual_Vlan.xml"
    }
  ]
}
-->
</stc:class>

<stc:class name="IteratorConfigMixParamsCommand"
           displayName="IteratorConfigMixParamsCommand"
           baseClass="spirent.methodology.IteratorConfigCommand"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Configures the mix information for an StmTemplateMix object."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
    <stc:property category="input" name="StmTemplateMix" displayName="StmTemplateMix" type="handle" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Handle of the StmTemplateMix object being configured." />
    </stc:property>
    <stc:property category="input" name="TagData" displayName="tag Data" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON String of tags needed in the sequence."/>
        <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>

<!-- CATEGORY: Framework: Iteration -->

<!-- SAMPLE_JSON:
This is an example for TagData.

    {
        "templateConfigurator": "ttCreateTemplateConfigCommand",
        "stmTemplateMix": "ttTemplateMix"
    }

-->

</stc:class>

<stc:class name="BuildTemplatePdusCommand"
           displayName="Build Template PDUs Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription"
                   value="Builds PDU information from JSON input and modifies the FrameConfig for Streamblocks in the template stored in an StmTemplateConfig object."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>

    <stc:property category="input" name="StmTemplateConfig" displayName="StmTemplateConfig" type="handle" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Handle of the StmTemplateConfig object being modified." />
    </stc:property>

    <stc:property category="input" name="TagNameList" displayName="Tag Name List" type="string" default=""  minOccurs="0" maxOccurs="unbounded">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription"
                       value="List of tag names of the streamblocks (XML elements) being modified in the template."/>
    </stc:property>

    <stc:property category="input" name="InputJson" displayName="JSON Input" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON string representation of PDUs that will be added to the streamblocks."/>
      <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>

<!-- CATEGORY: Framework: Template -->
<!-- CATEGORY: Traffic -->

<!-- SAMPLE_JSON:
The following create a frameconfig with EthII w/VLANs and IPv4 pdus

{
  "pdu_list": [
    {
      "enable": true,
      "name": "eth1",
      "pdu": "ethernet:EthernetII",
      "element_type": "pdu",
      "pdu_data": [
        {
          "enable": true,
          "pdu_data": [
            {
              "property_data": {
                "pri": "010",
                "id": "11"
              },
              "enable": true,
              "name": "Vlan",
              "element_type": "Vlan"
            },
            {
              "property_data": {
                "pri": "111",
                "id": "22"
              },
              "enable": true,
              "name": "Vlan_1",
              "element_type": "Vlan"
            }
          ],
          "name": "anon_2696",
          "element_type": "vlans"
        }
      ],
      "property_data": {
        "dstMac": "00:10:95:00:00:01",
        "srcMac": "00:10:95:00:00:02"
      }
    },
    {
      "enable": true,
      "name": "ip_1",
      "pdu": "ipv4:IPv4",
      "element_type": "pdu",
      "pdu_data": [
        {
          "enable": true,
          "pdu_data": [
            {
              "property_data": {
                "dscpHigh": "1",
                "dscpLow": "2",
                "reserved": "00"
              },
              "enable": true,
              "name": "anon_2701",
              "element_type": "diffServ"
            }
          ],
          "name": "anon_2700",
          "element_type": "tosDiffserv"
        }
      ],
      "property_data": {
        "totalLength": "20",
        "gateway": "1.0.0.3",
        "sourceAddr": "1.0.0.1",
        "destAddr": "1.0.0.2",
        "checksum": "47298"
      }
    }
  ]
}
-->
</stc:class>

<stc:class name="ConfigTemplatePdusCommand"
           displayName="Config Template PDUs Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription"
                   value="Configures PDU information in the FrameConfig for Streamblocks in the template stored in an StmTemplateConfig object."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>

    <stc:property category="input" name="StmTemplateConfig" displayName="StmTemplateConfig" type="handle" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Handle of the StmTemplateConfig object being modified." />
    </stc:property>

    <stc:property category="input" name="TemplateElementTagNameList" displayName="Template Element Tag Name List" type="string" default=""  minOccurs="0" maxOccurs="unbounded">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription"
                       value="List of tag names of the streamblocks (XML elements) being modified in the template."/>
    </stc:property>

    <stc:property category="input" name="PduPropertyList" displayName="PDU Information Property List" type="string" default=""  minOccurs="0" maxOccurs="unbounded">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription"
                       value="List of properties specifying the streamblock FrameConfig properties to be modified.  A property's index in this list MUST match the index of its value in PduValuelist."/>
    </stc:property>

    <stc:property category="input" name="PduValueList" displayName="PDU Information Value List" type="string" default=""  minOccurs="0" maxOccurs="unbounded">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription"
                       value="List of values modifying the specified streamblock FrameConfig properties.  The index of a value in this list MUST match the index of the property it is configuring in PduPropertyList."/>
    </stc:property>

<!-- CATEGORY: Framework: Template -->
<!-- CATEGORY: Traffic -->

</stc:class>


<stc:class name="ExpandProtocolMixCommand"
           displayName="Expand Protocol Mix Command"
           baseClass="spirent.methodology.ExpandTemplateMixCommand"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Expands the protocol mix template(s) into emulated devices and protocol objects. The protocol mix is defined from an StmTemplateMix object, populated with the mix information from the CreateProtocolMixCommand."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="TagName" displayName="Tag name for the Template Mix" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Tag name of the StmProtocolMix object being expanded." />
    </stc:property>
    <stc:property category="input" name="DeviceCount" displayName="Device Count"
                  type="u32" default="10">
        <stc:attribute internalType="string" type="framework.PropertyDescription" value="Total number of devices for the protocol mix. " />
    </stc:property>
    <stc:property category="input" name="PortGroupTagList" displayName="Port Group Tag" type="string" default="" minOccurs="0" maxOccurs="unbounded">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Tag name of the port groups the protocol mix is being expanded on."/>
    </stc:property>
<!-- CATEGORY: Protocol -->
</stc:class>


<stc:class name="TaggedLinkCreateCommand"
           displayName="Tagged Link Create Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none"
                   type="core.Sequenceable" value="true" />
    <stc:attribute internalIsEnum="false" internalType="string" name="none"
                   type="framework.CommandDescription"
                   value="Creates links between tagged objects." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Data Model Configuration"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:enumeration name="EnumLinkPattern">
        <stc:enum name="PAIR" value="0" displayName="Pair / Group back devices" />
        <stc:enum name="BACKBONE" value="1" displayName="Backbone" />
        <stc:enum name="INTERLEAVED" value="2" displayName="Interleave back devices" />
    </stc:enumeration>

    <stc:property name="LinkType" type="string" default="" category="input"
                  displayName="Link Type">
        <stc:attribute internalIsEnum="false" internalType="string" name="none"
                       type="framework.PropertyDescription"
                       value="Type of link being created between objects." />
    </stc:property>
    <stc:property name="SrcObjTag" type="string" default="" category="input"
                  displayName="Source Object Tag">
        <stc:attribute internalIsEnum="false" internalType="string" name="none"
                       type="framework.PropertyDescription"
                       value="Tag of the source (Back) objects." />
    </stc:property>
    <stc:property name="SrcIfTag" type="string" default="" category="input"
                  displayName="Source Interface Tag">
        <stc:attribute internalIsEnum="false" internalType="string" name="none"
                       type="framework.PropertyDescription"
                       value="Tag of the source's (Back) interface objects."/>
    </stc:property>
    <stc:property name="DstObjTag" type="string" default="" category="input"
                  displayName="Destination Object Tag">
        <stc:attribute internalIsEnum="false" internalType="string" name="none"
                       type="framework.PropertyDescription"
                       value="Tag of the destination (Front) objects." />
    </stc:property>
    <stc:property name="DstIfTag" type="string" default="" category="input"
                  displayName="Destination Interface Tag">
        <stc:attribute internalIsEnum="false" internalType="string" name="none"
                       type="framework.PropertyDescription"
                       value="Tag of the destination's (Front) interface objects."/>
    </stc:property>
    <stc:property name="LinkPattern" type="u8" default="PAIR"
                  category="input" displayName="Link Distribution Pattern">
        <stc:attribute internalIsEnum="false" internalType="string" name="none"
                       type="framework.PropertyDescription"
                       value="Distribution pattern of the link being created.  Acceptable values are: PAIR, BACKBONE, or INTERLEAVED."/>
        <stc:enumerationRef ref="EnumLinkPattern" />
    </stc:property>
    <stc:property name="LinkTag" type="string" default="" category="input"
                  displayName="Tag for newly-created Link Objects">
        <stc:attribute internalIsEnum="false" internalType="string" name="none"
                       type="framework.PropertyDescription"
                       value="Tag of the new link objects being create." />
    </stc:property>
    <stc:property name="LinkList" type="handle" default="" category="output"
                  minOccurs="0" maxOccurs="unbounded"
                  displayName="List of created Link objects">
        <stc:attribute internalIsEnum="false" internalType="string" name="none"
                       type="framework.PropertyDescription"
                       value="List of handles of the new link objects created by the command." />
    </stc:property>
<!-- CATEGORY: Framework: Data Model -->
</stc:class>


<stc:class name="L2L3LearningCommand"
           displayName="L2L3 Learning Command"
           bllDirectInterface="true"
           isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Performs L2 and/or L3 learning for the specified objects."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:enumeration name="EnumL2LearningOption">
        <stc:enum name="TX_ONLY" value="0" displayName="L2LearningOnTxOnly" />
        <stc:enum name="RX_ONLY" value="1" displayName="L2LearningOnRxOnly" />
        <stc:enum name="TX_RX" value="2" displayName="L2LearningOnTxRx" />
    </stc:enumeration>

    <stc:property category="input" name="ObjectList" displayName="Object List" type="handle" default="0" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of handles of objects to run learning on.  Acceptable objects are: ports, streamblocks, hosts, routers, or emulated devices." />
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="core.ValidHandleTypes" value="Port,StreamBlock,Host,Router,EmulatedDevice" />
    </stc:property>

    <stc:property category="input" name="TagNameList" displayName="Tag Name List" type="string" default="" minOccurs="0" maxOccurs="unbounded" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tag names of the objects to run learning on.  Acceptable objects are: ports, streamblocks, hosts, routers, or emulated devices." />
    </stc:property>

    <stc:property category="input" name="EnableL2Learning" displayName="Enable L2 Learning" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True runs L2 learning on the specified objects.  False does not run L2 learning on the objects." />
    </stc:property>

    <stc:property category="input" name="EnableL3Learning" displayName="Enable L3 Learning" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True runs L3 learning on the specified objects.  False does not run L3 learning on the objects." />
    </stc:property>

    <stc:property category="input" name="L2LearningOption" displayName="L2 Learning Option" type="u8" default="TX_RX">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Type of L2 learning to be performed.  Acceptable values are: TX_ONLY, RX_ONLY, or TX_RX.  Valid only when EnableL2Learning is enabled." />
      <stc:enumerationRef ref="EnumL2LearningOption"/>
    </stc:property>

    <stc:property category="input" name="WaitForArpToFinish" displayName="Wait For Arp To Finish" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True waits for ARP to finish before continuing.  False continues before ARP is finished.  Valid only when EnableL3Learning is enabled." />
    </stc:property>

    <stc:property category="input" name="ForceArp" displayName="Always Arp" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True will always ARP even if not required.  False will not ARP if it is not required.  Valid only when EnableL3Learning is enabled." />
    </stc:property>

    <stc:property category="input" name="VerifyArp" displayName="Verify Arp Status" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True verifies if ARP resolves.  False does not care about the ARP status." />
    </stc:property>

<!-- CATEGORY: Protocol -->
<!-- CATEGORY: Traffic -->

</stc:class>

<stc:class name="RunArpCommand"
           displayName="Run ARP Command"
           bllDirectInterface="true"
           isInternal="false">
    <stc:attribute type="framework.CommandDescription" value="Performs L3 learning for the specified tagged objects." internalIsEnum="false" internalType="string" name="none"/>
    <stc:attribute type="framework.CommandCategory" value="Test Methodology" internalIsEnum="false" internalType="string" name="none"/>
    <stc:attribute type="core.Sequenceable" value="true" internalIsEnum="false" internalType="bool" name="none"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:enumeration name="EnumReportType">
        <stc:enum name="NONE"       value="0" displayName="Do not generate a report" />
        <stc:enum name="FAILURES"   value="1" displayName="Only report failures" />
        <stc:enum name="ALWAYS"     value="2" displayName="Report all results" />
    </stc:enumeration>

    <stc:enumeration name="EnumL3TaggedObjectType">
        <stc:enum name="DEVICE"       value="0" displayName="Device" />
        <stc:enum name="STREAM_BLOCK" value="1" displayName="Stream Block" />
        <stc:enum name="BOTH"         value="2" displayName="Device and Stream Block" />
    </stc:enumeration>

    <stc:property category="input" name="TagNameList" displayName="Tag Name List" type="string" default="" minOccurs="0" maxOccurs="unbounded" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tag names of the objects to run learning on.  Acceptable objects are: streamblocks and devices." />
    </stc:property>

    <stc:property category="input" name="TaggedObjectType" displayName="Tagged Object Type" type="u8" default="DEVICE">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Object types the tags target. Acceptable values are: Device, Stream Block, or Both."/>
      <stc:enumerationRef ref="EnumL3TaggedObjectType"/>
    </stc:property>

    <stc:property category="input" name="ForceArp" displayName="Always Arp" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True will always ARP even if not required.  False will not ARP if it is not required." />
    </stc:property>

    <stc:property category="input" name="VerifyArp" displayName="Verify Arp Status" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True will verify if the ARP resolves.  False does not care about the ARP status." />
    </stc:property>

    <stc:property category="input" name="EnablePassFailState" displayName="Enable pass/fail state" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True will set the pass/fail state of the command" />
    </stc:property>

    <stc:property category="input" name="ReportType" displayName="Report Type" type="u8" default="NONE">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription"
           value="Select when this command should generate a report. This will add the status of ARP resolves to the Summary section of the test report. Valid only if VerifyArp is enabled." />
      <stc:enumerationRef ref="EnumReportType"/>
    </stc:property>

    <!-- Output properties -->
    <stc:property category="output" name="ArpPassed" displayName="All ARPs Passed" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True if all ARPs passed" />
    </stc:property>

</stc:class>

<stc:class name="GetJsonSchemaCommand"
           displayName="Get Json Schema Command"
           bllDirectInterface="true"
           isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Returns JSON schema of the specified key"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="Key" displayName="Key" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Name of the command whose schema will be returned." />
    </stc:property>

    <!-- Output properties -->
    <stc:property category="output" name="Schema" displayName="JSON Schema" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription"
        value="JSON Schema found based on the search key." />
        <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>
</stc:class>

<stc:class name="GenerateObjectMappingCommand"
    displayName="Generate Object Mapping Command"
    bllDirectInterface="true"
    isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Creates a mapping between two lists according to a specified pattern.  Outputs a pair corresponding to the current index."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:enumeration name="EnumMapPattern">
        <stc:enum name="PAIR" value="0" displayName="Pair / Group" />
        <stc:enum name="BACKBONE" value="1" displayName="Backbone" />
        <stc:enum name="ROUND_ROBIN" value="2" displayName="Round Robin" />
        <stc:enum name="CUSTOM" value="3" displayName="Custom Pattern" />
    </stc:enumeration>

    <stc:property category="input" name="InputJson" displayName="JSON Input" type="string" default=''>
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON string representation of parameters to create mapping between two lists of objects."/>
        <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>

    <!-- State Variables -->
    <stc:property category="state" name="CurrIndex" displayName="Current Index" type="u32" default="0">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Index of the current mapped pair." />
    </stc:property>
    <stc:property category="state" name="ResetState" displayName="Reset State" type="bool" default="false" isInternal="true" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True resets the state properties of the command.  False does not reset the state properties." />
    </stc:property>

    <!-- Output properties -->
    <stc:property category="output" name="LeftTagName" displayName="Left Output Tag Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription"
        value="Tag name of the left object returned by the command." />
    </stc:property>
    <stc:property category="output" name="RightTagName" displayName="Right Output Tag Name"
           type="string" default="" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription"
        value="Tag name of the right object returned by the command." />
    </stc:property>
    <stc:property category="output" name="ParentTagName" displayName="Parent Output Tag Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription"
        value="Tag name of the parent object returned by the command.  Only used for BuildPairObjectCommand." />
    </stc:property>

<!-- CATEGORY: Framework: Mapping -->

<!-- SAMPLE_JSON:
Creates a backbone (everything to everything) pattern between a list of IgmpHostConfig and a list of Ipv4Groups, where the possible parent is the IgmpHostConfig
{
    "leftComponents": {
        "tagNames": [
            "Host_ttIgmpHostConfig"
        ],
        "objectType": "IgmpHostConfig"
    },
    "rightComponents": {
        "tagNames": [
            "Dst_ttIpv4Group"
        ],
        "objectType": "Ipv4Group"
    },
    "mapPattern": "BACKBONE",
    "parentTagName": "LEFT"
}
-->
</stc:class>

<stc:class name="PairCommand"
    displayName="Pair Command"
    bllDirectInterface="true"
    canCreate="false"
    isInternal="true">
    <stc:property category="input" name="InputJson" displayName="JSON Input" type="string" default=''>
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON string representation of parameters to build a link between two objects."/>
        <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>
</stc:class>

<stc:class name="RunPairScriptCommand"
    baseClass="spirent.methodology.PairCommand"
    displayName="Run a Pair Command Script"
    isInternal="false"
    bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Runs a python script."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>

<!-- CATEGORY: Framework: Mapping -->
<!-- CATEGORY: Run and Execute -->

<!-- SAMPLE_JSON:
Run the run function of iptv_set_prop_val.py using the a dictionary of parameters. The leftTagName and rightTagName will be chained in if used with MapWhileCommand.
{
    "scriptFileName": "iptv_set_prop_val.py",
    "methodName": "run",
    "params": {
        "leftRelation": "ParentChild",
        "rightDir": true,
        "rightRelation": "SubscribedGroups",
        "inputValue": true,
        "property": "Active",
        "objectType": "IgmpGroupMembership"
    }
}
-->
</stc:class>

<stc:class name="BuildPairRelationCommand"
    displayName="Build Pair Relation Command"
    baseClass="spirent.methodology.PairCommand"
    bllDirectInterface="true"
    isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Creates a relation between two objects."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

<!-- CATEGORY: Framework: Mapping -->

<!-- SAMPLE_JSON:
Creates all relations found in IgmpHostConfig.xml template between EmulatedDevice and Ipv4If.
{
    "enableLoadFromFileName": true,
    "rightTagName": "Right_ttEmulatedDevice",
    "leftTagName": "Left_ttIpv4If",
    "templateXmlFileName": "IgmpHostConfig.xml"
}
-->
</stc:class>

<stc:class name="BuildPairObjectCommand"
    displayName="Build Pair Object Command"
    baseClass="spirent.methodology.PairCommand"
    bllDirectInterface="true"
    isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Creates an object between a source object and a destination object."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

<!-- CATEGORY: Framework: Mapping -->

<!-- SAMPLE_JSON:
Loads in an IgmpGroupMembership tagged with ttIgmpGroupMembership from the template file IgmpGroupMembership.xml, and puts it under IgmpHostConfig. Then builds relations between IgmpHostConfig, the newly created IgmpGroupMembership, and Ipv4Group.
{
    "enableLoadFromFileName": true,
    "rightTagName": "Dst_ttIpv4Group",
    "leftTagName": "Host_ttIgmpHostConfig",
    "midTemplateTagName": "ttIgmpGroupMembership",
    "templateXmlFileName": "IgmpGroupMembership.xml",
    "parentTagName": "Host_ttIgmpHostConfig"
}
-->

</stc:class>

<stc:class
    name="MapWhileCommand"
    baseClass="stak.StakWhileCommand"
    displayName="Map While Command"
    bllDirectInterface="true"
    isInternal="false">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="While loop for mapping objects together."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
<!-- CATEGORY: Framework: Mapping -->
</stc:class>

<stc:class name="AddToDbTableCommand"
           displayName="Add To DB Table"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Adds raw data or queried results to a new or existing table.  INSERT is implicitly done and does not need to be specified in the JSON."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="DbJsonString" displayName="Database JSON String" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON string representation of raw data or SQL queries to be inserted into a table."/>
        <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>
    <stc:property category="input" name="DbJsonFileName" displayName="Database JSON File" type="inputFilePath" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Location and filename of a JSON file containing raw data or SQL queries to be inserted into a table." />
      <stc:attribute type="framework.MangleRelativePath" value="false" internalType="bool" />
    </stc:property>
    <stc:property category="input" name="EnableLoadFromFileName" displayName="Enable JSON File" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True loads the JSON configuration specified by DbJsonFileName.  False loads the JSON string specified by DbJsonString." />
    </stc:property>

    <!-- Output properties -->
    <stc:property category="output" name="BuiltSql" displayName="Built SQL Statements" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription"
        value="SQL statements built (as defined by the input JSON) and used by the command." />
    </stc:property>
    <stc:property category="output" name="OutputJson" displayName="Output JSON String" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription"
        value="JSON String representing queries used (if any) and data added to a database." />
        <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>

<!-- CATEGORY: Results: Database and SQL -->

<!-- SAMPLE_JSON:
Defines two SQL operations to be executed.  The first is to create a new table in the database.  The second inserts raw data into the table.
{
    "sql_operations": [
        {
            "db_information": {
                "db_name": "SUMMARY"
            },
            "table": [],
            "sql_statement": [
                {
                    "static": "CREATE TABLE y1564MethodologyConfig( ID INTEGER PRIMARY KEY, ServiceName TEXT, StreamblockTag TEXT, SourceIP TEXT, DestinationIP TEXT )"
                }
            ]
        },
        {
            "db_information": {
                "db_name": "SUMMARY",
                "table_name": "y1564MethodologyConfig",
                "columns": [
                    "ID",
                    "ServiceName",
                    "StreamblockTag",
                    "SourceIP",
                    "DestinationIP"
                ]
            },
            "table": [
                ["1","Real-Time Data","0_LeftPortGroup_ttStreamBlock","10.0.0.1","10.0.0.2"],
                ["2","High-Priority Data","1_LeftPortGroup_ttStreamBlock","11.0.0.1","11.0.0.2"],
                ["3","Best-Effort Data","0_RightPortGroup_ttStreamBlock","10.0.0.2","10.0.0.1"]
            ],
            "sql_statement": []
        }
    ]
}
-->
<!-- SAMPLE_JSON:
Defines an SQL query to be executed.  The rows of data (defined by columns in db_information) returned by the query will be inserted into the table in db_information.
{
    "sql_operations": [
        {
            "db_information": {
                "db_name": "SUMMARY",
                "table_name": "y1564ServiceEndpoints",
                "columns": [
                    "ServiceName",
                    "SourceIP",
                    "DestinationIP"
                ]
            },
            "table": [],
            "sql_statement": [
                {
                    "static": "SELECT ServiceName, SourceIP, DestinationIP FROM y1564MethodologyConfig"
                }
            ]
        }
    ]
}
-->
</stc:class>

<stc:class name="RunSqlCommand"
           displayName="Run SQL Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Runs a built SQL statement defined in JSON.  Primarily used to retrieve data from a database via a query."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="DbJsonString" displayName="Database JSON String" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON string representation of SQL statements to be executed."/>
        <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>
    <stc:property category="input" name="DbJsonFileName" displayName="Database JSON File" type="inputFilePath" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Location and filename of a JSON file containing SQL statements to be executed." />
      <stc:attribute type="framework.MangleRelativePath" value="false" internalType="bool" />
    </stc:property>
    <stc:property category="input" name="EnableLoadFromFileName" displayName="Enable JSON File" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True loads the JSON configuration specified by DbJsonFileName.  False loads the JSON string specified by DbJsonString." />
    </stc:property>

    <!-- Output properties -->
    <stc:property category="output" name="OutputJson" displayName="Output JSON String" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription"
        value="JSON String representing queries used and the data returned from those queries." />
        <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>
    <stc:property category="output" name="CommandVerdict" displayName="Verdict of the Command" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True if verdict is PASS.  False if verdict is FAIL." />
    </stc:property>

<!-- CATEGORY: Results: Test Report -->
<!-- CATEGORY: Results: Database and SQL -->

<!-- SAMPLE_JSON:
This sample queries the database and puts the returned data into a temporary table, which is used to determined the verdict for this command.  This data is also flagged to be included with testReport.json.
{
    "sql_for_command_verdict": [
        {
            "static": "SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM mytable"
        }
    ],
    "sql_operations": [
        {
            "enable": false,
            "db_information": {
                "db_name": "SUMMARY"
            },
            "sql_statement": [
                {
                    "static": "SELECT Handle AS 'NHnd', name AS 'NName' FROM EotResultNode"
                }
            ]
        },
        {
            "report": {
                "report_verdict": {
                    "apply_test_verdict": true,
                    "passed_verdict_explanation": "passed explained",
                    "failed_verdict_explanation": "failed explained",
                    "sql_for_verdict": [
                        {
                            "static": "SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END FROM mytable"
                        }
                    ]
                },
                "report_group": "SUMMARY",
                "display_name": "report display"
            },
            "db_information": {
                "db_name": "SUMMARY"
            },
            "temp_table_name":"mytable",
            "sql_statement": [
                {
                    "static": "SELECT ParentHnd AS 'NPHnd', Name AS 'NPName' FROM EotResultNodeParam"
                }
            ]
        }
    ]
}
-->
</stc:class>

<stc:class name="ExecuteWithTagsCommand"
           displayName="Execute With Tags Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Executes a list of BLL commands utilizing tags to get handle information."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="CmdJsonString" displayName="Command JSON String" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON string representation of commands to be executed."/>
        <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>
    <stc:property category="input" name="CmdJsonFileName" displayName="Command JSON File" type="inputFilePath" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Location and filename of a JSON file containing commands to be executed." />
      <stc:attribute type="framework.MangleRelativePath" value="false" internalType="bool" />
    </stc:property>
    <stc:property category="input" name="EnableLoadFromFileName" displayName="Enable JSON File" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True loads the JSON configuration specified by CmdJsonFileName.  False loads the JSON string specified by CmdJsonString." />
    </stc:property>
    <stc:property category="input" name="ApplyPassFailState" displayName="Apply Executed Commands' PassFailState to this Command's PassFailState" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True sets this command's PassFailState to FAILED if any of the executed PassFailCommands FAILED.  False leaves this command's PassFailState unaffected by the PassFailState of any of the executed PassFailCommands." />
    </stc:property>

    <!-- Output properties -->
    <stc:property category="output" name="OutputJson" displayName="Output JSON String" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription"
        value="JSON String representing commands executed, properties used and the state/output properties." />
        <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>

<!-- CATEGORY: Run and Execute -->

<!-- SAMPLE_JSON:
This sample applies then executes a series of BFD commands.
{
    "enable": true,
    "description": "Execute BFD commands.",
    "command_list": [
        {
            "enable": true,
            "command_name": "ApplyToILCommand"
        },
        {
            "enable": true,
            "command_name": "BfdCreateStreamBlockCommand",
            "handle_property_list": [
                {
                    "property_name": "PortHandle",
                    "tag_name_list": ["West_ttPort"],
                    "class_name_list": ["Port"]
                },
                {
                    "property_name": "ObjectList",
                    "tag_name_list": ["ttBfdRouter2", "ttBfdRouter3"],
                    "class_name_list": ["BfdRouterConfig"]
                }
            ]
        },
        {
            "enable": true,
            "command_name": "BfdSetDiagnosticStateCommand",
            "property_value": {
                "BfdDiagnosticCode": "CD_TIME_EXPIRE",
                "DiagnosticStateTimeout": 20
            }
        },
        {
            "enable": true,
            "command_name": "BfdSetDiagnosticStateCommand",
            "property_value": {
                "BfdDiagnosticCode": "ECHO_FUNCTION_FAILED",
                "DiagnosticStateTimeout": 20
            },
            "handle_property_list": [
                {
                    "property_name": "ObjectList",
                    "tag_name_list": ["ttBfdRouter", "ttBfdRouter2"],
                    "class_name_list": ["BfdRouterConfig"]
                }
            ]
        }
    ]
}
-->
</stc:class>

<stc:class name="ProcessDataCommand"
           displayName="Process Data Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Transfer, transform, analyze, and manipulate data."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="InputJson" displayName="List of operations in JSON format" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON string representation of a list of operations to perform on data in the system."/>
        <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>

<!-- CATEGORY: Framework: Data Model -->
<!-- CATEGORY: Results: Database and SQL -->
<!-- CATEGORY: Results: Test Report -->

<!-- SAMPLE_JSON:
TITLE: <b>static_value</b> source data types

The static_value is a constant value or collection of values. It encapsulates
the common data format types (scalar, list, json_object, and table_data).

<b>Scalar</b>

The scalar data format wraps a single data value. The format property is set to scalar.
The type property is optional since the type can generally be determined by the data
itself. The description property is optional and is not typically generated for internal
data management.
{
  "format": "scalar",
  "data": 100,
  "type": "int",
  "description": "an integer"
}


<b>List</b>

The list data format wraps a list of data values. The format property is set to list.
The type_list property is optional since the types can generally be determined by the
data itself. The description property is optional and is not typically generated for
internal data management.
{
  "format": "list",
  "data": [100, 100.0, "100"],
  "type_list": ["int", "float", "string"],
  "description": "a list of data"
}


<b>JSON</b>

The JSON data format wraps either a JSON object or a list of JSON objects. The format
property is set to json_object. The description property is optional and is not typically
generated for internal data management.

An example of a single JSON object:
{
  "format": "json_object",
  "data": { ... },
  "description": "a json object"
}

An example of a list of JSON objects:
{
  "format": "json_object",
  "data": [{ ... }, { ... }, ...],
  "description": "a list of json objects"
}



<b>Table</b>

The table data format wraps data that represents rows and columns of data. The format
property is set to table_data. The description property is optional and is not typically
generated for internal data management. This internal format has several unique properties
to consider.

The schema property is optional. The source db_table includes the table schema as part
of the data it generates under the schema property. When present, the columns property
is required, and under that only the names property is required.

The row_data property holds data. This is technically optional as well. It is possible
to have the schema property that defines a table without any data. But in general methodology
authors will work with table data that contains data.
{
	"format": "table_data",
	"schema": {
		"columns": [{
				"name": "Column 1",
				"type": "int",
				"is_collection": false,
				"nullable": false,
				"default_value": "0",
				"primary_key": false
			},
			...
		]
	},
	"row_data": {
		"column_names": ["Column 1", ...],
		"rows": [
			[100, ...],
			[123, ...],
			...
		]
	},
	"description": "a table of data",
	"sql_cmd": "SELECT ..."
}
When the row_data is present, the rows property is required, even if the list contains a
single empty list. The column_names property is optional and only refers to data in the
rows property. The list of column names in the column_names property are associated by
order with the data in each row list within the rows property.

If both schema property and column_names property exist, then the column names between
the two must match in all ways except order. When writing data to a table, the data in
rows is rearranged to match the order of the table defined in schema property.

When generating data from an SQL query, the query statement that is actually issued to
SQLite is required in the sql_cmd property for debugging purposes.



The following is an example of using a static value as a data source to configure the
number of devices to create.
{
	"operation_list": [{
		"set_variable": {
			"src": {
				"static_value": {
					"format": "scalar",
					"type": "int",
					"data": "10"
				}
			},
			"dst": [{
				"variable": {
					"name": "DevicesPerPort"
				}
			}]
		}
	}]
}
The JSON key operation_list[0].set_variable.src.static_value.data can be used to expose
the constant value "10" to the UI for user configuration.
-->

<!-- SAMPLE_JSON:
TITLE: <b>run_sql</b> operation with sql source

To db_table destination:
This sample demonstrates an SQL query and the result sent to a new table in the SUMMARY database.
{
	"operation_list": [{
		"run_sql": {
			"src": {
				"sql": {
					"db_name": "SUMMARY",
					"sql_statement": [{
						"static": "SELECT CreatedTime FROM DataSet"
					}]
				}
			},
			"dst": [{
				"db_table": {
					"db_name": "SUMMARY",
					"table_name": "SomeNewTable",
					"schema": {
						"columns": [{
							"name": "CreatedTime"
						}]
					}
				}
			}]
		}
	}]
}


Simple value substitution, perhaps via exposed property:
In this example, we create a table in the summary database called MethConfig. Both the
definition and content of the table is defined by what comes after the SELECT keyword.
The statement is literally:

CREATE TABLE IF NOT EXISTS MethConfig AS SELECT 5 AS 'Device Count', 60 AS 'Router Up Timeout'

which creates two columns, "Device Count" and "Router Up Timeout", and populates a single
row with 5 and 60 respectively. By separating the values into their own static elements,
the values can be exposed either directly to the UI or to backend mappers. The following
JSON keys can be used:

     Device Count value: operation_list[0].run_sql.src.sql.sql_statement[1].static
Router Up Timeout value: operation_list[0].run_sql.src.sql.sql_statement[3].static

Note the single quote to create a string that defines the record set column header, which
in turn is then used to define the table column header.
{
	"operation_list": [{
		"run_sql": {
			"src": {
				"sql": {
					"sql_statement": [{
						"static": "CREATE TABLE IF NOT EXISTS MethConfig AS SELECT "
					}, {
						"static": "5"
					}, {
						"static": " AS 'Device Count', "
					}, {
						"static": "60"
					}, {
						"static": " AS 'Router Up Timeout'"
					}]
				}
			}
		}
	}]
}


Creating a pass/fail query for command pass/fail state:
The sql_statement holds a query that generates either a 1 (true) or 0 (false) single value record set. This
value is interpreted as pass or fail when the destination is command_pass_fail_state. Using the
command_pass_fail_state is an effective means of forming a branch decision using the ProcessDataCommand
as an expression command to a sequencer IF command.

When performing an inequality comparison in SQL, you will likely want to use the CAST(field AS INT) to ensure
that the inequality is performed on the integer representation of the data.

Note the back single quote used to identify the table column header when the header includes spaces.
{
	"operation_list": [{
		"run_sql": {
			"src": {
				"sql": {
					"db_name": "SUMMARY",
					"sql_statement": [{
						"static": "SELECT CAST(`Router Up Count` AS INT) > 0 FROM MethRouterUpCountTable"
					}]
				}
			},
			"dst": [{
				"command_pass_fail_state": {
					"status_value_on_fail": "0"
				}
			}]
		}
	}]
}


Incorporating variables into SQL queries:
This example shows how to build an SQL query that performs a comparison of integer values
between a database table column and a variable, and set the ProcessDataCommand's pass/fail
state based upon the comparison results.

Note that the run_sql operation does not introduce for the author any additional white space
characters into the sql_statement. All white space characters must be explicitly provided
by the author.

If the variable ConfiguredRouterCount has the value 7 in it, then the SQL statement that
is built is:
SELECT CAST(`Router Up Count` AS INT) > 7 FROM MethRouterUpCountTable
{
	"operation_list": [{
		"run_sql": {
			"src": {
				"sql": {
					"db_name": "SUMMARY",
					"sql_statement": [{
						"static": "SELECT CAST(`Router Up Count` AS INT) > "
					}, {
						"variable": "ConfiguredRouterCount"
					}, {
						"static": " FROM MethRouterUpCountTable"
					}]
				}
			},
			"dst": [{
				"command_pass_fail_state": {
					"status_value_on_fail": "0"
				}
			}]
		}
	}]
}


Using SQL queries as variable expression processors:
You can use SQL queries as expression processors for variables without the need for any
database involvement. For example, let's say you hold the following information in variables:

DevicesPerPort            The number of devices configured per port
TotalPorts                The total number of ports
SampledRouterUpCount      The number of routers (devices) that are sampled in the UP state

To form an expression for a sequencer WHILE(DevicesPerPort * TotalPorts > SampledRouterUpCount)
to return true while the routers are not all yet up, and false to leave the WHILE loop once they
all come up, you simply form a SELECT statement with those variables and operators.

SELECT DevicesPerPort * TotalPorts > SampledRouterUpCount

When the variables' contents are substituted, the SELECT statement looks something like:

SELECT 10 * 2 > 7

Of course it doesn't look like this in JSON. Instead, you need to break apart the SELECT statement
into those portions that are true SQL and those that are variable names that will be substituted with
their respective values.

Note the white spaces are explicitly provided by the author while the run_sql operation adds nothing
during the variable substitution other than the values themselves.
{
	"operation_list": [{
		"run_sql": {
			"src": {
				"sql": {
					"db_name": "SUMMARY",
					"sql_statement": [{
						"static": "SELECT "
					}, {
						"variable": "DevicesPerPort"
					}, {
						"static": " * "
					}, {
						"variable": "TotalPorts"
					}, {
						"static": " > "
					}, {
						"variable": "SampledRouterUpCount"
					}]
				}
			},
			"dst": [{
				"command_pass_fail_state": {
					"status_value_on_fail": "0"
				}
			}]
		}
	}]
}

Following sample demonstrates an SQL query in single string with variables embedded, 
and the result sent to a new table in the SUMMARY database.
The first 2 operations under "operation_list" are to set varibles column_name and table_name.
Of course, you can use any other variable already defined prior to this PDC command.
The third "run_sql" operation has single string "SELECT @{column_name} FROM @{table_name}"
defined for "sql_statement" to provide compact and flexible way except static/dynamic/variable
mentioned above.
{
  "operation_list": [
    {
      "transfer_data": {
        "src": {
          "static_value": {
            "format": "scalar",
            "type": "string",
            "data": "CreatedTime"
          }
        },
        "dst": [
          {
            "variable": {
              "name": "column_name"
            }
          }
        ]
      }
    },
    {
      "transfer_data": {
        "src": {
          "static_value": {
            "format": "scalar",
            "type": "string",
            "data": "DataSet"
          }
        },
        "dst": [
          {
            "variable": {
              "name": "table_name"
            }
          }
        ]
      }
    },
    {
      "run_sql": {
        "src": {
          "sql": {
            "db_name": "SUMMARY",
            "sql_statement": "SELECT @{column_name} FROM @{table_name}"
          }
        },
        "dst": [
		  {
			"db_table": {
			  "db_name": "SUMMARY",
			  "table_name": "SomeNewTable",
			  "schema": {
				"columns": [{
				  "name": "CreatedTime"
				}]
			  }
			}
		  }
		]
      }
    }
  ]
}
-->

<!-- SAMPLE_JSON:
TITLE: <b>set_variable</b> operation with variable destination

Setting user configured data into a variable:
This sample shows a basic set_variable from a static value. But the static value
only represents a default value that the author defined. The data itself can be
exposed to the UI or to a backend mapper. The JSON key would be
operation_list[0].set_variable.src.static_value.data
{
	"operation_list": [{
		"set_variable": {
			"src": {
				"static_value": {
					"format": "scalar",
					"type": "int",
					"data": "10"
				}
			},
			"dst": [{
				"variable": {
					"name": "DevicesPerPort"
				}
			}]
		}
	}]
}

Writing an SQL record set into a variable:
SQL queries produce record sets that are represented as tables. An entire table can be
held in a single variable. This sample will query a database table and store the results
in a variable. It will then query a database across joined tables and store the record set
in another variable.
{
	"operation_list": [{
		"set_variable": {
			"src": {
				"sql": {
					"db_name": "SUMMARY",
					"sql_statement": [{
						"static": "SELECT * FROM SomeTable"
					}]
				}
			},
			"dst": [{
				"variable": {
					"name": "SomeTable"
				}
			}]
		}
	}, {
		"set_variable": {
			"src": {
				"sql": {
					"db_name": "SUMMARY",
					"sql_statement": [{
						"static": "SELECT SomeTable.Field1, OtherTable.Field4 FROM SomeTable, OtherTable"
					}]
				}
			},
			"dst": [{
				"variable": {
					"name": "Fields1And4"
				}
			}]
		}
	}]
}

Writing an SQL record set single value into a variable:
SQL queries produce record sets that are represented as tables. Sometimes we want to store
only a single value from that record set into a variable. Both of these set_variable operations
result in the same value.

In the first case, the query returns a record set with multiple columns and rows, so we need to
tell the transform which column name to use for the column and which column name to use as a key
to match the row_id value to identify the row (and if primary_key_column is not specified, then
the internal column row_id is used).

In the second case, the query returns a single cell (one row and one column table), so we just
need to run the record set through a transform to get a scalar value.
{
	"operation_list": [{
		"set_variable": {
			"src": {
				"sql": {
					"db_name": "SUMMARY",
					"sql_statement": [{
						"static": "SELECT * FROM MethIterExpectedTxCount"
					}]
				}
			},
			"dst": [{
				"transform_list": [{
					"table_to_scalar": {
						"column_name": "Expected Tx Count",
						"primary_key_column": "Iteration",
						"row_id": 2
					}
				}],
				"variable": {
					"name": "Expected Tx Count"
				}
			}]
		}
	}, {
		"set_variable": {
			"src": {
				"sql": {
					"db_name": "SUMMARY",
					"sql_statement": [{
						"static": "SELECT `Expected Tx Count` FROM MethIterExpectedTxCount WHERE Iteration = 2"
					}]
				}
			},
			"dst": [{
				"transform_list": [{
					"table_to_scalar": {}
				}],
				"variable": {
					"name": "Expected Tx Count 2"
				}
			}]
		}
	}]
}

Using SQL queries as variable expression processors:
You can use SQL queries as expression processors for variables without the need for any
database involvement. For example, let's say you hold the following information in variables:

DevicesPerPort            The number of devices configured per port
TotalPorts                The total number of ports

To form an expression for the total number of devices, (DevicesPerPort * TotalPorts),
you simply form a SELECT statement with those variables and operators.

SELECT DevicesPerPort * TotalPorts

When the variables' contents are substituted, the SELECT statement looks something like:

SELECT 10 * 2

Of course it doesn't look like this in JSON. Instead, you need to break apart the SELECT statement
into those portions that are true SQL and those that are variable names that will be substituted with
their respective values.

Note the white spaces are explicitly provided by the author while the run_sql operation adds nothing
during the variable substitution other than the values themselves.
{
	"operation_list": [{
		"set_variable": {
			"src": {
				"sql": {
					"db_name": "SUMMARY",
					"sql_statement": [{
						"static": "SELECT "
					}, {
						"variable": "DevicesPerPort"
					}, {
						"static": " * "
					}, {
						"variable": "TotalPorts"
					}]
				}
			},
			"dst": [{
				"variable": {
					"name": "TotalDevices"
				}
			}]
		}
	}]
}

Writing a database table into a variable:
A db_table source type represents a database table. An entire table can be
held in a single variable. This sample will identify a database table to store
in a variable.

With the entire table in the variable, you can use the variable as a source
and run it through a table_to_scalar transform to pull out individual cell data.
{
	"operation_list": [{
		"set_variable": {
			"src": {
				"db_table": {
					"db_name": "SUMMARY",
					"table_name": "SomeTable"
				}
			},
			"dst": [{
				"variable": {
					"name": "SomeTable"
				}
			}]
		}
	}]
}

Writing a BLL object into a variable in table form:
The following set_variable operation will write into variable "East Port Group" a table
structure of BLL properties for all ports that are tagged "east_port_group". The variable
can then be written to the database (for example) using get_variable with db_table as a
destination. The results will be very similar to that of the SaveResults command.
{
	"operation_list": [{
		"set_variable": {
			"src": {
				"bll_object": {
					"tag_name_list": ["east_port_group"],
					"class_name": "Port"
				}
			},
			"dst": [{
				"variable": {
					"name": "East Port Group"
				}
			}]
		}
	}, {
		"get_variable": {
			"src": {
				"variable": {
					"name": "East Port Group"
				}
			},
			"dst": [{
				"db_table": {
					"table_name": "EastPortGroupProperties"
				}
			}]
		}
	}]
}

Writing specific BLL object properties into a variable in table form:
The following set_variable operation will write into variable "East Port Group" a table
structure of specific BLL properties for all ports that are tagged "east_port_group". The variable
can then be written to the database (for example) using get_variable with db_table as a
destination. The results will include those properties that the author specifies along with
the Handle and ParentHnd properties.
{
	"operation_list": [{
		"set_variable": {
			"src": {
				"bll_object": {
					"tag_name_list": ["east_port_group"],
					"class_name": "Port",
					"property_name_list": ["name", "location"]
				}
			},
			"dst": [{
				"variable": {
					"name": "East Port Group"
				}
			}]
		}
	}, {
		"get_variable": {
			"src": {
				"variable": {
					"name": "East Port Group"
				}
			},
			"dst": [{
				"db_table": {
					"table_name": "EastPortGroupProperties"
				}
			}]
		}
	}]
}

Writing a single BLL object property JSON element into a variable in scalar form:
The following will pull a static value from a run_sql operation and place it into the variable.
The ProcessDataCommand is also shown in the sample so that the JSON key can be understood better.
The variable will result with the value 5. Keep in mind that a transform is required to cast the scalar
to an integer, because the JSON value is naturally a string.

Without the json_key included in the bll_object_property, the entire property value would be placed into
the variable as a string.
{
	"operation_list": [{
		"set_variable": {
			"src": {
				"bll_object_property": {
					"class_name": "spirent.methodology.ProcessDataCommand",
					"property_name": "InputJson",
					"tag_name_list": ["tConfigure"],
					"json_key": "operation_list[0].run_sql.src.sql.sql_statement[1].static"
				}
			},
			"dst": [{
				"transform_list": [{
					"cast_scalar": {
						"type": "int"
					}
				}],
				"variable": {
					"name": "DeviceCount"
				}
			}]
		}
	}]
}
Meanwhile, in another ProcessDataCommand far, far away tagged with tConfigure...
{
	"operation_list": [{
		"run_sql": {
			"src": {
				"sql": {
					"sql_statement": [{
						"static": "CREATE TABLE IF NOT EXISTS MethConfig AS SELECT "
					}, {
						"static": "5"
					}, {
						"static": " AS 'Device Count', "
					}, {
						"static": "60"
					}, {
						"static": " AS 'Router Up Timeout'"
					}]
				}
			}
		}
	}]
}

Writing a scalar to variable from a variable that holds a list:
The following set_variable operation will take a list from one variable, pass it through a
list_to_scalar transform to pull out one item (the third by index) and then pass that scalar
through a cast_scalar transform to get an int to write to another variable.
{
	"operation_list": [{
		"set_variable": {
			"src": {
				"variable": {
					"name": "SomeList"
				}
			},
			"dst": [{
				"transform_list": [{
					"list_to_scalar": {
						"index": 2
					}
				}, {
					"cast_scalar": {
						"type": "int"
					}
				}],
				"variable": {
					"name": "SomeScalar"
				}
			}]
		}
	}]
}

Writing a scalar from the iterator to a variable:
{
	"operation_list": [{
		"set_variable": {
			"src": {
				"iterator_value": {
					"tag_name_list": ["tIter"],
					"property": "CurrVal"
				}
			},
			"dst": [{
				"variable": {
					"name": "SomeScalar"
				}
			}]
		}
	}]
}
-->

<!-- SAMPLE_JSON:
TITLE: <b>get_variable</b> operation with variable source

Sending a pass/fail variable to the command pass/fail state:
The get_variable sample will pull a boolean from the variable Verdict and pass it to the
ProcessDataCommand's pass/fail state. This can be used in an IF or WHILE command to help
make branching decisions.
{
	"operation_list": [{
		"get_variable": {
			"src": {
				"variable": {
					"name": "Verdict"
				}
			},
			"dst": [{
				"command_pass_fail_state": {
					"status_value_on_fail": "0"
				}
			}]
		}
	}]
}

Copy one variable to another:
The following sample copies the contents of one variable to another. However, the contents
can be modified through transformers as in the case of the second destination.
{
	"operation_list": [{
		"get_variable": {
			"src": {
				"variable": {
					"name": "ListOfData"
				}
			},
			"dst": [{
				"variable": {
					"name": "SomeList"
				}
			}, {
				"transform_list": [{
					"list_to_scalar": {
						"index": 2
					}
				}, {
					"cast_scalar": {
						"type": "int"
					}
				}],
				"variable": {
					"name": "SomeScalar"
				}
			}]
		}
	}]
}

Copy a variable to a database table:
The following sample copies the contents of one variable a database table. If the data in the
variable is already in table form, then it will be stored in the database as is. If the data
is a scalar, it will be stored in a table with a single row and column and the column name will
be "Data".
{
	"operation_list": [{
		"get_variable": {
			"src": {
				"variable": {
					"name": "SomeTableVariable"
				}
			},
			"dst": [{
				"db_table": {
					"table_name": "TheTableOfData"
				}
			}]
		}
	}]
}

Copy a variable to a BLL object property:
The following will copy a scalar variable to the BLL object property "name" for all ports that have
the east_port_group tag.
{
	"operation_list": [{
		"get_variable": {
			"src": {
				"variable": {
					"name": "SomeTableVariable"
				}
			},
			"dst": [{
				"bll_object_property": {
					"class_name": "Port",
					"property_name": "name",
					"tag_name_list": ["east_port_group"]
				}
			}]
		}
	}]
}
-->

<!-- SAMPLE_JSON:
TITLE: <b>get_iterator</b> operation with iterator_value source

The get_iterator operation gets the property value(s) of a tagged iterator command. The 'property'
field of iterator_value is an enum: CurrVal, Iteration, PrevIterVerdict or All. A scalar format is
returned for CurrVal (string), Iteration (int), and PrevIterVerdict (bool), while a table_data
format is returned for All.

In this sample, iterator_value is the source and bll_object_property is the destination. The value
of 'CurrVal' of an iterator command tagged with 'Tag_Iterator' sets the 'DeviceCount' property of
an emulated device object tagged with 'WestDevices'.
{
	"operation_list": [{
		"get_iterator": {
			"enable": true,
			"src": {
				"iterator_value": {
					"tag_name_list": ["Tag_Iterator"],
					"property": "CurrVal"
				}
			},
			"dst": [{
				"enable": true,
				"bll_object_property": {
					"tag_name_list": ["WestDevices"],
					"class_name": "EmulatedDevice",
					"property_name": "DeviceCount"
				}
			}]
		}
	}]
}

In this sample, iterator_value is the source and bll_object (with property_name_list) is the
destination. The value of 'CurrVal' of an iterator command tagged with 'Tag_Iterator' sets the
'CurrVal' property of another iterator command object tagged with 'RateIterCmd'.  The property
names must match.
{
	"operation_list": [{
		"get_iterator": {
			"enable": true,
			"src": {
				"iterator_value": {
					"tag_name_list": ["Tag_Iterator"],
					"property": "CurrVal"
				}
			},
			"dst": [{
				"enable": true,
				"bll_object": {
					"tag_name_list": [
						"RateIterCmd"
					],
					"class_name": "spirent.methodology.RateIteratorCommand",
					"property_name_list": ["CurrVal"]
				}
			}]
		}
	}]
}

In this sample, iterator_value is the source and variable is the destination. The value of
'Iteration' of an iterator command tagged with 'Tag_Iterator' is stored into an already existing
variable, 'MyVariable'.
{
	"operation_list": [{
		"get_iterator": {
			"enable": true,
			"src": {
				"iterator_value": {
					"tag_name_list": ["Tag_Iterator"],
					"property": "Iteration"
				}
			},
			"dst": [{
				"enable": true,
				"variable": {
					"name": "MyVariable"
				}
			}]
		}
	}]
}
-->

<!-- SAMPLE_JSON:
TITLE: <b>set_command_pass_fail_state</b> operation with command_pass_fail_state as destination

The set_command_pass_fail_state operation uses the src value to set the boolean Pass/Fail State for
the running ProcessDataCommand.  In the case that the Pass/Fail State is set to False (Fail)
status_value_on_fail is passed to the caller as the failure string.

From sql source:
The following converts the result of a SQL query to the boolean Pass/Fail State for the running
ProcessDataCommand.
{
	"operation_list": [{
		"set_command_pass_fail_state": {
			"src": {
				"sql": {
					"db_name": "SUMMARY",
					"sql_statement": [{
						"static": "SELECT avalue FROM atable"
					}]
				}
			},
			"dst": [{
				"command_pass_fail_state": {
					"description": "some description",
					"status_value_on_fail": "some failure status"
				}
			}]
		}
	}]
}

From variable source:
The following converts the contents of variable "XYZ" to the boolean Pass/Fail State for the running
ProcessDataCommand .
{
	"operation_list": [{
		"set_command_pass_fail_state": {
			"src": {
				"variable": {
					"name": "XYZ"
				}
			},
			"dst": [{
				"command_pass_fail_state": {
					"description": "some description",
					"status_value_on_fail": "some failure status"
				}
			}]
		}
	}]
}

From bll_object_property source:
The following uses the PassFailState property of a VerifyResultsValueCommand with tag "MYTAG" to
set the Pass/Fail State for the running ProcessDataCommand.
{
	"operation_list": [{
		"set_command_pass_fail_state": {
			"src": {
				"bll_object_property": {
					"tag_name_list": ["MYTAG"],
					"class_name": "VerifyResultsValueCommand",
					"property_name": "PassFailState"
				}
			},
			"dst": [{
				"command_pass_fail_state": {
					"description": "some description",
					"status_value_on_fail": "some failure status"
				}
			}]
		}
	}]
}
-->

<!-- SAMPLE_JSON:
TITLE: <b>get_bll_object_data</b> operation getting from BLL object properties

This operation allows the author to choose between bll_object and bll_object_property as the source. Authors
must be careful to apply the correct source for the desired data. bll_object returns information about the
BLL properties in a table form where the property name is the column name and the property value is the row
value under that column. On the other hand, bll_object_property is used to present a scalar data representing
only one property value.


The following sample will generate a table PortObjectsOfInterest and create a column for each Port property,
then one new row that contains the designated property values for each port that is tagged with ttPort.
Only those properties specified by property_name_list will be included, along with Handle and ParentHnd.
If property_name_list is empty or missing, then all properties will be included.

In this example, note that the bll_object source returns a table form of data with four columns specified
by the author. Two additional columns will be added, Handle and ParentHnd. This table is then written to
the destination.
{
	"operation_list": [{
		"get_bll_object_data": {
			"enable": true,
			"src": {
				"bll_object": {
					"tag_name_list": ["ttPort"],
					"class_name": "Port",
					"property_name_list": ["Name", "PortName", "Online", "IsVirtual"]
				}
			},
			"dst": [{
				"enable": true,
				"db_table": {
					"db_name": "SUMMARY",
					"table_name": "PortObjectsOfInterest"
				}
			}]
		}
	}]
}

This sample uses the object_handle variable type to specify the port object.
{
	"operation_list": [{
		"get_bll_object_data": {
			"enable": true,
			"src": {
				"bll_object": {
					"object_handle": {"variable": {"name": "Port1_handle"}},
					"class_name": "Port",
					"property_name_list": ["Name", "PortName", "Online", "IsVirtual"]
				}
			},
			"dst": [{
				"enable": true,
				"db_table": {
					"db_name": "SUMMARY",
					"table_name": "PortObjectsOfInterest"
				}
			}]
		}
	}]
}

This sample uses both the object_handle sql type and the tag_name_list to specify the port objects.
{
	"operation_list": [{
		"get_bll_object_data": {
			"enable": true,
			"src": {
				"bll_object": {
					"object_handle": {"sql": {"sql_statement": [{"static": "SELECT Handle FROM Ports"}]}},
					"tag_name_list": ["ttPort"],
					"class_name": "Port",
					"property_name_list": ["Name", "PortName", "Online", "IsVirtual"]
				}
			},
			"dst": [{
				"enable": true,
				"db_table": {
					"db_name": "SUMMARY",
					"table_name": "PortObjectsOfInterest"
				}
			}]
		}
	}]
}

This sample copies the Name property of the Project object to a table with one row and one column.
The translation from scalar to table is implicitly performed.
{
	"operation_list": [{
		"get_bll_object_data": {
			"enable": true,
			"src": {
				"bll_object_property": {
					"tag_name_list": ["ttProject"],
					"class_name": "Project",
					"property_name": "Name"
				}
			},
			"dst": [{
				"enable": true,
				"db_table": {
					"db_name": "SUMMARY",
					"table_name": "PortObjectsOfInterest"
				}
			}]
		}
	}]
}
-->

<!-- SAMPLE_JSON:
TITLE: <b>set_bll_object_data</b> operation setting BLL object properties

This operation allows the author to choose between bll_object and bll_object_property as the destination. Authors
must be careful to apply the correct destination type for the intended outcome.

The following sample will set the name of the port object(s) that are tagged with ttPort
to the string provided in the static_value source.
{
	"operation_list": [{
		"set_bll_object_data": {
			"src": {
				"static_value": {
					"format": "scalar",
					"data": "New Name For Port BLL Object"
				}
			},
			"dst": [{
				"bll_object_property": {
					"tag_name_list": ["ttPort"],
					"class_name": "Port",
					"property_name": "Name"
				}
			}]
		}
	}]
}

This sample uses the object_handle variable type to specify the target port object.
{
	"operation_list": [{
		"set_bll_object_data": {
			"src": {
				"static_value": {
					"format": "scalar",
					"data": "New Name For Port BLL Object"
				}
			},
			"dst": [{
				"bll_object_property": {
					"object_handle": {"variable": {"name": "Port1_handle"}},
					"class_name": "Port",
					"property_name": "Name"
				}
			}]
		}
	}]
}

This sample uses both the object_handle sql type and tag_name_list to specify the target port objects.
{
	"operation_list": [{
		"set_bll_object_data": {
			"src": {
				"static_value": {
					"format": "scalar",
					"data": "New Name For Port BLL Object"
				}
			},
			"dst": [{
				"bll_object_property": {
					"object_handle": {"sql": {"sql_statement": [{"static": "SELECT Handle FROM Ports"}]}},
					"tag_name_list": ["ttPort"],
					"class_name": "Port",
					"property_name": "Name"
				}
			}]
		}
	}]
}

The following sample will set the router id of an emulated device with the results
of an SQL query from a configuration table.
{
	"operation_list": [{
		"set_bll_object_data": {
			"src": {
				"sql": {
					"sql_statement": [{
						"static": "SELECT RouterId FROM DeviceConfiguration"
					}]
				}
			},
			"dst": [{
				"bll_object_property": {
					"tag_name_list": ["ttDevice"],
					"class_name": "EmulatedDevice",
					"property_name": "RouterId"
				}
			}]
		}
	}]
}

The following sample will set the RouterId property of one emulated device to be identical to that of another.
{
	"operation_list": [{
		"set_bll_object_data": {
			"src": {
				"bll_object_property": {
					"tag_name_list": ["ttDeviceEast"],
					"class_name": "EmulatedDevice",
					"property_name": "RouterId"
				}
			},
			"dst": [{
				"bll_object_property": {
					"tag_name_list": ["ttDeviceWest"],
					"class_name": "EmulatedDevice",
					"property_name": "RouterId"
				}
			}]
		}
	}]
}

Another sample copying the RouterId property from one device to another; but in this example, the
source is in table form and must be passed through a table_to_scalar transform before being written
to the destination BLL property.
{
	"operation_list": [{
		"set_bll_object_data": {
			"src": {
				"bll_object": {
					"tag_name_list": ["ttDeviceEast"],
					"class_name": "EmulatedDevice",
					"property_name_list": ["RouterId"]
				}
			},
			"dst": [{
				"transform_list": [{
					"table_to_scalar": {}
				}],
				"bll_object_property": {
					"tag_name_list": ["ttDeviceWest"],
					"class_name": "EmulatedDevice",
					"property_name": "RouterId"
				}
			}]
		}
	}]
}

This sample takes the properties in the property_name_list of the source bll_object and writes them
into the corresponding properties of the destination bll_object. Note in this case we are copying more
than one property, so we use bll_object for both source and destination. If we were copying only one
property, bll_object_property may be used instead.
{
	"operation_list": [{
		"set_bll_object_data": {
			"src": {
				"bll_object": {
					"tag_name_list": ["ttDeviceEast"],
					"class_name": "EmulatedDevice",
					"property_name_list": ["RouterId", "Name"]
				}
			},
			"dst": [{
				"bll_object": {
					"tag_name_list": ["ttDeviceWest"],
					"class_name": "EmulatedDevice",
					"property_name_list": ["RouterId", "Name"]
				}
			}]
		}
	}]
}

In this example, the db_table source returns data in a table form. The table is transformed into a
scalar (the first cell in the first row) and the cell data is written to the emulated device RouterId
property.
{
	"operation_list": [{
		"set_bll_object_data": {
			"src": {
				"db_table": {
					"db_name": "SUMMARY",
					"table_name": "DeviceConfig"
				}
			},
			"dst": [{
				"transform_list": [{
					"table_to_scalar": {}
				}],
				"bll_object_property": {
					"tag_name_list": ["ttDeviceWest"],
					"class_name": "EmulatedDevice",
					"property_name": "RouterId"
				}
			}]
		}
	}]
}

In this example, the first row of table DeviceConfig is read and the column(s) with the same name(s) as the property(s)
being set are copied to the emulated devices' property(s) for each emulated device tagged with ttDeviceWest. In
this example, RouterId and Name are being set.
{
	"operation_list": [{
		"set_bll_object_data": {
			"src": {
				"db_table": {
					"db_name": "SUMMARY",
					"table_name": "DeviceConfig"
				}
			},
			"dst": [{
				"bll_object": {
					"tag_name_list": ["ttDeviceWest"],
					"class_name": "EmulatedDevice",
					"property_name_list": ["RouterId", "Name"]
				}
			}]
		}
	}]
}

bll_object_property can also look for specific relations by using the relation_list array key.
relation_list is a list of Relations to traverse. Append -sources to name to traverse in the reverse direction.
Note that if this property is empty, will only use the default list, which traverses ParentChild and AffiliationPort-sources.
All traversed relations must be included explicitly in this list. (this is the same as the RelationList in SetPropertyCommand)

In the following example, the LoadUnits for a StreamBlockLoadProfile will be changed
using the value in the scalar src.
{
	"operation_list": [{
		"set_bll_object_data": {
			"src": {
				"static_value": {
					"format": "scalar",
					"data": "KILOBITS_PER_SECOND",
                    "type": "string"
				}
			},
			"dst": [{
				"bll_object_property": {
					"tag_name_list": ["ttStreamBlock"],
					"class_name": "StreamBlockLoadProfile",
					"property_name": "LoadUnit",
                    "relation_list": ["AffiliationStreamBlockLoadProfile"]
				}
			}]
		}
	}]
}

-->

<!-- SAMPLE_JSON:
TITLE: <b>force_copy_db_table</b> operation that forces the copy of one table to another

In this sample, SomeTable is copied from the LAST_ITERATION database to the SUMMARY database.
{
	"operation_list": [{
		"force_copy_db_table": {
			"src": {
				"db_table": {
					"db_name": "LAST_ITERATION",
					"table_name": "SourceTable"
				}
			},
			"dst": [{
				"db_table": {
					"db_name": "SUMMARY",
					"table_name": "SourceTable"
				}
			}]
		}
	}]
}

During the copy, the ordering of the columns can be changed, but the names of the columns must match.
In this sample, spirent_methodology_stm_Variables is copied from the LAST_ITERATION database to the
SUMMARY database.
{
	"operation_list": [{
		"force_copy_db_table": {
			"src": {
				"db_table": {
					"db_name": "LAST_ITERATION",
					"table_name": "spirent_methodology_stm_Variables"
				}
			},
			"dst": [{
				"db_table": {
					"db_name": "SUMMARY",
					"table_name": "VariablesOfAnotherOrder",
					"schema": {
						"columns": [{
							"name": "Id"
						}, {
							"name": "VariableDict"
						}, {
							"name": "DataSetId"
						}, {
							"name": "Name"
						}, {
							"name": "AlarmState"
						}, {
							"name": "Active"
						}, {
							"name": "ParentHnd"
						}, {
							"name": "Handle"
						}, {
							"name": "LocalActive"
						}]
					}
				}
			}]
		}
	}]
}
-->

<!-- SAMPLE_JSON:
TITLE: <b>transfer_data</b> is a generic operation that accepts any source and any destination

The following sample demonstrates creating a fact table along with the generic transfer_data operation.
It assumes the configuration has a port tagged as MyPort. The port handle is retrieved using a SQL
query and saved to the port_handle variable. A transform is done on the table output of the SQL
query to a scalar value. The third opertion outputs the variable contents to the TestCenter logs.
The log_output destination can be used by authors to debug the source output of operations.
The log_level may be Debug, Info, Warning or Error.

{
	"operation_list": [{
		"create_fact_table": {
			"fact_table_name": "Fact_Port",
			"src_fact_tables": ["Port"]
		}
	}, {
		"transfer_data": {
			"src": {
				"sql": {
					"db_name": "LAST_ITERATION",
					"sql_statement": [{
						"static": "SELECT Port_Handle FROM Fact_Port WHERE Port_TagName = 'MyPort'"
					}]
				}
			},
			"dst": [{
				"transform_list": [{
					"table_to_scalar": {}
				}],
				"variable": {
					"name": "port_handle"
				}
			}]
		}
	}, {
		"transfer_data": {
			"src": {
				"variable": {
					"name": "port_handle"
				}
			},
			"dst": [{
				"log_output": {
					"log_level": "Info"
				}
			}]
		}
	}]
}
-->

<!-- SAMPLE_JSON:
TITLE: <b>python_script</b> operation to run python script

This operation allows the author to run a function of a python script with a list of arguments
and then set the return value to a list of destinations. The supported input argument type is
variable or static value and the supported destination type is command_pass_fail_state,
bll_object_property and variable. The function must return at least one parameter and the first
return parameter from the function must be a string (empty or non-empty). The empty string means
there is no error while executing the function and non-empty string means the error information
while executing the function. When the destination of the first returned string is command_pass_fail_state,
if the string is empty, the verdict of command_pass_fail_state is set to True; if the string is
not empty, the verdict of command_pass_fail_state is set to FALSE. Regardless of whether the first
destination is command_pass_fail_state or not, if the first return value is non-empty string, then
the operation assumes the script failed and that any additional return values are undefined and
will not be assigned to their destinations.

The following example shows how to use the python_script. The my_python_func of my_python_file.py
file needs one argument and returns two parameters. "filename" defines the python script file name.
"function" defines the function name to be called. "src" defines the list of arguments passed to the
function, here it is a static_value. "dst" defines the list of destinations, the first destination
is command_pass_fail_state and the second destination is py_myVar. "filename", "function" and "dst"
are required for python_script operation while the "src" is optional.
{
    "operation_list": [{
        "python_script": {
            "filename": "my_python_file",
            "function": "my_python_func",
            "src": [
                {
                    "static_value": {
                        "format": "scalar",
                        "data": 123
                    }
                }
            ],
            "dst": [
                {
                    "command_pass_fail_state": {
                        "status_value_on_fail": "why failed"
                    }
                },
                {
                    "variable": {
                        "name": "py_myVar"
                    }
                }
            ]
		}
	}]
}

The following example supposes my_python_func of my_python_file file has no input arguments and
return only the script's return error string.
{
    "operation_list": [{
        "python_script": {
            "filename": "my_python_file",
            "function": "my_python_func",
            "dst": [
                {
                    "variable": {
                        "name": "py_myVar"
                    }
                }
            ]
		}
	}]
}
-->


<!-- SAMPLE_JSON:
TITLE: <b>create_report_table</b> operation to create report tables

This operation creates data tables for reports. If the operation is performed
within the context of an iteration, the table is generated in the report within
the context of that iteration. We call this an iteration report table.
If the operation is performed outside of all iteration loops, then the table
is generated in the report within the summary section. We call this a summary
report table.

The following sample creates a table that contains two columns with the names
"Client Port Count" and "Non-Client Port Count". The title of the table that
is generated in the report is "Port Count Discovery". This is an informational
table, it does not contain any verdict and has no impact on the pass/fail status
of the test.

This table will be rendered in the first section of its report (iteration or summary).
{
	"operation_list": [{
		"create_report_table": {
			"table_src": {
				"sql": {
					"db_name": "SUMMARY",
					"sql_statement": [{
						"static": "SELECT ClientPortCount AS 'Client Port Count', NonClientPortCount AS 'Non-Client Port Count' FROM MethPortCount"
					}]
				}
			},
			"display_name": "Port Count Discovery",
			"report_group": "SUMMARY"
		}
	}]
}


This next sample is much like the sample above, where a database table is dumped
into a report table without any verdict applied to the report table. This report
table is informational. In this case, it is simply reporting some of the user
configuration used for this test.

Unlike the table above, the column names from this table were originally created
with the intent to be used in a report table and are properly formed for user
consumption. The configuration table being dumped is found in the summary database.
{
	"operation_list": [{
		"create_report_table": {
			"table_src": {
				"db_table": {
					"table_name": "MethBgpFlowSpecConfig"
				}
			},
			"display_name": "Flow Spec Distribution Schedule"
		}
	}]
}


The following sample creates a single row table in the report to provide
information on the current iteration. Specifically, the last row of the
table MethIterResultsSessionsUp is pulled along with the SQLite3 hidden
column rowid as the complete record set for the contents of the table.

The database table column names are used as the report table column names.
For this reason, they need to be eligible (they must include spaces, properly
capitalized letters, etc.).

The report table is also provided with a verdict that is based upon the
Verdict column of the same row that is used to generate the table's content.
It is recommended that any verdict associated with a row of data is captured
in that row so that the calculations are performed only once and the results
used every time afterwards. The verdict of this table will have an influence
on the overall test verdict.

This table will be ordered in group 2 of the iteration's section of the report.
Those tables that are SUMMARY or GROUP_1 will be rendered before this table
in the iteraton report.
{
	"operation_list": [{
		"create_report_table": {
			"table_src": {
				"sql": {
					"db_name": "SUMMARY",
					"sql_statement": [{
						"static": "SELECT rowid AS 'Iteration', * FROM MethIterResultsSessionsUp ORDER BY rowid DESC LIMIT 1"
					}]
				}
			},
			"display_name": "Iteration BGP Sessions Results",
			"report_group": "GROUP_2",
			"table_verdict": {
				"verdict_src": {
					"sql": {
						"db_name": "SUMMARY",
						"sql_statement": [{
							"static": "SELECT `Verdict` = 'PASS' FROM MethIterResultsSessionsUp ORDER BY rowid DESC LIMIT 1"
						}]
					}
				},
				"passed_verdict_explanation": "All BGP router sessions established in the allotted time.",
				"failed_verdict_explanation": "Not all BGP router sessions established in the allotted time."
			}
		}
	}]
}

-->

<!-- SAMPLE_JSON:
TITLE: <b>run_influx_db_query</b> operation to run a query on an InfluxDB

The following sample has an Influx DB as the source and a SQL DB table as the
destination. The host key specifies the IP address (or localhost) of where the
Influx DB is running. The db key specifies the database name and the query key
specifies the Influx query statement that will be executed on the Influx DB.
This example outputs the source data to the table InterfaceRxPacketCounts in the SQL Summary DB.
{
	"operation_list": [{
		"run_influx_db_query": {
			"src": {
				"influx_db_query": {
					"host": "10.15.229.243",
					"query": [{
						"static": "select rx_packets_rate, rx_packets from vswitch_interface_metrics ORDER by time DESC limit 15"
					}],
					"db": "metrics"
				}
			},
			"dst": [{
				"db_table": {
					"db_name": "SUMMARY",
					"table_name": "InterfaceRxPacketCounts"
				}
			}]
		}
	}]
}
-->

<!-- SAMPLE_JSON:
TITLE: <b>create_fact_table</b> operation to create fact tables in the database

Fact tables are available to help authors query databases for information with
less effort in creating queries. Once the fact tables are created, the run_sql
operation can be used to query against the tables with far simpler queries, because
the fact tables are already formed from SQL JOINS for the author.

This sample demonstrates creating a predefined fact table, Fact_Rx_Tx_TxSb.
Given stream blocks flowing to a port, an author can add a fact table to the
database to help access information about the traffic, stream block, and end points.

In the following example, the west port group receives traffic and some of the
latency stats are collected and put into scalar variables for later use. Note that
the latency stats are related directly to the port tag name. Without fact tables,
this relationship is still possible for authors, but it would require a rather
complicated SQL query involving multiple joins across several tables.
{
	"operation_list": [{
		"create_fact_table": {
			"fact_table_name": "Fact_Rx_Tx_TxSb"
		}
	}, {
		"set_variable": {
			"src": {
				"sql": {
					"db_name": "LAST_ITERATION",
					"sql_statement": [{
						"static": "SELECT Rx_TotalLatency, Rx_MinLatency, Rx_AvgLatency FROM Fact_Rx_Tx_TxSb WHERE Rx_Dimen_Port_TagName = 'west port group'"
					}]
				}
			},
			"dst": [{
				"transform_list": [{
					"table_to_scalar": {
						"column_name": "Rx_TotalLatency"
					}
				}],
				"variable": {
					"name": "Rx Total Latency"
				}
			}, {
				"transform_list": [{
					"table_to_scalar": {
						"column_name": "Rx_MinLatency"
					}
				}],
				"variable": {
					"name": "Rx Minimum Latency"
				}
			}, {
				"transform_list": [{
					"table_to_scalar": {
						"column_name": "Rx_AvgLatency"
					}
				}],
				"variable": {
					"name": "Rx Average Latency"
				}
			}]
		}
	}]
}

Authors can create their own fact tables.

This sample demonstrates creating a custom fact table, Fact_Bgp, which joins
the EmulatedDevice, BgpRouterConfig, BgpIpv4RouteConfig, and Ipv4NetworkConfig
tables using parent-child relationships. Tag relations are also honored and
any tags associated with any of the objects are found in their respective records.

In the following example, the device router ID and route start address are
pulled from the Fact_Bgp table by the device tag "west" and placed into variables.
{
	"operation_list": [{
		"create_fact_table": {
			"fact_table_name": "Fact_Bgp",
			"src_fact_tables": ["BgpRouterConfig", "BgpIpv4RouteConfig", "Ipv4NetworkBlock", "EmulatedDevice"]
		}
	}, {
		"set_variable": {
			"src": {
				"sql": {
					"db_name": "LAST_ITERATION",
					"sql_statement": [{
						"static": "SELECT * FROM Fact_Bgp WHERE EmulatedDevice_TagName = 'west'"
					}]
				}
			},
			"dst": [{
				"transform_list": [{
					"table_to_scalar": {
						"column_name": "EmulatedDevice_RouterId"
					}
				}],
				"variable": {
					"name": "Router ID"
				}
			}, {
				"transform_list": [{
					"table_to_scalar": {
						"column_name": "Ipv4NetworkBlock_StartIpList"
					}
				}],
				"variable": {
					"name": "Route Start IP Address"
				}
			}]
		}
	}]
}
-->

<!-- SAMPLE_JSON:
TITLE: <b>Predefined fact tables</b> for create_fact_table operation

The previous example used a predefined fact table:
{
	"operation_list": [
      {
		"create_fact_table": {
          "fact_table_name": "Fact_Rx_Tx_TxSb"
        }
	  }
    ]
}
This is the same thing as doing:
{
	"operation_list": [
      {
		"create_fact_table": {
          "fact_table_name": "Fact_Rx_Tx_TxSb",
          "src_dimension_tables": ["StreamBlock", "Port"],
          "src_fact_tables": ["RxEotStreamResults", "TxEotStreamResults", "TxEotStreamBlockResults"]
        }
	  }
    ]
}

Predefined fact tables are fact table that already have a list of source dimension and source fact tables.
They allow authors to easily create a commonly used fact table without having to think about what dimensions
and source facts are needed.

Here are the list of predefined fact tables as of 9/19/16 and build 9.90.1073. To use one of these
fact tables, simply specify the fact_table_name in the create_fact_table operation (see above).
Predefined fact tables are specified in the dimensional results configuration file:
//TestCenter/integration/framework/bll/core/STAKCommands/testmethodology/utils/dimensional_results_config.json
[
  {
    "fact_table_name": "Fact_GenAnaPort",
    "src_dimension_tables": ["Port"],
    "src_fact_tables": ["GeneratorPortResults", "AnalyzerPortResults"]
  },
  {
    "fact_table_name": "Fact_Rx_Tx_TxSb",
    "src_dimension_tables": ["StreamBlock", "Port"],
    "src_fact_tables": ["RxEotStreamResults", "TxEotStreamResults", "TxEotStreamBlockResults"]
  },
  {
    "fact_table_name": "Fact_Rx_Tx",
    "src_dimension_tables": ["StreamBlock", "Port"],
    "src_fact_tables": ["RxEotStreamResults", "TxEotStreamResults"]
  },
  {
    "fact_table_name": "Fact_Tx_TxSb",
    "src_dimension_tables": ["StreamBlock", "Port"],
    "src_fact_tables": ["TxEotStreamResults", "TxEotStreamBlockResults"]
  },
  {
    "fact_table_name": "Fact_DevAddrv4",
    "src_dimension_tables": ["Port"],
    "src_fact_tables": ["EmulatedDevice", "Ipv4If", "EthIIIf"]
  },
  {
    "fact_table_name": "Fact_DevAddrv6",
    "src_dimension_tables": ["Port"],
    "src_fact_tables": ["EmulatedDevice", "Ipv6If", "EthIIIf"]
  },
  {
    "fact_table_name": "Fact_PppoePort",
    "src_dimension_tables": ["Port"],
    "src_fact_tables": ["PppoxPortConfig", "PppoePortResults"]
  },
  {
    "fact_table_name": "Fact_Dhcpv4Block",
    "src_dimension_tables": ["Port"],
    "src_fact_tables": ["EmulatedDevice", "Dhcpv4BlockConfig", "Dhcpv4BlockResults"]
  },
  {
    "fact_table_name": "Fact_Dhcpv4Port",
    "src_dimension_tables": ["Port"],
    "src_fact_tables": ["Dhcpv4PortConfig", "Dhcpv4PortResults"]
  },
  {
    "fact_table_name": "Fact_SaaDevice",
    "src_dimension_tables": ["Port"],
    "src_fact_tables": ["EmulatedDevice", "SaaDeviceConfig", "SaaDeviceResults"]
  },
  {
    "fact_table_name": "Fact_Handle_Table_Map",
    "src_dimension_tables": [],
    "src_fact_tables": [],
    "description": "Special fact table that associates every handle in the src db to its corresponding table name. Can be used to determine the TestCenter object type for a given handle. Source dimensions and facts are ignored."
  }
]
-->

<!-- SAMPLE_JSON:
TITLE: <b>for_loop_expression</b> for turning a while command into a for loop command.

Using this operator, the ProcessDataCommand is used as the expression command of a sequencer While
command. This operator manages the expression to give the while command a for loop behaviour. The
for_loop_expression operator manages the initialization of the for loop, the current value (control
variable), the post loop increment, and the limit evaluation to terminate the for loop.

The control variable holds the current value of the for loop that the author can use within the loop.
This for_loop_expression operator does not create a framework iteration context - it cannot be used
to define a test iteration for reports.

The control variable is not deleted at the end of the loop. The loop begins by creating the control
variable if it does not exist. The variable may exist when the loop begins, in which case it is taken
 for the operator's use and no longer available for its previous use.

Variables in general are not read only, but they should be treated as such when used as control variables.
Writing to a control variable can prevent it from being recognized as and used as a control variable.

The JSON for the PDC as an expression command for the while command that counts from 0 to 9:
{
  "operation_list": [
    {
      "for_loop_expression": {
        "init": 0,
        "evaluator": "<",
        "limit": 10,
        "post_loop_add": 1,
        "control_variable": "MyVariable"
      }
    }
  ]
}

In the operator above, the control variable will be initialized to 0. At the top of each loop, the
control variable will be compared to the limit using the evaluator. If the expression (e.g., 0<10)
is true, then the loop proceeds. When the expression is false, the loop exits (the sequencer while
command exits and does not execute its block). When the loop returns to the top, the post_loop_add
value is added to the control value, and then the control value is compared to the limit using the
evaluator as before.

The loop could count down from 10 to 0 with a post_loop_add of -1; or count by a value other than 1
(e.g., count by 10). The init, limit, and post_loop_add can be integer or float.
-->

<!-- SAMPLE_JSON:
TITLE: <b>transforms</b> are used to transform output from a source before inputting to a destination

The following example shows how to use the cast_scalar and scalar_to_table transform.
All dst elements allow for an optional transform_list. In this example a static scalar value
is created with type int. Before outputting to a DB table, the value is cast to type string
and then cast to type table as db_table dst requires table_data input. Note however that
scalar_to_table is not required as it is automatically done for you (also known as an implicit transform).
{
  "operation_list": [
    {
      "transfer_data": {
        "src": {
          "static_value": {
            "format": "scalar",
            "description": "Device count",
            "data": 5,
            "type": "int"
          }
        },
        "dst": [
          {
            "transform_list": [
              {
                "cast_scalar": { "type": "string" }
              },
              {
                "scalar_to_table": { "column_name": "DeviceCount" }
              }
            ],
            "db_table": { "table_name": "DeviceConfiguration" }
          }
        ]
      }
    }
  ]
}

List of transforms:
===================
Transforms the table data into a list of dictionaries. Each row in the table will be
a dictionary with each key representing a column header.
{
  "table_data_to_list_of_dicts" : {}
}
Input: table_data
Output: json_object

Transform the table data into a list of lists, where each list in the list of lists
represents a single row of data. The column headers are lost in this transform.
{
  "table_data_to_list_of_lists" : {}
}
Input: table_data
Output: json_object

Transform a list of dictionaries into a list of lists. Literally the values
of each dictionary is turned into a list. The keys are lost in this transform.
{
  "list_of_dicts_to_list_of_lists" : {}
}
Input: json_object
Output: json_object

Transform the table data into a list where the list will comprise of the
data for each row for a column, the data for a single row, or the data for
a cell in the table.
Note: if table_data has no row_data, then the transform will return an empty list
At least column_name or primary_key_column/row_id needs to be specified in the transform.
If only column_name is specified, a json list of rows for that column will be returned.
The primary_key_column and row_id are used to strip table to a single row.
If only the primary_key_column and row_id are specified, a json list of that row of data
will be returned.
If column_name, primary_key_column and row_id are specified, a json list of that single
column/row item will be returned
{
    "table_data_to_list": {
        "column_name": <string column name>,
        "primary_key_column": <string column name>,
        "row_id": <value> | {"variable": {"name": "some_variable_name"}}
    }
}
Input: table_data
Output: list

The following is an example to return the row as a list where counter column equals to 11.
{
    "table_data_to_list": {
        "primary_key_column": "counter",
        "row_id": 11
    }
}

The following is an example to return the rate column as a list from the row where the counter
column equals to the content of my_row_id.
{
    "table_data_to_list": {
        "column_name": "rate",
        "primary_key_column": "counter",
        "row_id": {"variable": {"name": "my_row_id"}
    }
}

Transform a single data list item into a scalar value. Literally extract
a single element from the list. By default, the first element in the list
is used. Specify the optional 0-based index property to extract another
list element. If it exceeds the size of the list or is negative,
then the last item is pulled.
{
  "list_to_scalar" : {
    "index": <value> | {"variable": {"name": "some_variable_name"}} | "some_variable_name"
  }
}
Input: input
Output: scalar

The following is an example to use an integer as index value.
{
  "list_to_scalar" : {
    "index": 0
  }
}

The following is an example to use a variable as an index value.
{
  "list_to_scalar" : {
    "index": {"variable": {"name": "my_index"}
  }
}

The following is an example to use the variable name as an index value.
{
  "list_to_scalar" : {
    "index": "my_index"
  }
}

Transform a list to table format. By default the list becomes a single row
in the table. If transform_list_to is COLUMN, the list becomes a single column
with each list item becoming a row. If transform_list_to is SINGLE_CELL, all
the list elements will be extracted into a table cell as a comma sperated string.
The column_names is required and used to specify the column names of the table.
{
  "list_to_table" : {
    "transform_list_to": <"ROW" | "COLUMN" | "SINGLE_CELL">,
    "column_names": [<list of column names>]
  }
}
Input: list
Output: table_data

Cast a scalar value to a new type. If type is not specified in the transform,
no casting is done. To cast values as bool, the python bool() expression is used.
The exception to that is incoming string types are considered False if the values
are "false", "0" or "0.0".
{
  "cast_scalar" : {
    "type": <"int" | "float" | "bool" | "string">
  }
}
Input: scalar
Output: scalar

Cast the incoming type to a bool if its not already and negate the value.
Negate: True becomes False and False becomes True
{
  "negate_scalar" : {}
}
Input: scalar
Output: scalar


Transform a table_data into a scalar value. If no properties are specified
the table element in the first row and first column are used.
Optional property column_name is used to strip table to a single column.
When unspecified, the first column in the table is used.
Optional properties primary_key_column and row_id are used to strip the table to a single row.
When unspecified, the first row in the table is used.
{
    "table_to_scalar": {
        "column_name": "<string column name>",
        "primary_key_column": "<string column name>",
        "row_id": "<value>" | {"variable": {"name": "some_variable_name"}}
    }
}
Input: table_data
Output: scalar

The following is an example to return the first column from the row where the counter column
equals to 11.
{
    "table_to_scalar": {
        "primary_key_column": "counter",
        "row_id": 11
    }
}

The following is an example to return the rate column from the row where the counter column
equals to the content of my_row_id.
{
    "table_to_scalar": {
        "column_name": "rate",
        "primary_key_column": "counter",
        "row_id": {"variable": {"name": "my_row_id"}
    }
}

Transform a scalar value to a table_data.
By default the scalar value is added to the table with column name "Data".
{
    "scalar_to_table": {
        "column_name": "<string column name>"
    }
}
Input: scalar
Output: table_data

Transform a json_object to a scalar value.
By default the json object data is transformed to a scalar string value.
If json data is of type dict/object, specify json_object_key to get a specific value in the dict.
If json data is of type list/array, specify json_array_index to get a specific list element.
{
    "json_to_scalar": {
        "json_object_key": "<key name of value to get>",
        "json_array_index": <array index of value to get>
    }
}
Input: json_object
Output: scalar

Transform a json_object to a table_data.
Creates a one-row table out of the json dict/list.
If the json data is a dict/object, each key becomes a column.
If the json data is a list/array, the column_names property must be specified for each list value.
{
    "json_to_table": {
        "column_names": [<names for each JSON list value>],
        "json_key": "<dot notated path into the json to get the data to use>"
    }
}
Input: json_object
Output: table_data

Rotate a table_data so that the 1st column is orignal table column names and all other columns
are are original table rows. New columns names can be specifed using property column_name_list
or column_name_sql.
{
    "rotate_table": {
        "column_name_list": [<column name list>],
        "number_last_column": <true | false>,
        "column_name_sql": <sql>
    }
}
Input: table_data
Output: table_data

Returns scalar False if the incoming list data is empty
else returns a scalar True
{
    "transform_list": [
        {
            "list_data_exists": {
            }
        }
    ]
}
Input: list
Output: scalar

Go through elements in a table_data and makes all the NULL/None types into
any number or string value. String values should be quoted. The convert_to
key is optional and defaults to 0 if not specified.
Transform is useful when DB queries return empty values when getting results.
{
    "convert_table_data_nulls": {
        "convert_to": <number or quoted string>
    }
}
Input: table_data
Output: table_data

-->

</stc:class>

<stc:class name="SetPropertyCommand"
           displayName="Set Property Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Sets a property for given handle and tag lists."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Data Model Configuration"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="TagList" displayName="Tag List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tag names of objects being configured." />
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="core.ValidHandleTypes" value="Tag" />
    </stc:property>
    <stc:property category="input" name="ObjectList" displayName="Object List" type="handle" default="" minOccurs="0" maxOccurs="unbounded" >
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of handles of objects being configured." />
    </stc:property>
    <stc:property category="input" name="ClassName" displayName="Class Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Name of the object's class." />
    </stc:property>
    <stc:property category="input" name="RelationList" displayName="Relation List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of Relations to traverse. Append -sources to name to traverse in the reverse direction.  Note that if this property is empty, will only use the default list, which traverses ParentChild and AffiliationPort-sources. All traversed relations must be included explicitly in this list."/>
    </stc:property>
    <stc:property category="input" name="PropertyName" displayName="Property Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Name of the object's property to configure." />
    </stc:property>
    <stc:property category="input" name="JsonKey" displayName="JSON value key" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Dot separated path to JSON value" />
    </stc:property>
    <stc:property category="input" name="Value" displayName="Value" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Values for the property specified in PropertyName." />
    </stc:property>
<!-- CATEGORY: Framework: Data Model -->
</stc:class>

<stc:class name="SetPropertyFromQueryCommand"
           displayName="Set Properties from query output"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Runs a built SQL statement defined in JSON. Primarily used to retrieve set parameters from a database via a query."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Data Model Configuration"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="DbJsonString" displayName="Database JSON String" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON string representation of SQL statements to be executed."/>
        <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>
    <stc:property category="input" name="DbJsonFileName" displayName="Database JSON File" type="inputFilePath" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Location and filename of a JSON file containing SQL statements to be executed." />
      <stc:attribute type="framework.MangleRelativePath" value="false" internalType="bool" />
    </stc:property>
    <stc:property category="input" name="EnableLoadFromFileName" displayName="Enable JSON File" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True loads the JSON configuration specified by DbJsonFileName.  False loads the JSON string specified by DbJsonString." />
    </stc:property>

<!-- CATEGORY: Framework: Data Model -->
<!-- CATEGORY: Results: Database and SQL -->

<!-- SAMPLE_JSON:
This sample queries the database and stores the returned data into property in a tagged object.
{
    "sql_operations": [
        {
            "enable": false,
            "db_information": {
                "db_name": "SUMMARY"
            },
            "sql_statement": [
                {
                    "static": "SELECT Handle AS 'NHnd', name AS 'NName' FROM EotResultNode"
                },
            ]
            "set_property": [
                {
                    "class_name": "spirent.methodology.CreateMethodologyChartCommand",
                    "conversion": "DICT",
                    "property_name": "TemplateModifier",
                    "json_key": "series",
                    "tag_list": [
                        "LossChart"
                    ]
                }
            ]
        }
    ]
}
-->
</stc:class>

<stc:class name="AddTagToObjectsCommand"
           displayName="Add Tag To Objects Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Adds a tag for specified child objects."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Data Model Configuration"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
    <stc:property category="input" name="SrcTagList" displayName="Source Tag List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of tag names of parent objects." />
    </stc:property>
    <stc:property category="input" name="TargetTagName" displayName="Target Tag Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Tag name used to tag target objects."/>
    </stc:property>
    <stc:property category="input" name="ClassName" displayName="Class Name" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Name of the target object's class." />
    </stc:property>
    <stc:property category="input" name="EnableObjectRecursiveSearch" displayName="Enable Tagged Object Recursive Search" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True enables recursive search from (and including) tagged objects for objects of type ClassName.  False disables recursive search so only the tagged objects are used." />
    </stc:property>
<!-- CATEGORY: Framework: Data Model -->
</stc:class>

<stc:class name="DeleteStmRtResultCommand"
           displayName="Delete StmRtResult Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Deletes StmRtResult objects or result_id(s) within an StmRtResult object."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="ResultIdList" displayName="result_id List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="List of result_ids to be deleted.  If not specified, all existing StmRtResult objects will be deleted." />
    </stc:property>
<!-- CATEGORY: Results: Real-Time Results -->
</stc:class>

<!-- Group commands that serve to organize the sequence -->
<stc:class
    name="BaseGroupCommand"
    baseClass="stak.StakGroupCommand"
    displayName="Base Group Command"
    bllDirectInterface="true"
    canCreate="false"
    isInternal="true">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Base group command for methodology sequence organization." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Sequence"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="DisplayName" displayName="Display Name" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Group display name."/>
    </stc:property>
    <stc:property category="input" name="Description" displayName="Description" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Group description."/>
    </stc:property>
    <stc:property category="input" name="GroupKey" displayName="Group Key" type="string" default="">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Optional key to identify the group."/>
    </stc:property>

</stc:class>

<stc:class
    name="InitGroupCommand"
    baseClass="spirent.methodology.BaseGroupCommand"
    displayName="Init Group Command"
    bllDirectInterface="true"
    isInternal="false">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Group for methodology initialization commands."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Sequence"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
<!-- CATEGORY: Sequence Groups -->
</stc:class>

<stc:class
    name="TopologyGroupCommand"
    baseClass="spirent.methodology.BaseGroupCommand"
    displayName="Topology Group Command"
    bllDirectInterface="true"
    isInternal="false">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Group for methodology topology commands."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Sequence"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:enumeration name="EnumTopologySide">
        <stc:enum name="LEFT" value="0" displayName="Left side" />
        <stc:enum name="RIGHT" value="1" displayName="Right side" />
        <stc:enum name="EAST" value="2" displayName="East side" />
        <stc:enum name="WEST" value="3" displayName="West side" />
        <stc:enum name="NORTH" value="4" displayName="North side" />
        <stc:enum name="SOUTH" value="5" displayName="South side" />
        <stc:enum name="SUT" value="6" displayName="SUT" />
        <stc:enum name="NE" value="7" displayName="Northeast side" />
        <stc:enum name="SE" value="8" displayName="Southeast side" />
        <stc:enum name="NW" value="9" displayName="Northwest side" />
        <stc:enum name="SW" value="10" displayName="Southwest side" />
    </stc:enumeration>

    <stc:property name="TopologySide" type="u8" default="LEFT"
                  category="input" displayName="Topology Side">
        <stc:attribute internalIsEnum="false" internalType="string" name="none"
                       type="framework.PropertyDescription"
                       value="Label describing the part of the topology this group represents.  Acceptable values are LEFT, RIGHT, EAST, WEST, NORTH, SOUTH, SUT, NE, SE, NW, or SW."/>
        <stc:enumerationRef ref="EnumTopologySide" />
    </stc:property>
<!-- CATEGORY: Sequence Groups -->
</stc:class>

<stc:class
    name="ProtocolGroupCommand"
    baseClass="spirent.methodology.BaseGroupCommand"
    displayName="Protocol Group Command"
    bllDirectInterface="true"
    isInternal="false">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Group for methodology protocol commands."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Sequence"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
<!-- CATEGORY: Sequence Groups -->
</stc:class>

<stc:class
    name="TrafficGroupCommand"
    baseClass="spirent.methodology.BaseGroupCommand"
    displayName="Traffic Group Command"
    bllDirectInterface="true"
    isInternal="false">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Group for methodology traffic commands."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Sequence"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
<!-- CATEGORY: Sequence Groups -->
</stc:class>

<stc:class
    name="TestGroupCommand"
    baseClass="spirent.methodology.BaseGroupCommand"
    displayName="Test Group Command"
    bllDirectInterface="true"
    isInternal="false">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Group for methodology test commands."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Sequence"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
<!-- CATEGORY: Sequence Groups -->
</stc:class>

<stc:class
    name="ResultsGroupCommand"
    baseClass="spirent.methodology.BaseGroupCommand"
    displayName="Results Group Command"
    bllDirectInterface="true"
    isInternal="false">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Group for methodology results commands."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Sequence"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
<!-- CATEGORY: Sequence Groups -->
</stc:class>

<stc:class
    name="CleanUpGroupCommand"
    baseClass="spirent.methodology.BaseGroupCommand"
    displayName="Clean Up Group Command"
    bllDirectInterface="true"
    isInternal="false">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Group for methodology clean up commands."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Sequence"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
<!-- CATEGORY: Sequence Groups -->
</stc:class>

<!-- Common topologies (pre-filled group commands) -->
<stc:class
    name="BaseTopologyCommand"
    baseClass="stak.StakGroupCommand"
    displayName="Base Topology Command"
    bllDirectInterface="true"
    canCreate="false"
    isInternal="true">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Base command for methodology topology configuration organization." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Sequence"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
</stc:class>

<stc:class
    name="WestEastTopologyCommand"
    baseClass="spirent.methodology.BaseTopologyCommand"
    displayName="East-West Topology Command"
    bllDirectInterface="true"
    isInternal="false">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Container for CreateTopologyGroupCommands that define an East-West Topology."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Sequence"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
<!-- CATEGORY: Sequence Groups -->
</stc:class>

<stc:class
    name="CustomTopologyCommand"
    baseClass="spirent.methodology.BaseTopologyCommand"
    displayName="Custom Topology Command"
    bllDirectInterface="true"
    isInternal="false">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Container for CreateTopologyGroupCommands that define a Custom Topology."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
           value="Test Methodology//Sequence"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
<!-- CATEGORY: Sequence Groups -->
</stc:class>

<!-- Group for identifying VM properties/parameters -->
<stc:class
    name="VirtualMachineGroupCommand"
    baseClass="spirent.methodology.BaseGroupCommand"
    displayName="Virtual Machine Group Command"
    bllDirectInterface="true"
    isInternal="false">

    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Group for methodology commands the configure VM parameters."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory"
            value="Test Methodology//Sequence"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />
    <!-- CATEGORY: Sequence Groups -->
</stc:class>

<stc:class name="SetMetricsServiceCommand"
           displayName="Set Metrics Service Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Configure information to access the metrics service."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Data Model Configuration"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="InfluxDbHost" displayName="Influx DB Host" type="string" default="localhost">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Influx DB host address (or localhost)"/>
    </stc:property>
    <stc:property category="input" name="InfluxDbPort" displayName="Influx DB Port" type="u32" default="80">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Influx DB port"/>
    </stc:property>
    <stc:property category="input" name="GrafanaUrl" displayName="Grafana URL" type="string" default="http://localhost/grafana">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Grafana URL"/>
    </stc:property>
    <stc:property category="input" name="VerifyService" displayName="Verify Service" type="bool" default="true">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Verify Service Availability"/>
    </stc:property>
<!-- CATEGORY: Framework: Data Model -->
</stc:class>

<stc:class name="RunInfluxDbQueryCommand"
           displayName="Run Influx DB Query"
           bllDirectInterface="true"
           pythonVirtualenv="spirent.metrics"
           isInternal="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Run a query on an Influx DB.  Output is in the form of table_data (normally used by the spirent.methodology.ProcessDataCommand and related utilities)." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="InputJson" displayName="Command JSON Input" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON input for the command (see spirent.methodology.ProcessDataCommand)"/>
      <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>
    <stc:property category="output" name="TableDataJson" displayName="Table Data JSON" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Output of the Influx DB query in table data format (see spirent.methodology.ProcessDataCommand)"/>
    </stc:property>
</stc:class>

<stc:class name="AddToInfluxDbCommand"
           displayName="Add To Influx DB"
           bllDirectInterface="true"
           pythonVirtualenv="spirent.metrics"
           isInternal="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Add data to the influx DB."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="InputJson" displayName="Command JSON Input" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="JSON input for the command (see ProcessDataCommand)"/>
      <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>
    <stc:property category="input" name="InputData" displayName="JSON Data Input" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Data input for the command in JSON format" />
      <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>
</stc:class>

<stc:class name="RunGrafanaCommand"
           displayName="Run Grafana Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Configure information to access the metrics service."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="InputJson" displayName="Grafana JSON operations" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Data input for the command in JSON format" />
      <stc:attribute type="framework.StringPropertyFormat" internalIsEnum="true" internalType="u8" value="JSON" />
    </stc:property>

<!-- CATEGORY: Results: Real-Time Results -->
<!-- SAMPLE_JSON:
This sample shows a create and delete datasource operation
{
    "operation_list": [
        {
            "enable": true,
            "create_datasource": {
                "name": "test_datasource1",
                "type": "influxdb",
                "url": "http://mydatasource.com",
                "database": "mymetrics",
                "access": "proxy"
            }
        },
        {
            "enable": true,
            "delete_datasource": {
                "name":"test_datasource2"
            }
        }
    ]
}
-->
</stc:class>

<stc:class name="AddInfluxDbEventCommand"
           displayName="Add Event to Influx DB"
           bllDirectInterface="true"
           pythonVirtualenv="spirent.metrics">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Add Event to Influx DB."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

    <stc:property category="input" name="EventTitle" displayName="Event Title" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Title value for Event"/>
    </stc:property>
    <stc:property category="input" name="EventText" displayName="Event Text" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Description text for Event"/>
    </stc:property>
    <stc:property category="input" name="EventTagList" displayName="Event Tag List" type="string" default="" minOccurs="0" maxOccurs="unbounded">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="A list of tags to associate event with (spaces and commas are not allowed)"/>
      <stc:regExpValidation pattern="[^, ]*" errorMsg="Spaces and commas are not allowed"/>
    </stc:property>
    <stc:property category="input" name="Database" displayName="InfluxDB database name" type="string" default="metrics">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Name of database to use for InfluxDB operation" />
    </stc:property>
    <stc:property category="input" name="Measurement" displayName="InfluxDB measurement name" type="string" default="stm_events">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Name of measurement (table) to use for InfluxDB operation" />
    </stc:property>
    <stc:property category="input" name="SessionToken" displayName="Session Token Value" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Session Token Value (Leave blank to use MethodologyCenter session token value)"/>
    </stc:property>
    <stc:property category="input" name="IgnoreInsertError" displayName="Ignore DB Insert Errors" type="bool" default="false">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="True ignores DB insert errors and the command will return True.  False will assert the error and the command will return False." />
    </stc:property>
    <stc:property category="input" name="EventTime" displayName="Event Time" type="string" default="">
      <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Event Time (Leave blank to use current time)"/>
    </stc:property>
<!-- CATEGORY: Results: Real-Time Results -->
</stc:class>

<stc:class name="CreatePortMapResultTableCommand"
           displayName="Create Port Map Result Table Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Create a table in the test report with TestCenter ports, port speed and corresponding connections." />
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology//Results" />
    <stc:attribute type="core.RequireApplyToIL" value="false" internalType="bool" />
    <stc:attribute type="core.RequirePostApplyToIL" value="false" internalType="bool" />

<!-- CATEGORY: Results: Test Report -->
</stc:class>

<stc:class name="InitPerfMetricsRealTimeResultsCommand"
           displayName="Initialize Performance Metrics Real Time Results Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Setup performance metrics real time result subscriptions."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>

    <stc:enumeration name="EnumPerfMetricsType">
        <stc:enum name="PORT_TRAFFIC" value="0" displayName="Port Traffic Results"/>
        <!-- <stc:enum name="STREAM_BLOCK_TRAFFIC" value="1" displayName="Stream Block Traffic Results"/> -->
    </stc:enumeration>

    <stc:property name="PerformanceMetricsType" category="input" displayName="Performance Metrics Type" type="u8" default="PORT_TRAFFIC">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Type of performance metric" />
        <stc:enumerationRef ref="EnumPerfMetricsType"/>
    </stc:property>
    <stc:property name="OverrideDefaultMode" category="input" displayName="Override Default Mode" type="bool" default="false">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Enable manual setting of the counter and jitter modes" />
    </stc:property>
    <stc:property name="CounterMode" type="u8" default="LATENCY_JITTER" category="input" displayName="Counter Mode">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Counter mode which the correct counter will be selected" />
        <stc:enumerationRef ref="ResultOptions.EnumResultViewMode"/>
    </stc:property>
    <stc:property name="JitterMode" type="u8" default="RFC4689ABSOLUTEVALUE" category="input" displayName="Jitter Mode">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Jitter mode to decide what method to use for jitter calculation" />
        <stc:enumerationRef ref="ResultOptions.EnumJitterMode"/>
    </stc:property>

</stc:class>

<stc:class name="CreateMetricsResultsCommand"
           displayName="Create Metrics Results Command"
           bllDirectInterface="true">
    <stc:attribute internalIsEnum="false" internalType="bool" name="none" type="core.Sequenceable" value="true"/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandDescription" value="Create metrics results."/>
    <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.CommandCategory" value="Test Methodology"/>

    <stc:property name="ResultTypeList" category="input" displayName="Result Types" type="string" default="" minOccurs="0" maxOccurs="unbounded">
        <stc:attribute internalIsEnum="false" internalType="string" name="none" type="framework.PropertyDescription" value="Type of metrics results to create.  The following result type(s) is currently supported: NFV_INTERFACE_ALERTS, ITERATION_NFV_INTERFACE_ALERTS, ITERATION_NFV_INTERFACE_STATS_REPORT" />
    </stc:property>
</stc:class>


</stc:meta>
