#####################################################################
# "Copyright 2008 Spirent Communications, PLC. All rights reserved"
#
# Author:    Ricky zhu
#
# Revision:  Original Nov 17, 2008
#
# Title:      HLTAPI_VPLS_Feature_vlan_traffic.tcl
# TestCase:   HLTAPI/VPLS/VPLS_Feature_vlan_traffic
# Objective: To verify that VPLS sth::emulation_vpls_site_config and sth::emulation_l2vpn_pe_config commands work correctly.
#            Use two STC ports through Cisco 7613 DUT. Please refer to "VPLS_LDP_2port.cfg" on cisco 7613 disk0. Its IP is 10.99.0.191.
#
# Note:      the script can be used as regression test
#
# Pre-requisites: 1) Two ports connected back to back.
#                 2) Card can run with: Raven / Mystique
#                 3) HLTAPI v2.30
#                 4) TCLx v8.4
#                 5) Phx autommation api v2.30
#
# Pass/Fail
# Citeria:    Script fails if  1. HLTAPI returns status = 0
#                              2. The status of RSVP Router neighbor is down
#
# Result Reference:
#
# Input:     device, port1, port2
# Output:    HTL.log
#
# Create Dated: Nov 14, 2008
#
#
# Testing Attributes: traffic_config, traffic_stats
#
# Platform Type: Linux, Solaris
#
# Error Codes:   Generated by HLTAPI
#
# Test Type:     Acceptance test, Regression test
#
#####################################################################

# Run sample:
#            c:>tclsh HLTAPI_VPLS_Feature_vlan_traffic.tcl 10.61.44.2 3/1 3/3
#            c:>tclsh HLTAPI_VPLS_Feature_vlan_traffictcl "10.61.44.2 10.61.44.7" 3/1 3/3

package require SpirentHltApi

set devicelist      [lindex $argv 0]
set port1        [lindex $argv 1]
set port2        [lindex $argv 2]
set i 1
foreach device $devicelist {
    set device$i $device
    incr i
}
set device$i $device
set portlist "$port1 $port2"


#######################################################
#Name: TurnOnCapture
#Author: Quinten Pierce
#Purpose: To turn on capture, either Hardware or Cut-Thru for a list of ports
#Input:  Port Handle list, capture type
#Output: fileNameList.  The list of filenames created is returned to the calling procedure/program
#                 Capture is turned on for the ports in the port handle list
#######################################################
proc TurnOnCapture {portHandleList {captureType  "HW"} {fileName "PortNum"}} {
    set captureHndList ""

    foreach portHnd $portHandleList {
        puts "Turn on capture on $portHnd"
        set capture [stc::get $portHnd -children-capture]
        stc::perform CaptureStart -CaptureProxyId $capture
        lappend captureHndList $capture
    }

    return $captureHndList
}   ;# end procedure

#######################################################
#Name: TurnOffCapture
#Author: Quinten Pierce
#Purpose: To turn off capture, and to retrieve the captured frames
#Input:  Port Handle list
#Output: None.  Capture is turned off, and the frames are retrieved
#######################################################
proc TurnOffCapture {portHandleList {fileName CaptureFilePort}} {
    set fileNameList {}
    set count 1;
    foreach portHnd $portHandleList {
        puts "Turn off capture on $portHnd"
        set captureHnd [stc::get $portHnd -children-capture]
        stc::perform CaptureStop -CaptureProxyId $captureHnd
        set name $fileName$count
        puts "Saving capture to $name"
        stc::perform SaveSelectedCaptureData -CaptureProxyId $captureHnd -filename "$name.pcap"
        lappend fileNameList "$name.pcap"
        incr count
    }
    puts "Save file Name list = $fileNameList"
    return $fileNameList
}

####define global variable
set media "fiber"
set speed "ether1000"

#Test script result and command return
set Result 0
set ret ""

#Set equipment information
set hPortlist ""
set passFail PASS
set logValue 0
set capture 0

set DUTIP "10.99.0.191"
set username spirent
set password spirent
set enablePassword spirent

set timeout 15
set runtime 60
set helperFile "HLTAPI_VPLS_helper.tcl"
set vc_id 920
set vpn_id 920
set ceVlanID 920

#Open all HLTAPI logs switches.
::sth::test_config  -logfile hltLogfile \
                    -log 1\
                    -vendorlogfile stcExport\
                    -vendorlog 1\
                    -hltlog 1\
                    -hltlogfile hltExport\
                    -hlt2stcmappingfile hlt2StcMapping \
                    -hlt2stcmapping 1\
                    -log_level 7

#Get port list
set port1 [lindex $portlist 0]
set port2 [lindex $portlist 1]

#Connect to chassis & reserve ports
set ret [sth::connect -device $devicelist \
                                -timeout 30 \
                                -port_list "$port1 $port2" \
                                -username "PVtester"]
set RStatus [keylget ret status]
#Get port handles
if {$RStatus} {
    #Retrieve port handles for later use
	set portIndex 0
	foreach port $portlist {
		set device [lindex $devicelist $portIndex] 
        set hPort($device,$port) [keylget ret port_handle.$device.$port]
		set hPortlist [concat $hPortlist $hPort($device,$port)]
		incr portIndex
    }
} else {
    set passFail FAIL
	puts "Error retrieving the port handles, error message was $ret"
	::sth::cleanup_session -port_list $hPortlist
	return
}
puts "The handles of portlist: $hPortlist"
#CE port
set hPort1 [ lindex $hPortlist 0 ]
#PE port
set hPort2 [ lindex $hPortlist 1 ]

#Set media type as fiber.
set portIndex 0
foreach port $portlist {
	set device [lindex $devicelist $portIndex] 
    set ret [::sth::interface_config   -port_handle       $hPort($device,$port) \
						       -intf_mode         ethernet \
						       -phy_mode          $media \
						       -speed             $speed \
						       -mode              config ]
    set intStatus [keylget ret status]
    if {! $intStatus} {
	   puts "Error configuring port $port with handle $hPort($device,$port)"
	   puts "Error message was $ret"
	   set passFail FAIL
	   ::sth::cleanup_session -port_list $hPortlist
	   return
     } else {
		puts "Port $port has been configured properly"
    }  ;# end if-else statement
	incr portIndex
}

puts "================Create CE on port: $port1 Custom Port==========================\n"
set ret [sth::emulation_vpls_site_config -port_handle $hPort1 \
                                       -site_count 1 \
                                       -vc_type 4 \
                                       -vpn_id $vpn_id \
                                       -vpn_id_step 1\
                                       -vc_id $vc_id \
                                       -vc_id_step 1\
                                       -vlan $ceVlanID \
									   -attached_dut_ip_addr 1.1.1.4 \
				                       -attached_dut_ip_prefix 32 \
                                       -mac_addr 00:00:11:00:00:01 \
                                       -mac_addr_step 00:00:00:00:00:01 \
                                       -mac_count 1 ]
set ceReturn [keylget ret status]
if {$ceReturn} {
    puts "PASS => VPLS CE has been configured on $hPort1 properly. \n"
    set ceHandle1 [keylget ret handle]
    puts "The handle of VPLS CE on $hPort1 is $ceHandle1. \n"
} else {
    puts "FAIL => VPLS CE configuration on $hPort1 FAILED. \n"
    puts "$ret\n"
    set passFail FAIL
    ::sth::cleanup_session -port_list $hPortlist
	return
}

########################
####  Code to configure OSPFv2 router/route and direct LDP router/LSP for setting up IGP/top lable distribute protocol.check point.
########################

########################
####  Code to configure OSPFv2
########################
#Create OSPF router.
puts "================Create OSPFv2 router on port $hPort2,IGP,Provider port=================\n"
sth::emulation_ospf_config -mode create \
    								  -session_type ospfv2 \
    								  -port_handle $hPort2 \
    								  -area_id 0.0.0.0 \
    								  -area_type external_capable \
    								  -count 1 \
    								  -hello_interval 10 \
    								  -dead_interval 40 \
    								  -intf_ip_addr 9.3.0.2 \
    								  -intf_ip_addr_step 0.0.0.1 \
    								  -intf_prefix_length 24 \
    								  -router_id 9.3.0.2 \
    								  -router_id_step 0.0.0.1 \
								  -network_type broadcast \
    								  -gateway_ip_addr 9.3.0.1
set ospfRouterHnd [keylget ret handle]

puts "Configuring OSPFv2 LSA router... \n"
#---Router LSA setup
sth::emulation_ospf_lsa_config -mode create \
    									  -type router \
    									  -adv_router_id 9.3.0.2 \
    									  -handle $ospfRouterHnd \
    									  -link_state_id 9.3.0.2 \
    									  -ls_age 0 \
    									  -ls_seq 80000001 \
    									  -router_abr 1 \
    									  -router_asbr 1 \
    									  -router_link_data 255.255.255.255 \
    									  -router_link_id 111.111.111.111 \
    									  -router_link_idx 2 \
    									  -router_link_metric 1 \
    									  -router_link_mode create \
    									  -router_link_type stub \
    									  -router_virtual_link_endpt  1

########################
####  Code to configure LDP
########################
puts "================Create LDP router on port $hPort2,Direct Type,Provider port=================\n"
sth::emulation_ldp_config	-mode                           create \
					-port_handle 			$hPort2 \
					-peer_discovery 		link \
					-label_adv 			unsolicited \
					-count				1 \
					-intf_ip_addr 			9.3.0.2 \
					-intf_ip_addr_step		0.0.0.1 \
					-intf_prefix_length		24 \
					-gateway_ip_addr		9.3.0.1 \
					-gateway_ip_addr_step	        0.0.0.0 \
					-remote_ip_addr 		9.3.0.1 \
					-remote_ip_addr_step	        0.0.0.0 \
					-lsr_id 			9.3.0.2 \
					-lsr_id_step			0.0.0.1
#Get the LDP handles for the first port
set LDPHnd [keylget ret handle]

 #Create LSP for each LDP router on port1
sth::emulation_ldp_route_config	-mode 			create \
                                        -fec_type 		ipv4_prefix \
                                        -handle 		$LDPHnd \
					-fec_ip_prefix_start 	111.111.111.111 \
                                        -fec_ip_prefix_length 	32 \
                                        -num_lsps 		1 \
					-label_msg_type 	mapping
########################
####  Code to configure a target type LDP router and a CE host behind the LDP router.check point.
########################

puts "================Create PE on port: $port2 Provider Port,Target type,Provider port==========================\n"
set ret [ sth::emulation_l2vpn_pe_config -port_handle $hPort2 \
                               -pe_remote_ip_addr 1.1.1.4 \
                               -pe_ip_addr_start 111.111.111.111 \
                               -pe_ip_addr_step 0.0.0.1 \
                               -pe_ip_addr_count 1 \
                               -pe_gateway_ip_addr 9.3.0.1 \
                               -pe_gateway_ip_addr_step 0.0.0.1 \
                               -pe_ip_addr_prefix_length 24 ]
set peReturn [keylget ret status]
if {$peReturn} {
    puts "PASS => VPLS PE has been configured on $hPort2 properly. \n"
    set peHandle1 [keylget ret handle]
    puts "The handle of VPLS PE on $hPort2 is $peHandle1. \n"
} else {
    puts "FAIL => VPLS PE configuration on $hPort2 FAILED. \n"
    puts "$ret\n"
    set passFail FAIL
    ::sth::cleanup_session -port_list $hPortlist
	return
}

puts "================Create VPN site on port $hPort2, Behind PE $peHandle1,Provider port=================\n"
set ret [sth::emulation_vpls_site_config -port_handle $hPort2 \
                                       -pe_handle $peHandle1 \
                                       -site_count 1 \
                                       -vc_type 5 \
                                       -vpn_id $vpn_id \
                                       -vpn_id_step 1\
                                       -vc_id $vc_id \
                                       -vc_id_step 1\
                                       -mac_addr 00:00:12:00:00:01 \
                                       -mac_addr_step 00:00:00:00:00:01 \
                                       -mac_count 1 ]
set ceReturn [keylget ret status]
if {$ceReturn} {
    puts "PASS => VPLS CE has been configured on $hPort2 properly. \n"
    set ceHandle2 [keylget ret handle]
    puts "The handle of VPLS CE on $hPort2 is $ceHandle2. \n"
} else {
    puts "FAIL => VPLS CE configuration on $hPort2 FAILED. \n"
    puts "$ret\n"
    set passFail FAIL
    ::sth::cleanup_session -port_list $hPortlist
	return
}

puts "================ Create VPLS Traffic between two CEs =========================\n"
set ret [sth::traffic_config   \
                             -mode  create \
                             -transmit_mode         "continuous" \
                             -port_handle           $hPort1 \
                             -rate_pps              100 \
                             -port_handle2          $hPort2 \
                             -bidirectional 1 \
                             -vpls_source_handle $ceHandle1 \
                             -vpls_destination_handle $ceHandle2 ]
set trafficReturn [keylget ret status]
if {$trafficReturn} {
    puts "PASS => The traffic between CEs has been configured properly. \n"
    set streamblock1 [keylget ret stream_id]
  } else {
    puts "FAIL => The traffic between CEs has been configured incorrectly. \n"
    puts "$ret\n"
    set passFail FAIL
    ::sth::cleanup_session -port_list $hPortlist
	return
}

#config parts are finished

########################
####  Code to save a STC configuration for dedugging.
########################
puts "================Sleep 10 seconds==========================\n"
after 10000
#stc::perform SaveToTcc -filename HLTAPI_VPLS_Feature_vlan_traffic.tcc

########################
####  Code to start OSPFv2 / LDP routers
########################
puts "================Start OSPFv2 router on port $hPort2,IGP,Provider port=================\n"
puts "Start OSPFv2 routers..."
set ret [ sth::emulation_ospf_control -mode start -handle $ospfRouterHnd ]
set startOSPFv2 [keylget ret status]
if {$startOSPFv2} {
    puts "PASS => OSPFv2 has been started on $hPort2 properly. \n"
  } else {
    puts "FAIL => OSPFv2 has been started on $hPort2 incorrectly. \n"
    puts "$ret\n"
    set passFail FAIL
    ::sth::cleanup_session -port_list $hPortlist
	return
}
puts "================Sleep 30 seconds==========================\n"
after 30000

puts "================Start LDP router on port $hPort2,Provider port=================\n"
puts "Start LDP routers..."
set ret [sth::emulation_ldp_control -mode start -handle $LDPHnd ]
set startLDP [keylget ret status]
if {$startLDP} {
    puts "PASS => The LDP routers has been started on $hPort2 properly. \n"
  } else {
    puts "FAIL => The LDP routers has been started on $hPort2 incorrectly. \n"
    puts "$ret\n"
    set passFail FAIL
    ::sth::cleanup_session -port_list $hPortlist
	return
}

puts "================Sleep 30 seconds==========================\n"
after 30000

########################
####  Code to check PE LDP router state
########################
puts "=====================Check the direct LDP PE router state========================\n"
set ldpRouterHnd [stc::get $LDPHnd -children-ldprouterconfig]
set directLDPStatus [stc::get $ldpRouterHnd -RouterState]
if {$directLDPStatus == "LDP_SESSION_STATE_UP"} {
    puts "PASS => The direct LDP PE router state is up on $ldpRouterHnd. \n"
  } else {
    puts "FAIL => The direct LDP PE router state is not up on $ldpRouterHnd. \n"
    puts $directLDPStatus
    set passFail FAIL
    ::sth::cleanup_session -port_list $hPortlist
	return
}

puts "=====================Check the target LDP PE router state========================\n"
set targetLDPStatus [stc::get $peHandle1 -RouterState]
if {$targetLDPStatus == "LDP_SESSION_STATE_UP"} {
    puts "PASS => The target LDP PE router state is up on $peHandle1. \n"
  } else {
    puts "FAIL => The target LDP PE router state is not up on $peHandle1. \n"
    puts $targetLDPStatus
    set passFail FAIL
    ::sth::cleanup_session -port_list $hPortlist
	return
}

#########################
#####  Code to check the DUT's status for the initial BGP routers and routes
#########################
#EX_TelnetOpen $DUTIP $username $password -timeout 15 -passwordPrompt "Password:" -prompt ">"
#EX_TelnetSendCommand "en" -prompt "Password:"
#EX_TelnetSendCommand $enablePassword -prompt "#"
#
#set ret [EX_TelnetSendCommand "show mpls ldp nei 111.111.111.111"]
#
#puts "***************** The result of show mpls ldp nei on $DUTIP ******************\n"
#puts $ret
#
#if {[string first "State: Oper" $ret] != -1} {
#	puts "\nPASS => VPLS MPLS LDP Neighbor is up on $DUTIP. \n"
#} else {
#	puts "\nFAIL => VPLS MPLS LDP Neighbor is not up on $DUTIP. \n"
#	set passFail FAIL
#	::sth::cleanup_session -port_list $hPortlist
#}   ;# end if-else statement

########################
####  Code to capture traffic streams
########################
puts "=====================Start traffic 5 seconds========================\n"
if {$capture == 1} {
	TurnOnCapture $hPortlist
}   ;# end if statement for turning on capture

sth::traffic_control -action run -port_handle "all"
stc::sleep 5
sth::traffic_control -action stop -port_handle "all"

if {$capture == 1} {
	TurnOffCapture $hPortlist
}   ;# end if statement for turning on capture

########################
####  Code to check Sig Tx count and Sig Rx count between Rx port and Tx port (between two CEs)
########################
puts "====Check Sig Tx count and Sig Rx count between Rx port and Tx port (between two CEs)====\n"
foreach portHnd $hPortlist {
    puts "Retrieving results from $portHnd \n"
    set ret [sth::interface_stats -port_handle $portHnd]
    set statReturn [keylget ret status]
    if {$statReturn} {
	    set tx_sigcount($portHnd) [keylget ret tx_generator_sig_frame_count]
	    set rx_sigcount($portHnd) [keylget ret rx_sig_count]
	    puts "Port $portHnd Statistics:  Tx Frames sig_frame_count - $tx_sigcount($portHnd)\n"
	    puts "Port $portHnd Statistics:  Rx Frames sig_frame_count - $rx_sigcount($portHnd)\n"
    } else {
	set passFail FAIL
	puts "FAIL - Retrieving Tx and Rx Frames sig_frame_count from $portHnd."
	return
    }
}

if { $rx_sigcount($hPort2) <= $tx_sigcount($hPort1) && \
    $tx_sigcount($hPort1)*0.8 <= $rx_sigcount($hPort2) } {
    puts "PASS - The result of traffic from $hPort1 to $hPort2 is correct.\n"
} else {
    set passFail FAIL
    puts "FAIL - The result of traffic from $hPort1 to $hPort2 is incorrect.\n"
	return
}

if { $rx_sigcount($hPort1) <= $tx_sigcount($hPort2) && \
    $tx_sigcount($hPort2)*0.8 <= $rx_sigcount($hPort1) } {
    puts "PASS - The result of traffic from $hPort2 to $hPort1 is correct.\n"
} else {
    set passFail FAIL
    puts "FAIL - The result of traffic from $hPort2 to $hPort1 is incorrect.\n"
	return
}

puts "Verdict: $passFail\n"
puts "================Test completed==========================\n"
puts "_SAMPLE_SCRIPT_SUCCESS"


