# toolMain.tcl --
#
# UI generated by GUI Builder Build 146 on 2013-12-24 15:43:34 from:
#    D:/Perforce/xTapiwork/TestCenter/p2_dev_HltApi/mainline/content/HltAPI/ReleasePackage/SourceCode/tools/toolMain.ui
# This file is auto-generated.  Only the code within
#    '# BEGIN USER CODE'
#    '# END USER CODE'
# and code inside the callback subroutines will be round-tripped.
# The proc names 'ui' and 'init' are reserved.
#

package require Tk 8.4

# Declare the namespace for this dialog
namespace eval toolMain {}

# Source the ui file, which must exist
set toolMain::SCRIPTDIR [file dirname [info script]]
source [file join $toolMain::SCRIPTDIR toolMain_ui.tcl]

# BEGIN USER CODE
#variable
variable TITLE
variable input_params
variable v_script_file_name
variable v_script_file_path

set TITLE "Save as HLTAPI"
set ::text   ._text_1

set input_params  ""
if {[info exist argv]} {
	set input_params $argv
}

if {$input_params eq ""} {
	set input_params $toolMain::SCRIPTDIR
}

set input_params [regsub -all {\\} $input_params "/"]
set input_params [regsub -all {\?} $input_params " "]
set input_params [regsub -all {\{|\}} $input_params ""]

proc center_the_toplevel { w } {
    # Callback on the <Configure> event for a toplevel
    # that should be centered on the screen

    # Make sure that we aren't configuring a child window

    if { [string equal $w [winfo toplevel $w]] } {

        # Calculate the desired geometry
        set width [winfo reqwidth $w]
        set height [winfo reqheight $w]
        set x [expr { ( [winfo vrootwidth  $w] - $width  ) / 2 }]
        set y [expr { ( [winfo vrootheight $w] - $height ) / 2 }]

        # Hand the geometry off to the window manager
        wm geometry $w ${width}x${height}+${x}+${y}
    }
}


proc FindPath {} {
   variable v_script_file_name
   variable v_script_file_path

   set v_script_file_path [file dirname [info script]]
   append v_script_file_path "/.property"

   if {[info exists v_script_file_path]} {
      set mydir $v_script_file_path
   } else {
      set mydir ""
      file mkdir $v_script_file_path
   }
   switch -regexp $::hlapiType {
      "tcl" {
	 set fileTyp tcl
	 set file_types {
         {"Tcl Files" { .tcl .TCL .tk .TK} }
         {"All Files" * }
	 }
      }
      "perl" {
		 set fileTyp pl
         set file_types {
         {"Perl Files" { .pl} }
         {"All Files" * }
	 }
      }
	  "jt_perl" {
		 set fileTyp pl
         set file_types {
         {"Perl Files" { .pl} }
         {"All Files" * }
	 }
      }
      "python" {
		set fileTyp py
         set file_types {
         {"Python Files" { .py} }
         {"All Files" * }
	 }
      }
      "robot" {
		set fileTyp robot
         set file_types {
         {"Robot Files" { .robot} }
         {"All Files" * }
	 }
      }
      default {
		if {[regexp -nocase $::hlapiType $::sth::hlapiGen::v_plugins match]} {
			set mysuffix [::sth::hlapiGen::getInfo_$match suffix]
			set fileTyp [string trim $mysuffix "."]
			set file_types {
				{"Testcase Files" { mysuffix} }
				{"All Files" * }
			}
			
			regsub "mysuffix" $file_types $mysuffix file_types
		}
      }
   }

   set file [tk_getSaveFile -title "Save as HLTAPI script" -filetypes $file_types\
			-initialdir $mydir -defaultextension .$fileTyp]
   if { $file == "" } {
        return; # they clicked cancel
   }
   catch {
	   set filechannel [open $v_script_file_path w]
	   puts $filechannel [file dirname $file]
	   close $filechannel }

   set v_script_file_name $file
   .filetext delete 0.0 end
   .filetext insert end $v_script_file_name
   focus .runBut
   update
}

proc Open {myfile} {
      variable TITLE
	  if {[file exist "$myfile"]} {
          set answer [tk_messageBox -type yesno -icon question -title $TITLE \
    				-message "Do you want to open the script in the text editor?"]
          switch -- $answer {
    		yes {if {[catch {
    				exec notepad.exe "$myfile" &
    			} results]} {
    				tk_messageBox -type ok -icon error -title $TITLE -message \
    				   "Error occurred during opening $myfile:\n${result}"
    			}}
          }
	  }
}

proc Generate {} {
	variable v_script_file_name
	variable input_params
    global env

	set TITLE "Save as HLTAPI"
	set retfile ""
    set v_script_file_name [.filetext get 1.0 {end -1c}]
	if {$v_script_file_name == ""} {
		if {[info exist ::sth::hlapiGen::v_plugins] && [regexp -nocase $::hlapiType $::sth::hlapiGen::v_plugins match]} {
			set title [::sth::hlapiGen::getInfo_$match title]
			set emptymsg [::sth::hlapiGen::getInfo_$match emptymsg]
			tk_messageBox -type ok -icon error -title $title -message $emptymsg		
		} else {			
			tk_messageBox -type ok -icon error -title $TITLE -message \
				"HLTAPI script name cannot be empty"
		}
	} else {
        ._text_1 configure -state normal
        ._text_1 delete 0.0 end

        ._text_1 insert end "Custom tool working path is: $input_params\n"
        set dirname ""
        if {[info exists env(DEFAULTYAML_DIR)]} {
            if {[file exists $env(DEFAULTYAML_DIR)]} {
                set dirname $env(DEFAULTYAML_DIR)
                set dirname [regsub -all {\\} $dirname "/"]
            }
        }
        ._text_1 insert end "Default yaml files folder is: $dirname\n"
		._text_1 insert end "\nLoading package..."
		update
		package require SpirentHltApi

		set ::sth::hlapiGen::test_config $::checklogBut
		set ::sth::hlapiGen::test_control $::checkoptimizeBut
		set ::sth::hlapiGen::pkt_capture $::checkpacketBut
		set ::sth::hlapiGen::test_run $::checkcontrolBut
		set ::sth::hlapiGen::test_result $::checkresultBut
		set ::sth::hlapiGen::device_info $::checkdeviceBut
		set ::sth::hlapiGen::traffic $::checktrafficBut
		set ::sth::hlapiGen::scaling_test $::checkmodeBut
		set ::sth::hlapiGen::default_value $::checkdefaultBut
		set ::sth::hlapiGen::output_type $::hlapiType
        set ::sth::hlapiGen::default_yaml $::checkdefaultyamlBut

		set retfile [::sth::hlapiGen::do_hlapi_gen $v_script_file_name]	

		if {$retfile ne "" && [file exist "$retfile"]} {
			if {[info exist ::sth::hlapiGen::v_plugins] && [regexp -nocase $::hlapiType $::sth::hlapiGen::v_plugins match]} {
				set endmsg [::sth::hlapiGen::getInfo_$match endmsg]
				._text_1 insert end $endmsg
			} else {
				._text_1 insert end "\n\nFinished: Script Saved Successfully."
			}
		} else {
			._text_1 insert end "\n\nFinished"
		}
	}
	update
	._text_1 configure -state disabled
	if {$retfile ne ""} {
		Open $retfile
	}

	focus .filetext
}
proc toolMain::processBind {arg} {

      focus -force .filetext
      bind .filetext <Tab> { focus .fileBut; break }
      bind .filetext <Return> { Generate;  break }

      bind .fileBut <Return> { FindPath; break }
      bind .fileBut <Tab> { focus .hltapiBut;  break }
      bind .fileBut <Shift-Tab> { focus .filetext;  break }

      bind .hltapiBut <Tab> { focus .modeBut;  break }
      bind .hltapiBut <Shift-Tab> { focus .fileBut;  break }
      bind .hltapiBut <Left> { focus .hlrapiBut;  set ::hlapiType robot;  break }
	  bind .hltapiBut <Right> { focus .hlpapiBut;  set ::hlapiType perl;  break }
	  
	  bind .hlpapiBut <Left> { focus .hltapiBut;  set ::hlapiType tcl;  break }
      bind .hlpapiBut <Right> { focus .hlpyapiBut;  set ::hlapiType python;  break }
	  bind .hlpapiBut <Tab> { focus .modeBut;  break }

      bind .hlpyapiBut <Left> { focus .hlpapiBut;  set ::hlapiType perl;  break }
      bind .hlpyapiBut <Right> { focus .hlrapiBut;  set ::hlapiType robot; break }
	  bind .hlpyapiBut <Tab> { focus .modeBut;  break }
      
      bind .hlrapiBut <Left> { focus .hlpyapiBut;  set ::hlapiType python;  break }
      bind .hlrapiBut <Right> { focus .hltapiBut;  set ::hlapiType tcl; break }
	  bind .hlrapiBut <Tab> { focus .modeBut;  break }
	
	if {[info exist ::sth::hlapiGen::v_plugins]} {
		set i 0
		foreach one $::sth::hlapiGen::v_plugins {
			set ::lone [string tolower $one]
			bind .$::lone\But <Tab> { focus .modeBut;  break }
			if {$i==0} {
                bind .$::lone\But <Left> { focus .hlrapiBut;  set ::hlapiType robot; break }
				bind .$::lone\But <Right> { focus .hltapiBut;  set ::hlapiType tcl; break }
				bind .hlrapiBut <Right> { focus .$::lone\But;  set ::hlapiType $::lone; break }
			} 
			incr i
		}
		if {$i != 0} {
			bind .hltapiBut <Left> { focus .$::lone\But;  set ::hlapiType $::lone;  break }
		}
	}
	
      bind .modeBut <Tab> { focus .logBut;  break }
      bind .modeBut <Return> {
      if {!$::checkmodeBut} {
        set ::checkmodeBut 1; break
        } else {
        set ::checkmodeBut 0; break
        }
      }

      bind .logBut <Tab> { focus .runBut;  break }
      bind .runBut <Tab> { focus .filetext;  break }

      bind .modeBut <Shift-Tab> { focus .hltapiBut;  break }
      bind .logBut <Shift-Tab> { focus .modeBut;  break }
      bind .runBut <Shift-Tab> { focus .logBut;  break }

      bind .runBut <Return> { Generate ; break }

      bind .logBut <Down> { focus .optimizeBut; break }
      bind .logBut <Right> { focus .controlBut; break }
      bind .logBut <Return> {
        if {$::checklogBut == 0} {
        set ::checklogBut 1; break
        } else {
        set ::checklogBut 0; break
        }
      }

      bind .optimizeBut <Up> { focus .logBut; break }
      bind .optimizeBut <Down> { focus .packetBut; break }
      bind .optimizeBut <Right> { focus .resultBut; break }
	  bind .optimizeBut <Tab> { focus .runBut;  break }
      bind .optimizeBut <Return> {
      if {!$::checkoptimizeBut} {
        set ::checkoptimizeBut 1; break
        } else {
        set ::checkoptimizeBut 0; break
        }
      }

      bind .packetBut <Up> { focus .optimizeBut; break }
	  bind .packetBut <Tab> { focus .runBut;  break }
	  bind .packetBut <Right> { focus .defaultBut; break }
      bind .packetBut <Return> {
       if {!$::checkpacketBut} {
        set ::checkpacketBut 1; break
        } else {
        set ::checkpacketBut 0; break
        }
      }

      bind .controlBut <Down> { focus .resultBut; break }
      bind .controlBut <Left> { focus .logBut; break }
      bind .controlBut <Right> { focus .deviceBut; break }
	  bind .controlBut <Tab> { focus .runBut;  break }
      bind .controlBut <Return> {
       if {!$::checkcontrolBut} {
        set ::checkcontrolBut 1; break
        } else {
        set ::checkcontrolBut 0; break
        }
      }

      bind .resultBut <Up> { focus .controlBut; break }
      bind .resultBut <Down> { focus .defaultBut; break }
      bind .resultBut <Left> { focus .optimizeBut; break }
      bind .resultBut <Right> { focus .trafficBut; break }
	  bind .resultBut <Tab> { focus .runBut;  break }
      bind .resultBut <Return> {
      if {!$::checkresultBut} {
        set ::checkresultBut 1; break
        } else {
        set ::checkresultBut 0; break
        }
      }

      bind .deviceBut <Down> { focus .trafficBut; break }
      bind .deviceBut <Left> { focus .controlBut; break }
	  bind .deviceBut <Tab> { focus .runBut;  break }
      bind .deviceBut <Return> {
       if {!$::checkdeviceBut} {
        set ::checkdeviceBut 1; break
        } else {
        set ::checkdeviceBut 0; break
        }
      }

      bind .trafficBut <Up> { focus .deviceBut; break }
      bind .trafficBut <Left> { focus .resultBut; break }
	  bind .trafficBut <Tab> { focus .runBut;  break }
      bind .trafficBut <Return> {
       if {!$::checktrafficBut} {
        set ::checktrafficBut 1; break
        } else {
        set ::checktrafficBut 0; break
        }
      }
	  bind .defaultBut <Up> { focus .resultBut; break }
      bind .defaultBut <Left> { focus .packetBut; break }
      bind .defaultBut <Right> { focus .defaultyamlBut; break }
	  bind .defaultBut <Tab> { focus .runBut;  break }
      bind .defaultBut <Return> {
       if {!$::checkdefaultBut} {
        set ::checkdefaultBut 1; break
        } else {
        set ::checkdefaultBut 0; break
        }
      }

	  bind .defaultyamlBut <Up> { focus .trafficBut; break }
      bind .defaultyamlBut <Left> { focus .defaultBut; break }
	  bind .defaultyamlBut <Tab> { focus .runBut;  break }
      bind .defaultyamlBut <Return> {
       if {!$::checkdefaultyamlBut} {
        set ::checkdefaultyamlBut 1; break
        } else {
        set ::checkdefaultyamlBut 0; break
        }
      }
	  
      bind . <Destroy>  {
              destroy .;
          set finish 1}
      bind . <Tab> {tk_focusNext %W}
	  focus -force .filetext
}
# END USER CODE

# BEGIN CALLBACK CODE
# ONLY EDIT CODE INSIDE THE PROCS.

# toolMain::_text_1_xscrollcommand --
#
# Callback to handle _text_1 widget option -xscrollcommand
#
# ARGS:
#    <NONE>
#
proc toolMain::_text_1_xscrollcommand args {}

# toolMain::_text_1_yscrollcommand --
#
# Callback to handle _text_1 widget option -yscrollcommand
#
# ARGS:
#    <NONE>
#
proc toolMain::_text_1_yscrollcommand args {}

# toolMain::controlBut_command --
#
# Callback to handle controlBut widget option -command
#
# ARGS:
#    <NONE>
#
proc toolMain::controlBut_command args {}

# toolMain::deviceBut_command --
#
# Callback to handle deviceBut widget option -command
#
# ARGS:
#    <NONE>
#
proc toolMain::deviceBut_command args {}

# toolMain::filetext_xscrollcommand --
#
# Callback to handle filetext widget option -xscrollcommand
#
# ARGS:
#    <NONE>
#
proc toolMain::filetext_xscrollcommand args {}

# toolMain::filetext_yscrollcommand --
#
# Callback to handle filetext widget option -yscrollcommand
#
# ARGS:
#    <NONE>
#
proc toolMain::filetext_yscrollcommand args {}

# toolMain::hlpapiBut_command --
#
# Callback to handle hlpapiBut widget option -command
#
# ARGS:
#    <NONE>
#
proc toolMain::hlpapiBut_command args {}

# toolMain::hlpyapiBut_command --
#
# Callback to handle hlpyapiBut widget option -command
#
# ARGS:
#    <NONE>
#
proc toolMain::hlpyapiBut_command args {}

# toolMain::hlrapiBut_command --
#
# Callback to handle hlrapiBut widget option -command
#
# ARGS:
#    <NONE>
#
proc toolMain::hlrapiBut_command args {}

# toolMain::hltapiBut_command --
#
# Callback to handle hltapiBut widget option -command
#
# ARGS:
#    <NONE>
#
proc toolMain::hltapiBut_command args {}

# toolMain::logBut_command --
#
# Callback to handle logBut widget option -command
#
# ARGS:
#    <NONE>
#
proc toolMain::logBut_command args {}

# toolMain::modeBut_command --
#
# Callback to handle modeBut widget option -command
#
# ARGS:
#    <NONE>
#
proc toolMain::modeBut_command args {}

# toolMain::optimizeBut_command --
#
# Callback to handle optimizeBut widget option -command
#
# ARGS:
#    <NONE>
#
proc toolMain::optimizeBut_command args {}

# toolMain::packetBut_command --
#
# Callback to handle packetBut widget option -command
#
# ARGS:
#    <NONE>
#
proc toolMain::packetBut_command args {}

# toolMain::resultBut_command --
#
# Callback to handle resultBut widget option -command
#
# ARGS:
#    <NONE>
#
proc toolMain::resultBut_command args {}

# toolMain::trafficBut_command --
#
# Callback to handle trafficBut widget option -command
#
# ARGS:
#    <NONE>
#
proc toolMain::trafficBut_command args {}

proc toolMain::defaultBut_command args {}

proc toolMain::defaultyamlBut_command args {}

# END CALLBACK CODE

# toolMain::init --
#
#   Call the optional userinit and initialize the dialog.
#   DO NOT EDIT THIS PROCEDURE.
#
# Arguments:
#   root   the root window to load this dialog into
#
# Results:
#   dialog will be created, or a background error will be thrown
#
proc toolMain::init {root mydir} {
    variable TITLE
	
    #set the default value
    set ::hlapiType tcl
    set ::checkmodeBut 0
    set ::checklogBut 1
    set ::checkcontrolBut 1
    set ::checkdeviceBut 0
    set ::checkoptimizeBut 1
    set ::checkresultBut 1
    set ::checktrafficBut 1
	set ::checkdefaultBut 1
    set ::checkpacketBut 0
    set ::checkdefaultyamlBut 0
    
    # Catch this in case the user didn't define it
    catch {toolMain::userinit}

    wm title . "Save as HLTAPI Wizard"

    set imageDir [file dirname [info script]]
    append imageDir "/icon.ico"
    set img [image create bitmap $imageDir]
    wm iconbitmap $root $img

	# we are running in the ui
	toolMain::ui $root $mydir

	catch {toolMain::processBind $root}
    catch {toolMain::run $root}
}

toolMain::init . $input_params
._text_1 configure -state normal
._text_1 insert end "Custom tool working path is: $input_params\n"
set dirname ""
if {[info exists env(DEFAULTYAML_DIR)]} {
    if {[file exists $env(DEFAULTYAML_DIR)]} {
        set dirname $env(DEFAULTYAML_DIR)
        set dirname [regsub -all {\\} $dirname "/"]
    }
}
._text_1 insert end "Default yaml files folder is: $dirname\n"
._text_1 configure -state disable

update
center_the_toplevel .
wm deiconify .
focus -force .filetext

vwait finish
