# Copyright (c) 2014 by Spirent Communications, Inc.
# All Rights Reserved
#
# By accessing or executing this software, you agree to be bound
# by the terms of this agreement.
#
# Redistribution and use of this software in source and binary forms,
# with or without modification, are permitted provided that the
# following conditions are met:
#   1.  Redistribution of source code must contain the above copyright
#       notice, this list of conditions, and the following disclaimer.
#   2.  Redistribution in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer
#       in the documentation and/or other materials provided with the
#       distribution.
#   3.  Neither the name Spirent Communications nor the names of its
#       contributors may be used to endorse or promote products derived
#       from this software without specific prior written permission.
#
# This software is provided by the copyright holders and contributors
# [as is] and any express or implied warranties, including, but not
# limited to, the implied warranties of merchantability and fitness for
# a particular purpose are disclaimed.  In no event shall Spirent
# Communications, Inc. or its contributors be liable for any direct,
# indirect, incidental, special, exemplary, or consequential damages
# (including, but not limited to: procurement of substitute goods or
# services; loss of use, data, or profits; or business interruption)
# however caused and on any theory of liability, whether in contract,
# strict liability, or tort (including negligence or otherwise) arising
# in any way out of the use of this software, even if advised of the
# possibility of such damage.
# sth_wrapper_functions.lib
#
# This is a wrapper library for Spirent HLTAPI to work with Cisco's existing scripts
# Created by Spirent professional service
# namespace ::spirent

if {[catch {

# Debug file code.
set ::spirent::enable_debug 1
set ::spirent::enable_lab_server 0
set ::spirent::lab_server_ip_address 10.61.44.190
set ::spirent::src_stream_id  ""
set ::spirent::dst_stream_id  ""
set ::spirent::enable_step_debug 0
set ::spirent::module_type  ""

set ::spirent::traffic_bidirectional  0

#variable used to trace if the stop action is called after start for duration conditon
set ::spirent::call_stop 0

array set ::spirent::stream_pgid {}
array set ::spirent::ip_device {}
array set ::spirent::stream_ipv4_config {}
set ::spirent::StreamArgList "mac_src mac_src_mode mac_src_count mac_src_step ip_src_addr ip_src_count ip_src_mode ip_src_step \
                        ip_dst_addr ip_dst_count ip_dst_step ip_dst_mode tcp_src_port tcp_dst_port tcp_rst_flag vlan_id \
                        vlan_id_mode vlan_id_count vlan_id_step vlan_cfi vlan_tpid mac_dst mac_dst_mode mac_dst_count mac_dst_step \
                        ip_precedence vlan_user_priority l3_length length_mode ip_ttl l2_encap vlan_id_outer_step vlan_outer_user_priority \
                        vlan_id_outer_count vlan_id_outer_mode vlan_outer_tpid vlan_id_outer vlan_outer_cfi"

if { [info exists ::env(EASY_BASEDIR)] } {
    set timestamp [clock format [clock scan now] -format {%Y-%m-%d-%H-%M-%S}]
    set hltname [file join $::env(EASY_BASEDIR) HLT$timestamp]
} else {
    set hltname "HLT_[clock format [clock scan now] -format {%Y-%m-%d-%H-%M-%S}]"
}

##keys mapping table between traffic_stats and drv_stats
array set ::spirent::port_rx_table {
    total_pkt_bytes         RxTotalOctetCount
    fcoe_frame_rate         RxFcoeFrameRate
    udp_pkts                RxUdpFrameCount
    tcp_checksum_errors     RxTcpChecksumErrorCount
    total_pkts              RxTotalFrameCount
    pfc_frame_rate          RxPfcFrameRate
    fcoe_frame_count        RxFcoeFrameCount
    tcp_pkts                RxTcpFrameCount
    pkt_bit_rate            RxL1BitRate
    raw_pkt_count           RxTotalFrameCount
    pkt_rate                RxSigFrameRate
    pfc_frame_count         RxPfcFrameCount
    total_pkt_rate          RxTotalFrameRate
    pkt_count               RxSigFrameCount
}
#pkt_byte_count          NONE
#ip_pkts                 NONE

array set ::spirent::port_tx_table {
    total_pkt_bytes         TxTotalOctetCount
    total_pkts              TxTotalFrameCount
    raw_pkt_count           TxTotalFrameCount
    pkt_bit_rate            TxL1BitRate
    pkt_byte_count          GeneratorOctetCount
    pkt_rate                GeneratorFrameRate
    pfc_frame_count         TxPfcFrameCount
    raw_pkt_rate            TxTotalFrameRate
    total_pkt_rate          TxTotalFrameRate
    pkt_count               GeneratorSigFrameCount
}
#elapsed_time            NONE
#ip_pkts                 NONE

array set ::spirent::stream_rx_table {
    misinserted_pkts        ReorderedFrameCount
    total_pkt_bytes         RxOctetCount
    prbs_bit_errors         PrbsBitErrorCount
    min_delay               MinLatency
    max_delay               MaxLatency
    avg_delay               AvgLatency
    duplicate_pkts          DuplicateFrameCount
    total_pkts              RxFrameCount
    dropped_pkts            DroppedFrameCount
    total_pkt_bit_rate      RxBitRate
    min_pkt_length          MinFrameLength
    total_pkt_rate          RxFrameRate
    max_pkt_length          MaxFrameLength
    rx_port                 ActualRxPortName
    Min                     MinFrameLength
    Max                     MaxFrameLength
}
#ipv4_outer_present      NONE
#ipv6_outer_present      NONE
#out_of_sequence_pkts    NONE
#udp_present             NONE
#ipv4_present            NONE
#ipv6_present            NONE
#tcp_present             NONE
#first_tstamp            FirstArrivalTime
#last_tstamp             LastArrivalTime

array set ::spirent::stream_tx_table {
    total_pkt_bytes         TxOctetCount
    total_pkt_rate          TxFrameRate
    total_pkts              TxFrameCount
    total_pkt_bit_rate      TxBitRate
}
#elapsed_time            NONE
#ipv4_outer_present      NONE
#udp_present             NONE
#ipv6_present            NONE
#ipv6_outer_present      NONE
#tcp_present             NONE
#ipv4_present            NONE


proc ::spirent::debug {szString} {
    variable debugfilename
    if {[info exists debugfilename]} {
        set hDebug [open $debugfilename a]
        puts $hDebug $szString
        close $hDebug
    }
}

# Pass in the argument list and an array variable name - this is used as a reference value
#    since an array variable cannot be returned.
proc ::spirent::listToArray {args aResultsName} {
  upvar $aResultsName aName
  array unset aName *
  set keys [regexp -nocase -all -line -inline -- {^-[^\s]*| -[^\s]*} [join $args]]
  set index 1
  foreach key $keys {
    set value ""
    set tmpkey [lindex $keys $index]
    if {$tmpkey == ""} {
        regexp -- "$key (.*)" [join $args] _ value
    } else {
        regexp -- "$key (.*?)$tmpkey" [join $args] _ value
    }
    regsub -all {[\{\}]} $value {} value
    set aName([string trim $key]) [string trim $value]
    incr index
  }
}



proc ::spirent::init { args } {
    # The init routine loads the appropriate version of Spirent TestCenter API, as well as HLTAPI.
    # By default, the latest of both will be loaded, by you can specify both versions if you like.
    #
    # Args (all optional):
    #   -chassisip      : The chassis IP to connect to and determine the correct version of software to load.
    #   -stcapiversion  : Load this specific version of the Spirent TestCenter API.
    #   -hltapiversion  : Load this specific version of HLTAPI.
    #   -port           : the first port need be reserved, Aims to get test module version info.

    if { ! [info exists ::env(STC_LOG_OUTPUT_DIRECTORY)] } {
        if { [info exists ::env(STC_LOG_PATH)] } {
            # Relocate the BLL log file to the specified directory.
            set ::env(STC_LOG_OUTPUT_DIRECTORY) $::env(STC_LOG_PATH)
        } elseif { [info exists ::env(EASY_BASEDIR)] } {
            # Relocate the BLL log file to the log/report directory for ATS.
            set ::env(STC_LOG_OUTPUT_DIRECTORY) $::env(EASY_BASEDIR)
        }
    }

    set notloaded [catch {
        package present SpirentTestCenter
        package present SpirentHltApi
    }]


    set errorhasoccurred [catch {

        if { $notloaded } {

            if { [catch {array set argArray $args} errmsg] } {
                error $errmsg
            }

        # This code is required to for Tcl to learn about all available packages.
        # Without this, the "package versions" command won't work.
        eval [package unknown] Tcl [package provide Tcl]

        # First determine the version of Spirent TestCenter to load.
        if { [info exists argArray(-chassisip)] } {
            #get exactly test module version
            set location $argArray(-chassisip)
            if {0} {
                set Module [lindex [split $argArray(-port) /] 0]
                ::sth::sthCore::invoke stc::connect $argArray(-chassisip)
                set physicalChassis [lindex [::sth::sthCore::invoke stc::get system1.physicalchassismanager -children-physicalchassis] 0]
                set physicaltestmoduleList [::sth::sthCore::invoke stc::get $physicalChassis -children-physicaltestmodule]
                set TestModuleFlag 0
                foreach physicaltestmodule $physicaltestmoduleList {
                    if {[::sth::sthCore::invoke stc::get $physicaltestmodule -Index] == $Module} {
                        set TestModuleFlag 1
                        break
                    }
                }
                if {$TestModuleFlag} {
                    set version [::sth::sthCore::invoke stc::get $physicaltestmodule -FirmwareVersion]
                } else {
                    set version [::sth::sthCore::invoke stc::get $physicalChassis -FirmwareVersion]
                }

                set location "$argArray(-chassisip)/$Module"
            } else {
                # MGJ Fix.
                set path [file dirname [::info script]]
                set filename [file join $::spirent::_WRAPPER_DIR "stc_get_version.tcl"]

                # Be sure to set the TCLLIBPATH so that the "stc_get_version.tcl" script can file at least
                # one version of Spirent TestCenter to use.
                set ::env(TCLLIBPATH) $::auto_path

                if { [info exists argArray(-port)] } {
                    set version [exec tclsh $filename $argArray(-chassisip) $argArray(-port)]
                    set location "$argArray(-chassisip)/$argArray(-port)"
                } else {
                    set version [exec tclsh $filename $argArray(-chassisip)]
                }
            }

            set msg "The Spirent TestCenter at $location is running version $version"
            puts "$msg"
            set major [lindex [split $version .] 0]
            set minor [lindex [split $version .] 1]
            set build [lindex [split $version .] 2]

            set stcapiversion $major.$minor

        } elseif { [info exists argArray(-stcapiversion)] } {
            # Just use the specified version.
            set stcapiversion $argArray(-stcapiversion)
        } else {
            set stcapiversion ""
        }

        set validstcversion ""
        if { [info exists ::spirent::supportedversions(stc)] } {
            set validstcversion $::spirent::supportedversions(stc)
        }

        loadLatestValidPackage SpirentTestCenter $validstcversion $stcapiversion

        # Load HLTAPI.
        if { [info exists argArray(-hltapiversion)] } {
            set hltapiversion $argArray(-hltapiversion)
        } else {
            set hltapiversion ""
        }

        set validhltapiversion ""
        if { [info exists ::spirent::supportedversions(hltapi)] } {
            set validhltapiversion $::spirent::supportedversions(hltapi)
        }

        loadLatestValidPackage SpirentHltApi $validhltapiversion $hltapiversion

        # Return the versions that are in use.
        keylset result hltapiwrapperversion [package present SpirentHltApiWrapper]
        keylset result hltapiversion        [package present SpirentHltApi]
        keylset result stcapiversion        [package present SpirentTestCenter]

        # Use the Lab Server if one has been defined.
        if { [info exists ::env(STC_LAB_SERVER_ADDRESS)] } {

            if { [info exists ::env(STC_LAB_SERVER_USER)] } {
                set username $::env(STC_LAB_SERVER_USER)
            } else {
                set username $::tcl_platform(user)
            }

            if { [info exists ::env(STC_LAB_SERVER_SESSIONAME)] } {
                set sessionname $::env(STC_LAB_SERVER_SESSIONAME)
            } else {
                # Derive the session name from the job.
                set sessionname ""
                if { [info exists ::env(EASY_BASEDIR)] } {
                    set sessionname $::env(EASY_BASEDIR)
                    set sessionname [file tail $sessionname]
                    set sessionname [lindex [split $sessionname .] 0]
                }

                if { $sessionname eq "" } {
                    set sessionname "unknown"
                }
            }

            # If the session ID (sessionname - username) already exists, terminate it first.
            # NOTE: This is NOT necessary with 4.42 (and probably 4.40) and later, however,
            #       it is necessary with 4.39.
            ::sth::sthCore::invoke stc::perform CSServerConnect -host $::env(STC_LAB_SERVER_ADDRESS)

            foreach session [::sth::sthCore::invoke stc::get system1.csserver -children-CSTestSession] {

                if { [::sth::sthCore::invoke stc::get $session -name] eq "$sessionname - $username" } {
                    # Kill the existing session.
                    ::sth::sthCore::invoke stc::perform CSStopTestSessionCommand    -TestSession $session
                    ::sth::sthCore::invoke stc::perform CSDestroyTestSessionCommand -TestSession $session
                    break
                }
            }
            ::sth::sthCore::invoke stc::perform CSServerDisconnect
            # Done terminating the existing session.

            sth::labserver_connect -server_ip          $::env(STC_LAB_SERVER_ADDRESS) \
                                   -user_name          $username                      \
                                   -session_name       $sessionname                   \
                                   -create_new_session 1

            # By default, the lab server session will remain until it is explicitly terminated.
            if { [info exists ::env(STC_LAB_SERVER_TERMINATE)] } {
                ::sth::sthCore::invoke stc::perform terminatebll -TerminateType $::env(STC_LAB_SERVER_TERMINATE)
            }
        }

        } ;# End if $notloaded

        # Return the versions that are in use.
        keylset result hltapiwrapperversion [package present SpirentHltApiWrapper]
        keylset result hltapiversion        [package present SpirentHltApi]
        keylset result stcapiversion        [package present SpirentTestCenter]

    } errmsg]

    if { $errorhasoccurred } {
        return -code 1 -errorcode -2 $errmsg
    } else {
        keylset result status 1
    }
    keylset result stcapiversion        [package provide SpirentTestCenter]
    keylset result hltapiversion        [package provide SpirentHltApi]
    keylset result hltapiwrapperversion [package provide SpirentHltApiWrapper]

    return $result
}

#==============================================================================
proc ::spirent::loadLatestValidPackage { pkgname validrange {version ""} } {
    # This procedure attempts to load the specified package "pkgname". Optionally,
    # you may specify a specific version to load.
    # "validrange" is a list of ranges of allowable versions for the specified package.
    # Each entry can take the following forms:
    #   all         : (default) All versions of the package are valid.
    #   <version>   : Only the specified version is valid.
    #   -<max>      : All versions, up to the specified version, are valid.
    #   <min>-      : All versions, from the specified version, are valid.
    #   <min>-<max> : All versions between, and including, the specified versions are valid.
    #
    # If the specified version does not fall within the "valid" range, an error is thrown.

    set loadedversion ""

    if { $validrange eq "" } {
        set validrange "all"
    }
    package forget $pkgname

    if { $validrange eq "all" } {
        # All versions of this package are valid.
        if { $version eq "" } {
            # Load the latest version of the package.
            set loadedversion [package require $pkgname]
        } else {
            # Try to load the specified version of the package.
            set loadedversion [package require -exact $pkgname $version]
        }
    } else {

        # Attempt to find a version of the package that is within the specific valid range.

        # This is a list of all versions of this package that are currently available.
        set versionlist [package versions $pkgname]

        # Build a list of versions that are available and valid.
        set foundvalidversionlist ""
        foreach entry $validrange {
            # Parse this entry. Valid forms are:
            #   -<maxversion>
            #   <minversion>-
            #   <minversion>-<maxversion>

            if { [regexp {([0-9\.]*)-([0-9\.]*)} $entry -> minversion maxversion] } {
            } elseif { [regexp {[0-9\.]*} $entry minversion] } {
            } else {
                error "The package '$pkgname' version entry '$entry' is invalid."
            }

            if { ! [info exists maxversion] } {
                set maxversion $minversion
            }

            if { $minversion eq "" } {
                set minversion 0
            }

            if { $maxversion eq "" } {
                set maxversion 99999
            }

            # By now, both minversion and maxversion are defined.

            if { $version ne "" } {
                # A specific version was requested. See if that version falls within this entries' range.
                if { [package vcompare $version $minversion] > -1 && [package vcompare $version $maxversion] < 1 } {
                    # We have found the version we need to load.
                    set foundvalidversionlist $version
                    break
                }
            } else {
                # No specific version was specified. Add all installed versions that are within the valid range specified by "entry".
                foreach availableversion $versionlist {
                    if { [package vcompare $availableversion $minversion] > -1 && [package vcompare $availableversion $maxversion] < 1 } {
                        lappend foundvalidversionlist $availableversion
                    }
                }
            }
        }

        # We now have a list of valid versions. Find the latest version.
        # If a specific version was requested, there will be only one option (if it is valid).
        set versiontoload 0
        foreach validversion $foundvalidversionlist {
            if { [package vcompare $versiontoload $validversion] < 0 } {
                set versiontoload $validversion
            }
        }

        if { $versiontoload == 0 } {
            package require $pkgname
        } else {
            # Finally, load the package.
            if {[catch {set loadedversion [package require -exact $pkgname $versiontoload]} err]} {
                package require $pkgname
            }
            #set loadedversion [package require -exact $pkgname $versiontoload]
        }
    }

    return $loadedversion
}

proc ::spirent::process_arguments {args} {
# Primary purpose of this command is to intercept arguments and handle them before they
#  are passed into the wrapper commands.
# The following attributes will be searched for:
#  -port_handle
#
#    set aMapToSpirent(1/1) port1
#    set aMapToSpirent(1/2) port2
#    set aMapToSpirent(1/3) port3
#    variable kl_port_to_handle_map

# Handle -port_handle values.      ([^[:space:]]*)
    if [regexp -nocase -all -line -- {(-port_handle) ([^-]*)} $args -> szType szPortHandle] {
        debug "\t\t\tmodified ($szType) $args"
    }

    # Handle -src_port values.
    if [regexp -nocase -all -line -- {(-src_port) ([^-]*)} $args -> szType szPortHandle] {
        debug "\t\t\tmodified ($szType) $args"
    }

    # Handle -dst_portlist values.
    if [regexp -nocase -all -line -- {(-dst_portlist) ([^-]*)} $args -> szType szPortHandle] {
        debug "\t\t\tmodified ($szType) $args"
    }

    # Handle -dst_port_list values.
    if [regexp -nocase -all -line -- {(-dst_port_list) ([^-]*)} $args -> szType szPortHandle] {
        debug "\t\t\tmodified ($szType) $args"
    }

    # Handle -dest_port_list values.
    if [regexp -nocase -all -line -- {(-dest_port_list) ([^-]*)} $args -> szType szPortHandle] {
        debug "\t\t\tmodified ($szType) $args"
    }
    return $args
}

proc ::spirent::process_cmd {cmdName} {
    set returnKeyedList ""
    ::spirent::TraceEnter $cmdName
    if {[catch {set returnKeyedList [eval $cmdName]} errMsg]} {
        if {[string length $errMsg] == 0} {
            set errMsg "exception with empty error message is raised."
            ::sth::sthCore::log error $errMsg
        }
        ::sth::sthCore::processError returnKeyedList "error in $cmdName -->$errMsg";
    } else {
        if {[string length $returnKeyedList] == 0} {
            ::sth::sthCore::processError returnKeyedList "error in $cmdName --> empty keyed list returned"
        }
    }
    return $returnKeyedList
}


proc ::spirent::alarms_control {args} {
######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::alarms_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::alarms_stats {args} {
######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::alarms_stats $args"
    return [::spirent::process_cmd $cmdName]
}

proc ::spirent::device_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::device_info $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_ancp_config {args} {
    ######convert physical port
    regsub -nocase -- "ietf-ancp-protocol2" $args "ietf_ancp_protocol2" args
    regsub -nocase -- "gsmp-l2control-config2" $args "gsmp_l2control_config2" args
    set args [eval ::spirent::port_converter $args]
    regsub -nocase -- "ietf_ancp_protocol2" $args "ietf-ancp-protocol2" args
    regsub -nocase -- "gsmp_l2control_config2" $args "gsmp-l2control-config2" args
    set cmdName "::sth::emulation_ancp_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_ancp_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_ancp_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::status_item {args} {
    global return_list
    set stat_item [keylget return_list $args]
    return $stat_item;
}
proc ::spirent::status_item_keys {} {
	global return_list
	set stat_item [keylkeys return_list]
	return $stat_item;
}
proc ::spirent::emulation_ancp_stats {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_ancp_stats $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_ancp_subscriber_lines_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_ancp_subscriber_lines_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_bfd_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    
    ##in case -vlan 0
    if {[lsearch $args "-vlan"] > -1} {
        set index [lsearch $args "-vlan"]
        set vlan [lindex $args [expr $index + 1]]
        set vlanArgList "vlan"
        if {$vlan == 0} {
            set vlanArgList "$vlanArgList vlan_id vlan_id_step vlan_user_priority"
        }
        set args [wrapper::shield_args -total $args -unsupported $vlanArgList]
    }
    
    set cmdName "::sth::emulation_bfd_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_bfd_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_bfd_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_bfd_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_bfd_info $args"
    return [::spirent::process_cmd $cmdName]
}

proc ::spirent::emulation_bgp_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_bgp_info $args"
    return [::spirent::process_cmd $cmdName]
}

proc ::spirent::emulation_bgp_route_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_bgp_route_info $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_dhcp_config {args} {
    ######convert physical port
    global return_list
    set parentnamespace ""
    set procedure [info level 1]
    regexp -nocase {:*([a-z]+)::} $procedure -> parentnamespace
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_dhcp_config $args"
    set return_output [::spirent::process_cmd $cmdName]
    if { [string match -nocase $parentnamespace "AgtTest"] } {
        keylset return_dhcp handle.port_handle [lindex [lindex [keylget return_output handle] 0] 0]
        keylset return_dhcp handle.dhcp_handle [lindex [lindex [keylget return_output handle] 0] 1]
        keylset return_dhcp status [keylget return_output status]
        set return_list $return_dhcp
        return $return_dhcp
    }
    return $return_output
}
proc ::spirent::emulation_dhcp_group_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_dhcp_group_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_dhcp_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_dhcp_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_dhcp_stats {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_dhcp_stats $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_dhcp_server_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_dhcp_server_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_dhcp_server_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_dhcp_server_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_dhcp_server_relay_agent_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_dhcp_server_relay_agent_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_dhcp_server_stats {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_dhcp_server_stats $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_efm_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_efm_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_efm_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_efm_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_efm_stat {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_efm_stat $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_gre_config {args} {

    array set argArray {}
    ::spirent::listToArray $args argArray

    if {![info exist argArray(-gre_prefix_len)]} {
        set argArray(-gre_prefix_len) 24
    }
    if {![info exists argArray(-gre_tnl_type)]} {
        set argArray(-gre_tnl_type) 4
    }
    if {![info exists argArray(-gre_checksum)]} {
        set argArray(-gre_checksum) 0
    }

    return [array get argArray]
}


proc ::spirent::emulation_igmp_config {args} {
    ##Call global return_list for getting the values for ixia::status_item.
    global return_list
    ######convert physical port
    variable hosts_from_gre_obj
    variable gre_objects_from_port
    
    set args [eval ::spirent::port_converter $args]
    variable intf_ip_addr_from_port

    set createHandleFlag 0
    array set argArray {}
    ::spirent::listToArray $args argArray

    if { [info exists argArray(-reset)] } {
        # Delete all of the IGMP configuration for this interface (which may be multiple hosts).
        if { [info exists argArray(-handle)] } {
            set handlelist $argArray(-handle)
        } elseif { [info exists argArray(-port_handle)] } {
            # Reset all of the devices on this port.
            set handlelist [::sth::sthCore::invoke stc::get $argArray(-port_handle) -AffiliationPort-Sources]
        }

        foreach handle $handlelist {
            if { [info exists argArray(-handle)] } {
                set handleindex [lsearch -exact $argArray(-handle) $handle]
            } else {
                set handleindex -1
            }
            if { [::sth::sthCore::invoke stc::get $handle -name] eq "host_igmp" && $handleindex == -1  } {
                # This host was for IGMP only. Delete the entire thing.
                ::sth::sthCore::invoke stc::delete $handle
            } else {
                # This host was not originally created for IGMP, or was specified by -handle.
                # Just delete the "IgmpHostConfig" object if it exists.
                foreach igmpconfig [::sth::sthCore::invoke stc::get $handle -children-IgmpHostConfig] {
                ::sth::sthCore::invoke stc::delete $igmpconfig
		}
            }
        }
        array unset argArray -reset
    }

    if { [info exists argArray(-vlan)] } {
        if { ! $argArray(-vlan) } {
            # Disable vlans.
            array unset argArray -vlan_id
            array unset argArray -vlan_id_count
            array unset argArray -vlan_id_mode
            array unset argArray -vlan_id_step
            array unset argArray -vlan_user_priority
            array unset argArray -vlan_cfi
            array unset argArray -vlan_outer_cfi
            array unset argArray -vlan_id_outer
            array unset argArray -vlan_id_outer_mode
            array unset argArray -vlan_id_outer_count
            array unset argArray -vlan_id_outer_step
            array unset argArray -vlan_outer_user_priority
        }
        array unset argArray -vlan
    }

    if {[info exists argArray(-mac_address_init)]} {
        # STC uses "-source_mac", not "-mac_address_init".
        # WARNING: I have a feeling that there is a bug in HLTAPI.
        #          "source_mac" should probably be "mac_addr" instead.

        set argArray(-source_mac) $argArray(-mac_address_init)
        unset argArray(-mac_address_init)
    }
    if {[info exists argArray(-mac_address_step)]} {
        set argArray(-source_mac_step) $argArray(-mac_address_step)
        array unset argArray -mac_address_step
    }

    #Valid values for "-suppress_report": "true|1"
    if {[info exists argArray(-suppress_report)]} {
        set argArray(-suppress_report) 1
    }

    #Valid values for "-ip_router_alert": "true|1"
    if { [info exists argArray(-ip_router_alert)] && ! $argArray(-ip_router_alert) } {
        array unset argArray -ip_router_alert
    }

    if {[info exists argArray(-msg_count_per_interval)]} {
        set msg_count_per_interval $argArray(-msg_count_per_interval)
        unset argArray(-msg_count_per_interval)
    }

    if {[info exists argArray(-max_groups_per_pkts)]} {
        unset argArray(-max_groups_per_pkts)
    }
    if {[info exists argArray(-max_sources_per_group)]} {
        unset argArray(-max_sources_per_group)
    }
    if {[info exists argArray(-enable_packing)]} {
        unset argArray(-enable_packing)
    }
    if { ! [info exists argArray(-msg_interval)] } {
        # Set a cap on the maximum message interval. I believe this may be the cause for some failures.
        set argArray(-msg_interval) 500
    }
    if {[info exists argArray(-interface_handle)]} {
        #if {"" ne [::sth::sthCore::invoke stc::get $argArray(-interface_handle) -children-igmphostconfig]} {
        #    unset argArray(-interface_handle)
        #}
        # if the interface_handle is a gre_objectX, replace it with its associated GRE routerX
        if {[regexp gre_object $argArray(-interface_handle)]} {
            #set argArray(-interface_handle) [lindex [keylget hosts_from_gre_obj $argArray(-interface_handle)] 0]
            set argArray(-interface_handle) [keylget gre_objects_from_port $argArray(-interface_handle)]
        }	
        set results {}
        keylset results handle $argArray(-interface_handle)
        keylset results handles {}
        keylset results status 0
        set host $argArray(-interface_handle)
        variable ::sth::igmp::hostFilterMode
        variable ::sth::igmp::hostFilterIpAddr
        if {[info exists argArray(-filter_mode)]} {
            set filterMode argArray(-filter_mode)
        } else {
            set filterMode "include"
        }
        
        if {[info exists argArray(-filter_ip_addr)]} {
            set filterIpAddr argArray(-filter_ip_addr)
        } else {
            set filterIpAddr "192.0.1.0"
        }
        
        set ::sth::igmp::hostFilterMode($host) $filterMode
        set ::sth::igmp::hostFilterIpAddr($host) $filterIpAddr
        # Create igmphostconfig
        set ret [::sth::sthCore::invoke stc::perform ProtocolCreateCommand -ParentList $argArray(-interface_handle) -CreateClassId igmphostconfig]
        array set tempA $ret
        if [regexp successful $tempA(-Status)] {
            keylset results status 1
            keylset results handles $tempA(-ReturnList)
        }
        #-intf_ip_addr 104.0.0.2
        #-msg_interval 12
        #-port_handle port1
        #-count 1
        #-mode create
        foreach el [array names argArray] {
            switch -- $el {
                -igmp_version {
                    if {$argArray(-igmp_version) == "v2"} {::sth::sthCore::invoke stc::config $tempA(-ReturnList) -Version IGMP_V2}
                    if {$argArray(-igmp_version) == "v3"} {::sth::sthCore::invoke stc::config $tempA(-ReturnList) -Version IGMP_V3}
                    if {$argArray(-igmp_version) == "v1"} {::sth::sthCore::invoke stc::config $tempA(-ReturnList) -Version IGMP_V1}
                }
                -filter_mode {
                    # -filter_mode is used inside of sth::emulation_igmp_group_config
                    if {$argArray(-filter_mode) == "include"} {set ::sth::igmp::hostFilterMode($argArray(-interface_handle)) "include"}
                    if {$argArray(-filter_mode) == "exclude"} {set ::sth::igmp::hostFilterMode($argArray(-interface_handle)) "exclude"}
                }
                #default {puts "Warning - ::spirent::emulation_igmp_config $el $argArray($el) - not used"}
            }
        }
        return $results
    }

    # added auto configue -ip_src_addr if it is not in parameter config list
    if {![info exists argArray(-intf_ip_addr)] && [info exists argArray(-port_handle)]} {
        set argArray(-intf_ip_addr) [keylget intf_ip_addr_from_port $argArray(-port_handle)]
    }

    # Ixia creates $count separate interface objects.
    set count 1
    if { [info exists argArray(-count)] } {
        set count $argArray(-count)
        array unset argArray -count
    }

    # Make sure all of the defaults are defined.
    if { ! [info exists argArray(-source_mac)] } {
        # I'm not sure what the Ixia default MAC address is. It's not specified in the documentation.
        set argArray(-source_mac) 00.00.00.00.00.01
    }
    if { ! [info exists argArray(-source_mac_step)] } {
        # I'm not sure what the Ixia default MAC address is. It's not specified in the documentation.
        set argArray(-source_mac_step) 00.00.00.00.00.01
    }
    if { [info exists argArray(-vlan_id)] && ! [info exists argArray(-vlan_id_step)] } {
        # Note from Ixia's documentation:
        #    When -vlan_id_mode is set to increment, this defines the step for every VLAN.
        #    Valid for mode create.
        #    When vlan_id_step causes the vlan_id value to exceed it's maximum value the
        #    increment will be done modulo <number of possible vlan ids>.
        #    Examples: vlan_id = 4094; vlan_id_step = 2 -> new vlan_id value = 0
        #    vlan_id = 4095; vlan_id_step = 11 -> new vlan_id value = 10
        set argArray(-vlan_id_step) 1
    }
    # added auto configue -ip_src_addr if it is not in parameter config list
    if {![info exists argArray(-intf_ip_addr)]} {
        if {[info exists argArray(-port_handle)]} {
            set argArray(-intf_ip_addr) [keylget intf_ip_addr_from_port $argArray(-port_handle)]
        } else {
            set argArray(-intf_ip_addr) 192.85.1.3
        }

    }
    if { ! [info exists argArray(-intf_ip_addr_step)] } {
        set argArray(-intf_ip_addr_step) 0.0.0.1
    }
    if { ! [info exists argArray(-neighbor_intf_ip_addr)] } {
        set argArray(-neighbor_intf_ip_addr) 192.85.1.1
    }
    if { ! [info exists argArray(-neighbor_intf_ip_addr_step)] } {
        set argArray(-neighbor_intf_ip_addr_step) 0.0.0.0
    }

    keylset result status 1

    set handlelist  ""
    set handleslist ""
    for { set i 0 } { $i < $count } { incr i } {

        if { [info exists argArray(-port_handle)] && ! [info exists argArray(-handle)] && [info exists argArray(-intf_ip_addr)] } {
            # See if there is an existing device with this IP address.
            set handle [::wrapper::get_device_with_ip_new $argArray(-intf_ip_addr) $argArray(-port_handle)]
            if { $handle ne "" } {
                # Make sure IGMP isn't already enabled on this device, otherwise, we'll get an exception.
                foreach igmphostconfig [::sth::sthCore::invoke stc::get $handle -children-IgmpHostConfig] {
                    ::sth::sthCore::invoke stc::delete $igmphostconfig
                }
                set createHandleFlag 1
                set argArray(-handle) $handle
                array unset cmdresult
            }
        }

        set args [array get argArray]
        set cmdName "::sth::emulation_igmp_config $args"
        set cmdresult [::spirent::process_cmd $cmdName]

        if { [keylget cmdresult status] } {
            set igmphandle   [keylget cmdresult handle]
            set devicehandle [keylget cmdresult handles]

            lappend handlelist  $igmphandle
            lappend handleslist $devicehandle
	    
            # Mark the device as an IGMP host. This will allow us to identify which devices need
            # to be deleted when the emulation_igmp_config -reset flag is used.
            stc::config $devicehandle -name "host_igmp"

            if {[info exist argArray(-intf_ip_addr)]} {
                set intf_ip_addr $argArray(-intf_ip_addr)
                set ::spirent::ip_device($intf_ip_addr) $igmphandle
            }
        } else {
            set result $cmdresult
            break
        }
        unset cmdresult

        # Now step the address values.
        set argArray(-source_mac)            [::sth::sthCore::macStep $argArray(-source_mac) $argArray(-source_mac_step) 1]
        set argArray(-intf_ip_addr)          [::sth::sthCore::updateIpAddress 4 $argArray(-intf_ip_addr)          $argArray(-intf_ip_addr_step)          1]
        set argArray(-neighbor_intf_ip_addr) [::sth::sthCore::updateIpAddress 4 $argArray(-neighbor_intf_ip_addr) $argArray(-neighbor_intf_ip_addr_step) 1]
        if { [info exists argArray(-vlan_id)] } {
            set argArray(-vlan_id) [expr $argArray(-vlan_id) + $argArray(-vlan_id_step)]
        }
        if {$createHandleFlag} {
            array unset argArray -handle
            set createHandleFlag 0
        }
    }

    keylset result handle  $handlelist
    keylset result handles $handleslist

    # MGJ: Added support for the "-msg_interval" option. There is a bug which prevents it from being set.
    if { [info exists argArray(-msg_interval)] } {
        set porthandle ""
        if { [info exists argArray(-port_handle)] } {
            set porthandle $argArray(-port_handle)
        } elseif { [info exists argArray(-handle)] } {
            set porthandle [::sth::sthCore::invoke stc::get $argArray(-handle) -affiliationport-targets]
        }
        if { $porthandle ne "" } {
            ::sth::sthCore::invoke stc::config $porthandle.igmpportconfig -RatePps $argArray(-msg_interval)
        }
    }

    # MGJ: Added support for the "-msg_count_per_interval" option.
    if { [info exists msg_count_per_interval] } {
        set porthandle ""
        if { [info exists argArray(-port_handle)] } {
            set porthandle $argArray(-port_handle)
        } elseif { [info exists argArray(-handle)] } {
            set porthandle [::sth::sthCore::invoke stc::get $argArray(-handle) -affiliationport-targets]
        }

        if { $porthandle ne "" } {
            ::sth::sthCore::invoke stc::config $porthandle.igmpportconfig -MaxBurst $msg_count_per_interval
        }
    }

    return $result
}

proc ::spirent::emulation_igmp_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    array set argArray {}
    ::spirent::listToArray $args argArray

    if {[info exists argArray(-group_member_handle)]} {
        # Agilent allows the user to join specific groups for a host.
        # Spirent TestCenter doesn't allow this, so we need to disable groups
        # that are not in use.
        #
        # WARNING: (MGJ) The code here has a flaw. It will disable groups that were joined
        #          by previous emulation_igmp_control join commands.
        #          I'm not going to fix it, because the fix will touch a lot of code.
        #          My recommendation is to disable all groups for a host when it is created.
        #          When a join is issued, enable all specified groups. When a leave is
        #          issued, disable all specified groups.

        if {[info exists argArray(-handle)]} {
            foreach new_handle $argArray(-handle) {
                # The handle could be a host or igmphostconfig object. We need the igmphostconfig object.
                if { ! [regexp -nocase {igmphostconfig} $new_handle] } {
                    set igmphostconfig [::sth::sthCore::invoke stc::get $new_handle -children-igmphostconfig]
                } else {
                    set igmphostconfig $new_handle
                }
    
                if { $igmphostconfig ne "" } {
                    set existFlag 0
                    foreach group_membership [::sth::sthCore::invoke stc::get $igmphostconfig -children-igmpgroupmembership] {
                        if [regexp $argArray(-group_member_handle) [::sth::sthCore::invoke stc::get $group_membership -subscribedgroups-Targets]] {
                            ::sth::sthCore::invoke stc::config $group_membership -Active TRUE
                            set existFlag 1
                        } else {
                            ::sth::sthCore::invoke stc::config $group_membership -Active FALSE
                        }
                    }
                    if {$existFlag == 0} {
                        ::sth::sthCore::invoke stc::create "IgmpGroupMembership" -under $igmphostconfig [list -SubscribedGroups-targets $argArray(-group_member_handle)]
                    }   
                }
                ::sth::sthCore::invoke stc::apply
            }
        }
        unset argArray(-group_member_handle)
    }
    if {[info exists argArray(-group_pool_handle)]} {
        unset argArray(-group_pool_handle)
    }
    if {[info exists argArray(-mode)] && $argArray(-mode) == "start"} {
        set argArray(-mode) join
    }
    if {[info exists argArray(-mode)] && $argArray(-mode) == "stop"} {
        set argArray(-mode) leave
    }
    set args [array get argArray]


    set cmdName "::sth::emulation_igmp_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_igmp_group_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set i [lsearch $args -no_write]
    set args [lreplace $args $i $i]

    array set argArray {}
    ::spirent::listToArray $args argArray

    ##ignoring ixia arguments not used in Spirent
    catch {unset argArray(-g_enable_packing)}
    catch {unset argArray(-g_max_groups_per_pkts)}
    catch {unset argArray(-g_max_sources_per_group)}
    catch {unset argArray(-g_filter_mode)}
    if {[info exists argArray(-mode)] && $argArray(-mode) == "clear_all"} {
        if {![info exists argArray(-handle)] && [info exists argArray(-session_handle)]} {
            foreach igmpHostConfig [::sth::sthCore::invoke stc::get $argArray(-session_handle) -children-igmphostconfig] {
                set argArray(-handle) [::sth::sthCore::invoke stc::get $igmpHostConfig -children-igmpgroupmembership]
            }
            unset argArray(-session_handle)
        }
    }

    if {[info exists argArray(-mode)] && $argArray(-mode) == "delete"} {
        if {![info exists argArray(-group_pool_handle)] && [info exists argArray(-handle)]} {
            set argArray(-group_pool_handle) [::sth::sthCore::invoke stc::get $argArray(-handle) -subscribedgroups-Targets]
        }
    }
    set args [array get argArray]

    set cmdName "::sth::emulation_igmp_group_config $args"
    set result [::spirent::process_cmd $cmdName]

    if [keylget result status] {
        set handle [keylget result handle]

        if { [info exists argArray(-group_pool_handle)] } {
            keylset result group_pool_handle $argArray(-group_pool_handle)
        } else {
            keylset result group_pool_handle {}
        }
        if { [info exists argArray(-source_pool_handle)] } {
            keylset result source_pool_handles $argArray(-source_pool_handle)
        } else {
            keylset result source_pool_handles {}
        }

    }
    return $result
}
proc ::spirent::emulation_igmp_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_igmp_info $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_isis_config {args} {

    ################################################
    ##
    ## step 1: set variables
    ## step 2: convert args vlaues to STC style
    ## step 3: Unset variables which is not is STC
    ## step 4: set manual variables values
    ## step 5: Execute and return
    ##
    ################################################

    #########################
    ## step 1: set variables
    #########################

    global return_list
    array set argArray {}
    #array set result ""
    #array set tempResult ""
    #keylset result status 1
    #keylset result handle ""
    #keylset result handles ""
    #keylset result session_router ""
    #set tempArray(-areaIdStep) "0.0.0.1"
    ###for Agilent
    set parentnamespace ""
    set procedure [info level 1]
    regexp -nocase {:*([a-z]+)::} $procedure -> parentnamespace
    
    ############################################
    ## step 2: convert args values to STC style
    ############################################
    
    ## convert physical port
    set args [eval ::spirent::port_converter $args]
    ## List to Array
    ::spirent::listToArray $args argArray

    # Setting the enable_isis_lsp attribute as 0 to avoid creating the isislsp in isis_config API.
    # This is applicable only from HLTAPI 4.57 onwards.
    #set argArray(-enable_isis_lsp) 0

    if {[info exist argArray(-vlan)] && ( $argArray(-vlan) == 0)} {
        array unset argArray -vlan_id
        array unset argArray -vlan_id_step
        array unset argArray -vlan_id_mode
        array unset argArray -vlan_user_priority
    }
    array unset argArray -vlan
    
    ###############################################
    ## step 3: Unset variables which is not is STC
    ###############################################
    
    catch {unset argArray(-attach_bit)}
    catch {unset argArray(-domain_authentication_mode)}
    catch {unset argArray(-graceful_restart_mode)}
    catch {unset argArray(-graceful_restart_version)}
    catch {unset argArray(-l1_router_priority)}
    catch {unset argArray(-l2_router_priority)}
    catch {unset argArray(-max_packet_size)}
    catch {unset argArray(-partition_repair)}
    catch {unset argArray(-te_metric)}
    catch {unset argArray(-discard_lsp)}

    #######################################
    ## step 4: set manual variables values
    #######################################
    
    if {[info exist argArray(-area_authentication_mode)]} {
        if {$argArray(-area_authentication_mode) == "null"} {
            set argArray(-authentication_mode) "none"
        } elseif {$argArray(-area_authentication_mode) == "text"} {
            set argArray(-authentication_mode) "simple"
        } else {
            set argArray(-authentication_mode) $argArray(-area_authentication_mode)
        }
        unset argArray(-area_authentication_mode)
    }
    
    if {[info exist argArray(-mac_address_init)]} {
        set tmpstring [join [split $argArray(-mac_address_init) .] {}]
        set stringlen [string length $tmpstring]
        set startindx 0
        set tmplist ""
        for {set endindx 1} {$endindx < $stringlen} {incr endindx 2} {
            lappend tmplist [string range $tmpstring $startindx $endindx]
            incr startindx 2
        }
        set argArray(-mac_address_start) [join $tmplist :]
        unset argArray(-mac_address_init)
    }

    if {[info exist argArray(-area_id)]} {
        set argArray(-area_id) [join $argArray(-area_id) {}]
    } else {
        set argArray(-area_id) "490001"
    }

	if {([info exist argArray(-mode)] && ("create" == $argArray(-mode))) && ([info exist argArray(-reset)])} {
	    set port_handle $argArray(-port_handle)
        set devices [::sth::sthCore::invoke stc::get $port_handle -AffiliationPort-Sources]
        if {$devices != ""} {
            foreach device $devices {
                set isis_session [::sth::sthCore::invoke stc::get $device -children-IsisRouterConfig]
                if {$isis_session != ""} {
                    ::sth::sthCore::invoke stc::delete $isis_session
                }
            }
        }
		unset argArray(-reset)
	}
    
    if {[info exist argArray(-system_id)]} {
        set argArray(-system_id) [join $argArray(-system_id) {}]
    }

    if {[info exist argArray(-te_max_bw)] && $argArray(-te_max_bw) == 0} {
        unset argArray(-te_max_bw)
    }

    if {[info exist argArray(-te_admin_group)] && $argArray(-te_admin_group) == 0} {
        unset argArray(-te_admin_group)
    }

    if {[info exist argArray(-te_max_resv_bw)] && $argArray(-te_max_resv_bw) == 0} {
        unset argArray(-te_max_resv_bw)
    }
    
    if {[info exist argArray(-te_unresv_bw_priority0)] && $argArray(-te_unresv_bw_priority0) == 0} {
        unset argArray(-te_unresv_bw_priority0)
    }
    
    if {[info exist argArray(-te_unresv_bw_priority1)] && $argArray(-te_unresv_bw_priority1) == 0} {
        unset argArray(-te_unresv_bw_priority1)
    }
    
    if {[info exist argArray(-te_unresv_bw_priority2)] && $argArray(-te_unresv_bw_priority2) == 0} {
        unset argArray(-te_unresv_bw_priority2)
    }
    
    if {[info exist argArray(-te_unresv_bw_priority3)] && $argArray(-te_unresv_bw_priority3) == 0} {
        unset argArray(-te_unresv_bw_priority3)
    }
    
    if {[info exist argArray(-te_unresv_bw_priority4)] && $argArray(-te_unresv_bw_priority4) == 0} {
        unset argArray(-te_unresv_bw_priority4)
    }
    
    if {[info exist argArray(-te_unresv_bw_priority5)] && $argArray(-te_unresv_bw_priority5) == 0} {
        unset argArray(-te_unresv_bw_priority5)
    }
    
    if {[info exist argArray(-te_unresv_bw_priority6)] && $argArray(-te_unresv_bw_priority6) == 0} {
        unset argArray(-te_unresv_bw_priority6)
    }
    
    if {[info exist argArray(-te_unresv_bw_priority7)] && $argArray(-te_unresv_bw_priority7) == 0} {
        unset argArray(-te_unresv_bw_priority7)
    }

    if {[info exist argArray(-multi_topology)] && $argArray(-multi_topology) == 1} {
        set argArray(-multi_topology) 2
    }

    if {[info exist argArray(-mode)] && [string match -nocase $argArray(-mode) delete]} {
        if {[string equal -nocase [::sth::sthCore::invoke stc::get $argArray(-handle) -name] "port_address"]} {
            if {[catch {
                set isishandle [::sth::sthCore::invoke stc::get $argArray(-handle) -children-isisrouterconfig]
                ::sth::sthCore::invoke stc::delete $isishandle
            } cmderror]} {
                keylset return_keydlist status 0 log $cmderror
            } else {
                keylset return_keydlist status 1
            }
            return $return_keydlist
        }
    }
    
    if {[info exist argArray(-mode)] && [string match -nocase $argArray(-mode) create]} {
        #check if there is already one device created with the same ip, then use that device to create emulation
        if {![info exist argArray(-intf_ip_addr)] && ![info exist argArray(-intf_ipv6_addr)]} {
            set device [lindex [::sth::sthCore::invoke stc::get $argArray(-port_handle) -affiliationport-Sources] 0]
        } else {
            if {[info exist argArray(-intf_ip_addr)]} {
                set intf_ip_addr $argArray(-intf_ip_addr)
            } else {
                set intf_ip_addr $argArray(-intf_ipv6_addr)
            }
            set port_hdl $argArray(-port_handle)
            set device [::wrapper::get_device_with_ip_new $intf_ip_addr $port_hdl]
        }
        catch {unset isisRoute}
        catch {unset existedIsisVersion}
        catch {unset configIsisVersion}
        if {$device != ""} {
            set isisRoute [stc::get $device -children-isisrouterconfig]
            if {"" != $isisRoute} {
                set existedIsisVersion [stc::get $isisRoute -IpVersion]
                if {[info exist argArray(-ip_version)] && 6 == $argArray(-ip_version)} {
                    set configIsisVersion ipv6
                } else {
                    set configIsisVersion ipv4
                }
            }
            if {![info exist existedIsisVersion] || [string equal -nocase $existedIsisVersion $configIsisVersion]} {
                array unset argArray -port_handle
                set argArray(-handle) $device
            }
        }
        # This is to make the MAC address unique across the ports
        if {![info exist argArray(-mac_address_start)] && ![info exist argArray(-handle)]} {
            set lastdevice [lindex [::sth::sthCore::invoke stc::get project1 -children-emulateddevice] end]
            if {$lastdevice != ""} {
                set macaddr [::sth::sthCore::invoke stc::get [::sth::sthCore::invoke stc::get $lastdevice -children-ethiiif] -SourceMac]
                set argArray(-mac_address_start) [::wrapper::incrMacAddress $macaddr]
            }
        }
    }

    ##############################
    ## step 5: Execute and return
    ##############################
    
    set args [array get argArray]
    set cmdName "::sth::emulation_isis_config $args"
    set return_list [::spirent::process_cmd $cmdName]
    if {[string match -nocase $parentnamespace "AgtTest"] && ![info exist argArray(-system_id)]} {
        if {[info exist argArray(-mode)] && [string match -nocase $argArray(-mode) create]} {
            set rtrhndl [keylget return_list handles]
            set ethhndl [::sth::sthCore::invoke stc::get $rtrhndl -children-ethiiif]
            set macaddr [::sth::sthCore::invoke stc::get $ethhndl -sourcemac]
            set isislsphndl [keylget return_list session_router]
            ::sth::sthCore::invoke stc::config $isislsphndl -systemid $macaddr
            ::sth::sthCore::invoke stc::config [::sth::sthCore::invoke stc::get $isislsphndl -parent] -systemid $macaddr
            ::sth::sthCore::invoke stc::apply
        }
    }
    if {[info exist argArray(-intf_ip_addr)]} {
        set intf_ip_addr $argArray(-intf_ip_addr)
        set ::spirent::ip_device($intf_ip_addr) [keylget return_list handle]
    } elseif {[info exist argArray(-intf_ipv6_addr)]} {
        set intf_ip_addr [::sth::sthCore::normalizeIPv6Addr $argArray(-intf_ipv6_addr)]
        set ::spirent::ip_device($intf_ip_addr) [keylget return_list handle]
    }
    
    return $return_list
}
proc ::spirent::emulation_isis_control {args} {
    ######convert physical port
    global return_list
    array set argArray {}
    set args [eval ::spirent::port_converter $args]
    ## List to Array
    ::spirent::listToArray $args argArray
    if {[info exist argArray(-port_handle)]} {
        foreach prthndl $argArray(-port_handle) {
            set args [wrapper::shield_args -total $args -unsupported "port_handle"]
            set args "$args -port_handle $prthndl"
            set cmdName "::sth::emulation_isis_control $args"
            set return_list [::spirent::process_cmd $cmdName]
            if {[keylget return_list status] == 0} {
                break
            }
        }
    } else {
        set cmdName "::sth::emulation_isis_control $args"
        set return_list [::spirent::process_cmd $cmdName]
    }
    return $return_list
}
proc ::spirent::emulation_isis_info {args} {
    ######convert physical port
    global return_list
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_isis_info $args"
    set return_list [::spirent::process_cmd $cmdName]
    return $return_list
}
proc ::spirent::emulation_isis_topology_route_config {args} {

    ################################################
    ##
    ## step 1: set variables
    ## step 2: convert args vlaues to STC style
    ## step 3: Unset variables which is not is STC
    ## step 4: set manual variables values
    ## step 5: Execute and return
    ##
    ################################################

    #########################
    ## step 1: set variables
    #########################

    global return_list
    array set argArray {}
    ###for Agilent
    set parentnamespace ""
    set procedure [info level 1]
    regexp -nocase {:*([a-z]+)::} $procedure -> parentnamespace
    
    ############################################
    ## step 2: convert args values to STC style
    ############################################
    
    ## convert physical port
    set args [eval ::spirent::port_converter $args]
    ## List to Array
    ::spirent::listToArray $args argArray

    ###############################################
    ## step 3: mapping external_route_count and stub_route_count
    ###############################################
    
    if {[info exist argArray(-external_route_count)]} {
        set argArray(-external_count) $argArray(-external_route_count)
        unset argArray(-external_route_count)
    }
    if {[info exist argArray(-stub_route_count)]} {
        set argArray(-stub_count) $argArray(-stub_route_count)
        unset argArray(-stub_route_count)
    }
    
    set isishandle $argArray(-handle)
    set retVal  [::sth::sthCore::invoke stc::get $isishandle -children]
    set templist [split $retVal " "]
    foreach handle $templist {
        if {[regexp -nocase "isisrouterconfig" $handle]} {
            if {![info exist argArray(-router_routing_level)]} {
                set routing_level  [::sth::sthCore::invoke stc::get $handle -Level]
                if {$routing_level eq "LEVEL2"} {
                    set argArray(-router_routing_level)  "L2"
                } elseif  {$routing_level eq "LEVEL1"} {
                    set argArray(-router_routing_level)  "L1"
                } else {
                    set argArray(-router_routing_level) "L1L2"
                }
            }
        
            if {![info exist argArray(-router_system_id)]} {
                set system_id  [::sth::sthCore::invoke stc::get $handle -SystemId]
                regsub -all {\-|:} $system_id " " router_system_id
                set argArray(-router_system_id) $router_system_id
                
            
            }
        
        }
    }
  
    #######################################
    ## step 4: set manual variables values
    #######################################
    
    if {[info exist argArray(-external_metric)]} {
        if {$argArray(-external_metric) < 1 || $argArray(-external_metric) > 63} {
            unset argArray(-external_metric)
        }
    }
    
    if {[info exist argArray(-type)]} {
        if {$argArray(-type) != "router" && $argArray(-type) != "grid" && \
                $argArray(-type) != "stub" && $argArray(-type) != "external"} {
            unset argArray(-type)
        }
    }
    
    if {[info exist argArray(-router_system_id)]} {
        set argArray(-router_system_id) [join $argArray(-router_system_id) {}]
    }
    
    if {[info exist argArray(-router_area_id)]} {
        unset argArray(-router_area_id)
    }

    ##############################
    ## step 5: Execute and return
    ##############################
    
    set args [array get argArray]
    set cmdName "::sth::emulation_isis_topology_route_config $args"
    set return_list [::spirent::process_cmd $cmdName]
    return $return_list
}
proc ::spirent::emulation_l2vpn_pe_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_l2vpn_pe_config $args"
    return [::spirent::process_cmd $cmdName]
}

##Not matched ixia HLTAPI
##add by WestWang
proc ::spirent::emulation_lacp_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_lacp_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_lacp_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_lacp_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_lacp_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_lacp_info $args"
    return [::spirent::process_cmd $cmdName]
}

proc ::spirent::emulation_ldp_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_ldp_info $args"
    return [::spirent::process_cmd $cmdName]
}

proc ::spirent::emulation_lldp_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_lldp_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_lldp_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_lldp_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_lldp_dcbx_tlv_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_lldp_dcbx_tlv_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_lldp_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_lldp_info $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_lldp_optional_tlv_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_lldp_optional_tlv_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_mld_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]

    array set tempArray {}
    array set argArray {}
    ::spirent::listToArray $args argArray

    if {[info exists argArray(-reset)]} {
        # Delete all of the MLD configuration for this inteface (which may include multiple devices).
        if { [info exists argArray(-handle)] } {
            set handlelist $argArray(-handle)
        } elseif { [info exists argArray(-port_handle)] } {
            # Reset all of the devices on this port.
            set handlelist [::sth::sthCore::invoke stc::get $argArray(-port_handle) -AffiliationPort-Sources]
        }

        foreach handle $handlelist {          
            if { [info exists argArray(-handle)] } {
                set handleindex [lsearch -exact $argArray(-handle) $handle]
            } else {
                set handleindex -1
            }
            if { [::sth::sthCore::invoke stc::get $handle -name] eq "host_mld" && $handleindex == -1  } {
                # This host was for MLD only. Delete the entire thing.
                ::sth::sthCore::invoke stc::delete $handle
            } else {
                # This host was not originally created for MLD, or was specified by -handle.
                # Just delete the "MLDHostConfig" object if it exists.
                foreach mldhostconfig [::sth::sthCore::invoke stc::get $handle -children-MldHostConfig] {
                ::sth::sthCore::invoke stc::delete $mldhostconfig
		}
            }
        }

        array unset argArray -reset
    }

    if { [info exists argArray(-vlan)] } {
        if { ! $argArray(-vlan) } {
            # Disable vlans.
            array unset argArray -vlan_id
            array unset argArray -vlan_id_count
            array unset argArray -vlan_id_mode
            array unset argArray -vlan_id_step
            array unset argArray -vlan_user_priority
            array unset argArray -vlan_cfi
            array unset argArray -vlan_outer_cfi
            array unset argArray -vlan_id_outer
            array unset argArray -vlan_id_outer_mode
            array unset argArray -vlan_id_outer_count
            array unset argArray -vlan_id_outer_step
            array unset argArray -vlan_outer_user_priority
        }

        array unset argArray -vlan
    }

    if {[info exists argArray(-mac_address_init)]} {
        set macaddress $argArray(-mac_address_init)
        unset argArray(-mac_address_init)
    }
    if {[info exists argArray(-mac_address_step)]} {
        set macaddressstep $argArray(-mac_address_step)
        array unset argArray -mac_address_step
    }

    if {[info exists argArray(-msg_count_per_interval)]} {
        set msg_count_per_interval $argArray(-msg_count_per_interval)
        unset argArray(-msg_count_per_interval)
    }

    if { ! [info exists argArray(-msg_interval)] } {
        # Set a cap on the maximum message interval. I believe this may be the cause for some failures.
        set argArray(-msg_interval) 500
    }

    #Valid values for "-suppress_report": "true|1"
    if {[info exists argArray(-suppress_report)]} {
        set argArray(-suppress_report) 1
    }

    if {[info exists argArray(-max_groups_per_pkts)]} {
        unset argArray(-max_groups_per_pkts)
    }

    # Ixia creates $count separate interface objects.
    set count 1
    if { [info exists argArray(-count)] } {
        set count $argArray(-count)
        array unset argArray -count
    }

    # Make sure all of the defaults are defined.
    if { ! [info exists macaddress] } {
        # I'm not sure what the Ixia default MAC address is. It's not specified in the documentation.
        set macaddress 00.00.00.00.00.01
    }
    if { ! [info exists argArray(-source_mac_step)] } {
        # I'm not sure what the Ixia default MAC address is. It's not specified in the documentation.
        set macaddressstep 00.00.00.00.00.01
    }
    if { [info exists argArray(-vlan_id)] && ! [info exists argArray(-vlan_id_step)] } {
        # Note from Ixia's documentation:
        #    When -vlan_id_mode is set to increment, this defines the step for every VLAN.
        #    Valid for mode create.
        #    When vlan_id_step causes the vlan_id value to exceed it's maximum value the
        #    increment will be done modulo <number of possible vlan ids>.
        #    Examples: vlan_id = 4094; vlan_id_step = 2 -> new vlan_id value = 0
        #    vlan_id = 4095; vlan_id_step = 11 -> new vlan_id value = 10
        set argArray(-vlan_id_step) 1
    }
    if { ! [info exists argArray(-intf_ip_addr)] } {
        # I don't know what the Ixia or Agilent default is.
        set argArray(-intf_ip_addr) 2001::2
    }
    if { ! [info exists argArray(-intf_ip_addr_step)] } {
        set argArray(-intf_ip_addr_step) 0::1
    }
    if { ! [info exists argArray(-neighbor_intf_ip_addr)] } {
        set argArray(-neighbor_intf_ip_addr) 0::0
    }
    if { ! [info exists argArray(-neighbor_intf_ip_addr_step)] } {
        set argArray(-neighbor_intf_ip_addr_step) 0::0
    }

    keylset result status 1

    set handlelist  ""
    set handleslist ""
    for { set i 0 } { $i < $count } { incr i } {
        if { [info exists argArray(-port_handle)] && ! [info exists argArray(-handle)] && [info exists argArray(-intf_ip_addr)] } {
            # See if there is an existing device with this IP address.
            set handle [::wrapper::get_device_with_ip_new $argArray(-intf_ip_addr) $argArray(-port_handle)]
            if { $handle ne "" } {
                # Make sure MLD isn't already enabled on this device, otherwise, we'll get an exception.
                foreach mldhostconfig [::sth::sthCore::invoke stc::get $handle -children-MldHostConfig] {
                    ::sth::sthCore::invoke stc::delete $mldhostconfig
                }
                set argArray(-handle) $handle
                set tempArray(-port_handle) $argArray(-port_handle)
                array unset argArray -port_handle
                array unset cmdresult
            }
        }

        set args [array get argArray]
        set cmdName "::sth::emulation_mld_config $args"
        set cmdresult [::spirent::process_cmd $cmdName]

        if { [keylget cmdresult status] } {
            set devicehandle [keylget cmdresult handles]
            set mldhandle    [::sth::sthCore::invoke stc::get $devicehandle -parent]
            lappend handlelist  $mldhandle
            lappend handleslist $devicehandle

            # Modify the MAC address since Spirent HLTAPI doesn't support setting it.
            set tempValue [::sth::sthCore::invoke stc::get $devicehandle -parent]
            ::sth::sthCore::invoke stc::config $tempValue.EthIIIf -SourceMac $macaddress
            # Mark the device as an MLD host. This will allow us to identify which devices need
            # to be deleted when the emulation_mld_config -reset flag is used.
            stc::config $devicehandle -name "host_mld"
            if {[info exist argArray(-intf_ip_addr)]} {
                set intf_ip_addr $argArray(-intf_ip_addr)
                set ::spirent::ip_device($intf_ip_addr) $mldhandle
            }
            unset tempValue
        } else {
            set result $cmdresult
            break
        }
        unset cmdresult

        # Now step the address values.
        set macaddress                       [::sth::sthCore::macStep $macaddress $macaddressstep 1]
        set argArray(-intf_ip_addr)          [::sth::sthCore::updateIpAddress 6 $argArray(-intf_ip_addr)          $argArray(-intf_ip_addr_step)          1]
        set argArray(-neighbor_intf_ip_addr) [::sth::sthCore::updateIpAddress 6 $argArray(-neighbor_intf_ip_addr) $argArray(-neighbor_intf_ip_addr_step) 1]
        if { [info exists argArray(-vlan_id)] } {
            set argArray(-vlan_id) [expr $argArray(-vlan_id) + $argArray(-vlan_id_step)]
        }
        if {[info exist tempArray(-port_handle)]} {
            set argArray(-port_handle) $tempArray(-port_handle)
            array unset argArray -handle
            array unset tempArray -port_handle
        }
    }

    keylset result handle  $handlelist
    keylset result handles $handleslist

    # MGJ: Added support for the "-msg_interval" option. There is a bug which prevents it from being set.
    if { [info exists argArray(-msg_interval)] } {
        set porthandle ""
        if { [info exists argArray(-port_handle)] } {
            set porthandle $argArray(-port_handle)
        } elseif { [info exists argArray(-handle)] } {
            set porthandle [::sth::sthCore::invoke stc::get $argArray(-handle) -affiliationport-targets]
        }

        if { $porthandle ne "" } {
            ::sth::sthCore::invoke stc::config $porthandle.mldportconfig -RatePps $argArray(-msg_interval)
        }
    }

    # MGJ: Added support for the "-msg_count_per_interval" option.
    if { [info exists msg_count_per_interval] } {
        set porthandle ""
        if { [info exists argArray(-port_handle)] } {
            set porthandle $argArray(-port_handle)
        } elseif { [info exists argArray(-handle)] } {
            set porthandle [::sth::sthCore::invoke stc::get $argArray(-handle) -affiliationport-targets]
        }

        if { $porthandle ne "" } {
            ::sth::sthCore::invoke stc::config $porthandle.mldportconfig -MaxBurst $msg_count_per_interval
        }
    }
    return $result
}

proc ::spirent::emulation_mld_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    array set argArray {}
    ::spirent::listToArray $args argArray

        if {[info exists argArray(-mode)] && $argArray(-mode) == "start"} {
            set argArray(-mode) "join"
        }
        if {[info exists argArray(-mode)] && $argArray(-mode) == "stop"} {
            set argArray(-mode) "leave"
        }
        set args [array get argArray]


    set cmdName "::sth::emulation_mld_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_mld_group_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_mld_group_config $args"
    set result [::spirent::process_cmd $cmdName]

    ::spirent::listToArray $args argArray

    if { [info exists argArray(-group_pool_handle)] } {
        keylset result group_pool_handle $argArray(-group_pool_handle)
    }
    if { [info exists argArray(-source_pool_handle)] } {
        keylset result source_pool_handle $argArray(-source_pool_handle)
    }

    return $result
}
proc ::spirent::emulation_mld_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_mld_info $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_mpls_l2vpn_pe_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_mpls_l2vpn_pe_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_mpls_l2vpn_site_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_mpls_l2vpn_site_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_mpls_l3vpn_pe_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_mpls_l3vpn_pe_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_mpls_l3vpn_site_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_mpls_l3vpn_site_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_multicast_group_config {args} {
    global return_list
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    array set argArray {}
    ::spirent::listToArray $args argArray

        # Ixia used both -ip_addr_step 0.0.0.1 and -ip_prefix_len 8 which do not make sense
        # Need set -ip_prefix_len 32 when -ip_addr_step 0.0.0.x
        if {[info exists argArray(-ip_addr_step)] && [regexp -all \\. $argArray(-ip_addr_step)] == 3} {
            if [regexp {0\.0\.0\.} $argArray(-ip_addr_step)] {
                set argArray(-ip_prefix_len) 32
            }
            set argArray(-ip_addr_step) [::ip::toInteger $argArray(-ip_addr_step)]
        } elseif {[info exists argArray(-ip_addr_step)] && [regexp -nocase -all -line -- {([[:digit:]+])} $argArray(-ip_addr_step) match]} {
            # for IPv6
            set argArray(-ip_addr_step) $match
        }
        set args [array get argArray]


    set cmdName "::sth::emulation_multicast_group_config $args"
    set retKeyedList [::spirent::process_cmd $cmdName]
	
    set return_list $retKeyedList
    return $retKeyedList
}
proc ::spirent::emulation_multicast_source_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    array set argArray {}
    listToArray $args argArray

    if {[info exists argArray(-ip_addr_step)]} {
        set argArray(-ip_addr_step) [convertIp2Integer $argArray(-ip_addr_step)]
    }
    set args [array get argArray]


    set cmdName "::sth::emulation_multicast_source_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_mvpn_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_mvpn_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_mvpn_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_mvpn_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_mvpn_customer_port_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_mvpn_customer_port_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_mvpn_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_mvpn_info $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_mvpn_provider_port_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_mvpn_provider_port_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_oam_config_msg {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_oam_config_msg $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_oam_config_topology {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_oam_config_topology $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_oam_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_oam_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_oam_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_oam_info $args"
    return [::spirent::process_cmd $cmdName]
}

proc ::spirent::emulation_ospf_lsa_config {args} {

    ################################################
    ##
    ## step 1: set variables
    ## step 2: convert args vlaues to STC style
    ## step 3: Unset variables which is not is STC
    ## step 4: set manual variables values
    ## step 5: Execute and return
    ##
    ################################################

    #########################
    ## step 1: set variables
    #########################

    array set argArray {}


    ############################################
    ## step 2: convert args values to STC style
    ############################################
    
    ## convert physical port
    set args [eval ::spirent::port_converter $args]
    ## List to Array
    ::spirent::listToArray $args argArray

    ###############################################
    ## step 3: Unset variables which is not is STC
    ###############################################
    
    catch {unset argArray(-lsa_group_mode)}
    catch {unset argArray(-area_id)}
    catch {unset argArray(-no_write)}

    #######################################
    ## step 4: set manual variables values
    #######################################

    if {[info exist argArray(-type)]} {
        if {$argArray(-type) == "opaque_type_9" || $argArray(-type) == "opaque_type_11"} {
            unset argArray(-type)
        }
    }
    
    ##############################
    ## step 5: Execute and return
    ##############################
    
    set args [array get argArray]
    set cmdName "::sth::emulation_ospf_lsa_config $args"
    set return_list [::spirent::process_cmd $cmdName]
    return $return_list
}
proc ::spirent::emulation_ospf_route_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_ospf_route_info $args"
    return [::spirent::process_cmd $cmdName]
}

proc ::spirent::emulation_ospfv2_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_ospfv2_info $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_ospfv3_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_ospfv3_info $args"
    return [::spirent::process_cmd $cmdName]
}

proc ::spirent::emulation_pim_config {args} {
    variable gre_tunnel_list
    variable hosts_from_gre_obj
    #variable gre_physical_router_per_port
    variable gre_objects_from_port

    array set argArray {}
    array set tempArray {}
    set handleFlag 0

    set args [eval ::spirent::port_converter $args]
    ::spirent::listToArray $args argArray
    
    if {[info exist argArray(-vlan)] && ( $argArray(-vlan) == 0)} {
        array unset argArray -vlan_id
        array unset argArray -vlan_id_step
        array unset argArray -vlan_id_mode
        array unset argArray -vlan_user_priority
    }
    array unset argArray -vlan

    # Added for GRE test case: L3VPN_Leave_Group
    # Input: -handle <pim_session_handle> or
    #   pimrouterconfigX or pimv4groupblk5
    # -port_handle <handle>
    # -mode enable/disable

    if {[info exists argArray(-gateway_intf_ip_addr)]} {
        # This is not a permanent fix. Instead, we need to set the IP interface
        # object's gateway address directly.
        set argArray(-neighbor_intf_ip_addr) $argArray(-gateway_intf_ip_addr)
        set tempArray(-gateway_intf_ip_addr) $argArray(-gateway_intf_ip_addr)
        unset argArray(-gateway_intf_ip_addr)
    }
    if {[info exists argArray(-port_handle)] && [info exists argArray(-handle)] && [info exists argArray(-mode)] && $argArray(-mode) eq "disable"} {
        set results {}
        keylset results status 0
        if {[regexp "pimrouterconfig" $argArray(-handle)]} {
            set pimv4groupblk [::sth::sthCore::invoke stc::get $argArray(-handle) -children-pimv4groupblk]
        } elseif {[regexp "pimv4groupblk" $argArray(-handle)]} {
            set pimv4groupblk $argArray(-handle)
        }
        foreach el $pimv4groupblk {
            ::sth::sthCore::invoke stc::config $el -Active false
        }
        ::sth::sthCore::invoke stc::apply
        keylset results status 1
        keylset results handle $argArray(-handle)
        return $results
    }
    if {[info exists argArray(-port_handle)] && [info exists argArray(-handle)] && [info exists argArray(-mode)] && $argArray(-mode) eq "enable"} {
        set results {}
        keylset results status 0
        if {[regexp "pimrouterconfig" $argArray(-handle)]} {
            set pimv4groupblk [::sth::sthCore::invoke stc::get $argArray(-handle) -children-pimv4groupblk]
        } elseif {[regexp "pimv4groupblk" $argArray(-handle)]} {
            set pimv4groupblk $argArray(-handle)
        }
        foreach el $pimv4groupblk {
            ::sth::sthCore::invoke stc::config $el -Active true
        }
        ::sth::sthCore::invoke stc::apply
        ::spirent::emulation_pim_control -mode stop -port_handle $argArray(-port_handle)
        sleep 1
        ::spirent::emulation_pim_control -mode start -port_handle $argArray(-port_handle)
        keylset results status 1
        keylset results handle $argArray(-handle)
        return $results
    }
    ##this is from version 1.02
    if { [info exists argArray(-reset)] } {
        # Delete all of the PIM configuration for this interface (this may include multiple devices).
        if { [info exists argArray(-handle)] } {
            set handlelist $argArray(-handle)
        } elseif { [info exists argArray(-port_handle)] } {
            # Reset all of the devices on this port.
            set handlelist [::sth::sthCore::invoke stc::get $argArray(-port_handle) -AffiliationPort-Sources]
        }

        foreach handle $handlelist {
            if { [info exists argArray(-handle)] } {
                set handleindex [lsearch -exact $argArray(-handle) $handle]
            } else {
                set handleindex -1
            }
            if { [::sth::sthCore::invoke stc::get $handle -name] eq "router_pim" && $handleindex == -1 } {
                # This host was for PIM only. Delete the entire thing.
                ::sth::sthCore::invoke stc::delete $handle
            } else {
                # This device was not originally created for PIM, or was specified by -handle.
                # Just delete the "PimRouterConfig" object if it exists.
                foreach pimconfig [::sth::sthCore::invoke stc::get $handle -children-PimRouterConfig] {
                    ::sth::sthCore::invoke stc::delete $pimconfig
                }
            }
        }
        unset argArray(-reset)
    }
    if {[info exists argArray(-intf_ip_prefix_length)]} {
        set argArray(-intf_ip_prefix_len) $argArray(-intf_ip_prefix_length)
        unset argArray(-intf_ip_prefix_length)
    }
    if {[info exists argArray(-gateway_intf_ip_addr)]} {
        # This is not a permanent fix. Instead, we need to set the IP interface
        # object's gateway address directly.
        set argArray(-neighbor_intf_ip_addr) $argArray(-gateway_intf_ip_addr)
        unset argArray(-gateway_intf_ip_addr)
    }
    if {![info exists argArray(-type)]} {
        set argArray(-type) "remote_rp"
    }

    if { [info exists argArray(-port_handle)] && ![info exists argArray(-handle)] && [info exists argArray(-intf_ip_addr)] } {
        # See if there is an existing device with this IP address.
        set handle [::wrapper::get_device_with_ip_new $argArray(-intf_ip_addr) $argArray(-port_handle)]

        if {"" != $handle} {
            # There is an existing device with this IP address. Clone it.
            array set cmdresult [stc::perform Clone -SrcList $handle]

            # Set the name of the device so that we can distiguish it. This is purely for debugging.
            ::sth::sthCore::invoke stc::config $cmdresult(-ReturnList) -name "router_pim"
            # Make sure PIM isn't already enabled on this device, otherwise, we'll get an exception.
            foreach pimrouterconfig [::sth::sthCore::invoke stc::get $cmdresult(-ReturnList) -children-PimRouterConfig] {
                ::sth::sthCore::invoke stc::delete $pimrouterconfig
            }
            set argArray(-handle) $cmdresult(-ReturnList)
            array unset argArray -port_handle
            set handleFlag 1
        }
    }

    if {[info exists argArray(-interface_handle)]} {
        if [regexp gre_object $argArray(-interface_handle)] {
            #set argArray(-tunnel_handle) [eval sth::emulation_gre_config [keylget gre_tunnel_list $argArray(-interface_handle)]]
            # if the interface_handle is a gre_objectX, replace it with its associated GRE router objects
            #set argArray(-interface_handle) [lindex [keylget hosts_from_gre_obj $argArray(-interface_handle)] 0]
            #set argArray(-interface_handle) [lindex [keylget gre_physical_router_per_port $argArray(-interface_handle)] 0]
            set argArray(-interface_handle) [keylget gre_objects_from_port $argArray(-interface_handle)]
        }

        # if the interface_handle is a list of hostX objects, replace it with the first one ????
        set argArray(-interface_handle) [lindex $argArray(-interface_handle) 0]

        set results {}
        keylset results handle $argArray(-interface_handle)
        keylset results handles {}
        keylset results status 0

        # Create PimRouterConfig
        set ret [::sth::sthCore::invoke stc::perform ProtocolCreateCommand -ParentList $argArray(-interface_handle) -CreateClassId PimRouterConfig]
        array set tempA $ret
        if [regexp successful $tempA(-Status)] {
            keylset results status 1
            keylset results handles $tempA(-ReturnList)
        }
        # The following arguments are not used
        # -count 1
        # -router_id 11.0.5.18

        return $results
    }
    if {![info exists argArray(-ip_version)]} {
        set argArray(-ip_version) 4
    }
    if {![info exists argArray(-link_local_intf_ip_addr)] && $argArray(-ip_version) != 4} {
        set argArray(-link_local_intf_ip_addr) [::spirent::get_next_link_local_intf_ip_addr]
    }

    if { [info exists argArray(-mode)] && $argArray(-mode) eq "delete"} {

        # If -handle is not specified, delete all of the PIM routers on the port.
        if { [info exists argArray(-handle)] } {
            set handlelist $argArray(-handle)
        } elseif { [info exists argArray(-port_handle)] } {
            # Reset all of the devices on this port.
            set handlelist [stc::get $argArray(-port_handle) -AffiliationPort-Sources]
        }

        foreach handle $handlelist {
            if { [info exists argArray(-handle)] } {
                set handleindex [lsearch -exact $argArray(-handle) $handle]
            } else {
                set handleindex -1
            }
            if { [stc::get $handle -name] eq "router_pim" && $handleindex == -1  } {
                # This host was for PIM only. Delete the entire thing.
                ::sth::sthCore::invoke stc::delete $handle
            } else {
                # This device was not originally created for PIM, or was specified by -handle.
                # Just delete the "PimRouterConfig" object if it exists.
                foreach pimconfig [stc::get $handle -children-PimRouterConfig] {
                    ::sth::sthCore::invoke stc::delete $pimconfig
                }
            }
        }

        keylset results status     1
        keylset results handle     $handlelist
        keylset results handles    $handlelist
        keylset results interfaces $handlelist

        return $results
    }

    set args [array get argArray]

    set cmdName "::sth::emulation_pim_config $args"
    set results [::spirent::process_cmd $cmdName]

    if {$handleFlag && [info exists tempArray(-gateway_intf_ip_addr)]} {
        set tempIpv4If [::sth::sthCore::invoke stc::get $argArray(-handle) -children-ipv4if]
        set handleGateway [::sth::sthCore::invoke stc::get $tempIpv4If -Gateway]
        if {![string equal -nocase $handleGateway $tempArray(-gateway_intf_ip_addr)]} {
            ::sth::sthCore::invoke stc::config $tempIpv4If -Gateway $tempArray(-gateway_intf_ip_addr)
        }
        unset tempIpv4If
        unset handleGateway
    }

    set pimRouterList ""
    set deviceList    ""
    set routerList [keylget results handle]
    foreach emulateddevice $routerList {
        lappend deviceList $emulateddevice
        foreach pimrouterconfig [::sth::sthCore::invoke stc::get $emulateddevice -children-PimRouterConfig] {
            lappend pimRouterList $pimrouterconfig
        }
        # Mark the device as PIM router. This will allow us to identify which devices need
        # to be deleted when the emulation_pim_config -reset flag is used.
        stc::config $emulateddevice -name "router_pim"
    }
    keylset results handles $pimRouterList
    keylset results interfaces $pimRouterList
    return $results
}

proc ::spirent::emulation_pim_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    array set argArray {}
    listToArray $args argArray

    if {[info exists argArray(-flap_interval)]} {
        unset argArray(-flap_interval)
    }
    if {[info exists argArray(-flap)]} {
        unset argArray(-flap)
    }
    if {![info exists argArray(-port_handle)] && [info exists argArray(-handle)]} {
        set argArray(-port_handle) [::sth::sthCore::invoke stc::get $argArray(-handle) -affiliationport-targets]
    }
    set args [array get argArray]

    set cmdName "::sth::emulation_pim_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_pim_group_config {args} {
    ######convert physical port
    array set argArray {}
    array set tempArray {}

    set args [eval ::spirent::port_converter $args]
    ::spirent::listToArray $args argArray
    if {[info exist argArray(-group_pool_mode)]} {
        set tempArray(-group_pool_mode) $argArray(-group_pool_mode)
    } else {
        set tempArray(-group_pool_mode) "send"
    }
    set errorHasOccurred [catch {
        # Assume -group_pool_mode == send
        # array unset argArray -group_pool_mode

        if {[info exists argArray(-join_prune_aggregation_factor)]} {
            if { $argArray(-join_prune_aggregation_factor) > 1 } {
                set enablepacking 1
            } else {
                set enablepacking 0
            }
            unset argArray(-join_prune_aggregation_factor)
        } elseif { [info exists argArray(-mode)] && [string match -nocase $argArray(-mode) "create"] } {
            set enablepacking 0
        }

        if { [info exists enablepacking] } {
            ::sth::sthCore::invoke ::sth::sthCore::invoke stc::config system1.project.PimGlobalConfig -EnablePackGroupRecord $enablepacking
        }

        if {[info exists argArray(-s_g_rpt_group)]} {
            set argArray(-wildcard_group) $argArray(-s_g_rpt_group)
            unset argArray(-s_g_rpt_group)
        }
        # If user not input parameter: source_pool_handle, the grouptype is STARSTARRP
        # If user input parameter: source_pool_handle and wildcard_group is 0, grouptype is SG
        # If user input parameter: source_pool_handle and wildcard_group is 1, grouptype is STARG
        #if {[info exists argArray(-rp_ip_addr)] && ![info exists argArray(-wildcard_group)]} {
        #   set argArray(-wildcard_group) 1
        #}
        if {[info exists argArray(-flap_interval)]} {
            unset argArray(-flap_interval)
        }
        if {[info exists argArray(-spt_switchover)]} {
            unset argArray(-spt_switchover)
        }
        
        if {[info exists argArray(-switch_over_interval)]} {
            unset argArray(-switch_over_interval)
        }
        if {[info exists argArray(-mode)] && $argArray(-mode) == "delete" && ![info exists argArray(-group_pool_handle)]} {
            if [info exists argArray(-handle)] {
                set argArray(-group_pool_handle) [::sth::sthCore::invoke stc::get $argArray(-handle) -joinedgroup-Targets]
            }
        }
        if {[info exists argArray(-mode)] && $argArray(-mode) == "create" && ![info exists argArray(-group_pool_handle)]} {
            if [info exists argArray(-handle)] {
                set argArray(-group_pool_handle) [::sth::sthCore::invoke stc::get $argArray(-handle) -joinedgroup-Targets]
            }
        }
        # HLTAPI 4.22 does not support -source_pool_handle; 4.30 does support
        if {[info exists argArray(-source_pool_handle)]} {
            #unset argArray(-source_pool_handle)
        }
        if {[info exists argArray(-mode)] && $argArray(-mode) == "clear_all"} {
            # -session_handle router1
            if [info exists argArray(-session_handle)] {
                foreach pimRouterConfig [::sth::sthCore::invoke stc::get $argArray(-session_handle) -children-pimrouterconfig] {
                    foreach pimV4group [::sth::sthCore::invoke stc::get $pimRouterConfig -children-pimv4groupblk] {
                        ::sth::sthCore::invoke stc::delete $pimV4group
                    }
                    foreach pimV4register [::sth::sthCore::invoke stc::get $pimRouterConfig -children-pimv4registerblk] {
                        ::sth::sthCore::invoke stc::delete $pimV4register
                    }
                }
                ::sth::sthCore::invoke stc::apply
            }
            set result ""
            keylset result status 1
        } else {
            set args [array get argArray]

            set cmdName "::sth::emulation_pim_group_config $args"
            set result [::spirent::process_cmd $cmdName]
            # ZL added for changing STARSTARRP to STARG
            if {[keylget result status] && [info exists argArray(-mode)] && $argArray(-mode) == "create" && ![info exists argArray(-source_pool_handle)]} {
                if [regexp "STARSTARRP" [::sth::sthCore::invoke stc::get [keylget result handle] -GroupType]] {
                    ::sth::sthCore::invoke stc::config [keylget result handle] -GroupType STARG
                    ::sth::sthCore::invoke stc::apply
                }
            }
            # ZL end
        }
    } errMsg]
    if {$errorHasOccurred} {
        keylset result status 0
        keylset result log $errMsg
    }
    return $result

}
proc ::spirent::emulation_pim_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_pim_info $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_ping {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_ping $args"
    array set argArray {}
    ::spirent::listToArray $args argArray

        if {[info exists argArray(-dst_portlist)] && [info exists argArray(-src_port)] } {

            set dstHostList [::::sth::sthCore::invoke stc::get $argArray(-dst_portlist) -affiliationport-Sources]
            if ![llength $dstHostList] {
                set result [::sth::interface_config -mode config -port_handle $argArray(-dst_portlist) -intf_mode ethernet -phy_mode $::spirent::phy_mode -intf_ip_addr $::spirent::dst_ip_addr -src_mac_addr $::spirent::dst_mac_addr -enable_ping_response 1]
                set dstHostList [::::sth::sthCore::invoke stc::get $argArray(-dst_portlist) -affiliationport-Sources]
            }
            #foreach host $dstHostList {
            #   ::::sth::sthCore::invoke stc::config $host -EnablePingResponse TRUE
            #}
            set dstHost [lindex $dstHostList 0]
            set dstHostIp [::sth::sthCore::invoke stc::get [::sth::sthCore::invoke stc::get $dstHost -children-ipv4if] -Address]

            set srcHostList [::::sth::sthCore::invoke stc::get $argArray(-src_port) -affiliationport-Sources]
            set srcHost [lindex $srcHostList 0]

            set count 5
            set rx 0
            while {$count > 0 && !$rx} {
                set result [::sth::emulation_ping -handle $srcHost -count 1 -host $dstHostIp]
                set rx [keylget result rx]
                # if rx is a empty string, set rx 0
                if ![regexp {[[:digit:]+]} $rx] { set rx 0}
                #puts $result
                incr count -1
            }

            keylset result rX $rx
            set tx [keylget result tx]
            keylset result tX $tx
            keyldel result rx
            keyldel result tx

            return $result
        }

    return [::spirent::process_cmd $cmdName]
}

##Not matched with ixia ptp
##Add by WestWang
proc ::spirent::emulation_ptp_config {args} {
    ######convert physical port
    array set argArray {}
    ::spirent::listToArray $args argArray
    if {[info exists argArray(-port_handle)]} {
        set port_arg "-port_handle $argArray(-port_handle)"
        unset argArray(-port_handle)
        set port_arg [eval ::spirent::port_converter $port_arg]
        set args "[array get argArray] $port_arg"
    }
    
    set cmdName "::sth::emulation_ptp_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_ptp_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_ptp_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_ptp_stats {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_ptp_stats $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_rip_config {args} {
    array set argArray {}
    ###### Calling this proc to set the empty values to 1. Ex : -reset
    set args [wrapper::shield_args -total $args]
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    
	::spirent::listToArray $args argArray
	
	array unset argArray -receive_type
	
	if {([info exist argArray(-send_type)] && "broadcast_v2" == $argArray(-send_type))} {
	   set argArray(-send_type) broadcast
    }
	
	if {[info exist argArray(-mac_address_init)]} {
	   set argArray(-mac_address_start) $argArray(-mac_address_init)
	   unset argArray(-mac_address_init)
    }
	
	
	if {(([info exist argArray(-mode)] && ("create" == $argArray(-mode))) && (([info exist argArray(-reset)]) && ("1" == $argArray(-reset))))} {
	    set port_handle $argArray(-port_handle)
        set devices [::sth::sthCore::invoke stc::get $port_handle -AffiliationPort-Sources]
        set rip_devices ""
        foreach device $devices {
            set rip_session [::sth::sthCore::invoke stc::get $device -children-RipRouterConfig]
            if {$rip_session != ""} {
                #this is a RIP router
                set rip_devices [concat $rip_devices $device]
                ::sth::sthCore::invoke stc::delete $rip_session
            }
        }
		unset argArray(-reset)
	}
	
	if {[info exist argArray(-mode)] && ("create" == $argArray(-mode))} {
        if { [info exists argArray(-port_handle)] && ! [info exists argArray(-handle)] \
                        && [info exists argArray(-intf_ip_addr)]} {
            set device [::wrapper::get_device_with_ip_new $argArray(-intf_ip_addr) \
                        $argArray(-port_handle)]
            if {$device != ""} {
                set argArray(-handle) $device
                array unset argArray -port_handle
            }
        }
	}

	set args [array get argArray]
    ##in case -vlan 0

    if {[lsearch $args "-vlan"] > -1} {
        set index [lsearch $args "-vlan"]
        set vlan [lindex $args [expr $index + 1]]
        set vlanArgList "vlan"
        if {$vlan == 0} {
            set vlanArgList "$vlanArgList vlan_id vlan_id_mode vlan_id_step vlan_user_priority"
        }
        set args [wrapper::shield_args -total $args -unsupported $vlanArgList]
    }
    
    set cmdName "::sth::emulation_rip_config $args"
    set return_list [::spirent::process_cmd $cmdName]
    if {[info exist argArray(-intf_ip_addr)]} {
        set intf_ip_addr $argArray(-intf_ip_addr)
        set ::spirent::ip_device($intf_ip_addr) [keylget return_list handle]
    }
    return $return_list
}
proc ::spirent::emulation_rip_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    ::spirent::listToArray $args argArray
    if {![info exist argArray(-handle)]} {
        set device_handle ""
        if {[info exist argArray(-advertise)]} {
            set device_handle [::sth::sthCore::invoke stc::get $argArray(-advertise) -parent]
            while {![regexp -nocase "^host|^router|^emulateddevice" $device_handle]} {
                set device_handle [::sth::sthCore::invoke stc::get $device_handle -parent]
            }
            set argArray(-handle) $device_handle
        } elseif {[info exist argArray(-port_handle)]} {
            set device_list [::sth::sthCore::invoke stc::get $argArray(-port_handle) -AffiliationPort-Sources]
            foreach device $device_list {
                set riprtrcfg [::sth::sthCore::invoke stc::get $device -children-RipRouterConfig]
                if {$riprtrcfg != ""} {
                    lappend device_handle $device
                }
            }
        }
    }
    set args [array get argArray]
    set cmdName "::sth::emulation_rip_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_rip_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_rip_info $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_rip_route_config {args} {
    array set argArray {}
    ###### Calling this proc to set the empty values to 1. Ex : -reset
    set args [wrapper::shield_args -total $args]
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    
	::spirent::listToArray $args argArray
	
	if {(([info exist argArray(-mode)] && ("create" == $argArray(-mode))) && (([info exist argArray(-reset)]) && ("1" == $argArray(-reset))))} {
        set rip_session [::sth::sthCore::invoke stc::get $argArray(-handle) -children-RipRouterConfig]
	    set rip_routes [::sth::sthCore::invoke stc::get $rip_session -children-ripv4routeparams]
        if {$rip_routes != ""} {
                #this is a RIP router
                set rip_devices [concat $rip_routes $device]
                ::sth::sthCore::invoke stc::delete $rip_routes
        }
        unset argArray(-reset)
	}
	
	set args [array get argArray]
	
	set cmdName "::sth::emulation_rip_route_config $args"
    return [::spirent::process_cmd $cmdName]
}

proc ::spirent::emulation_rsvp_config {args} {

    ################################################
    ##
    ## step 1: set variables
    ## step 2: convert args vlaues to STC style
    ## step 3: Unset variables which is not is STC
    ## step 4: set manual variables values
    ## step 5: Execute and return
    ##
    ################################################

    #########################
    ## step 1: set variables
    #########################

    global return_list
    array set argArray {}

    ############################################
    ## step 2: convert args values to STC style
    ############################################
    
    ## convert physical port
    set args [eval ::spirent::port_converter $args]
    ## List to Array
    ::spirent::listToArray $args argArray

    ###############################################
    ## step 3: Unset variables which is not is STC
    ###############################################
    
    catch {unset argArray(-ip_version)}
    catch {unset argArray(-actual_restart_time)}
    catch {unset argArray(-bundle_msg_sending)}
    catch {unset argArray(-graceful_restart_helper_mode)}
    
    if {[info exist argArray(-vlan)] && ( $argArray(-vlan) == 0)} {
        array unset argArray -vlan_id
        array unset argArray -vlan_id_step
        array unset argArray -vlan_id_mode
        array unset argArray -vlan_user_priority
    }
    array unset argArray -vlan
    
    catch {unset argArray(-graceful_restart_start_time)}
    catch {unset argArray(-graceful_restart_up_time)}
    catch {unset argArray(-graceful_restarts_count)}
    catch {unset argArray(-hello_retry_count)}
    catch {unset argArray(-resv_state_refresh_timeout)}
    catch {unset argArray(-resv_state_timeout_count)}
    catch {unset argArray(-path_state_refresh_timeout)}
    catch {unset argArray(-path_state_timeout_count)}

    #######################################
    ## step 4: set manual variables values
    #######################################
    
    if {[info exist argArray(-graceful_restart_recovery_time)] && $argArray(-graceful_restart_recovery_time) > 65535} {
        unset argArray(-graceful_restart_recovery_time)
    }
    
    if {[info exist argArray(-graceful_restart_restart_time)] && $argArray(-graceful_restart_restart_time) > 65535} {
        unset argArray(-graceful_restart_restart_time)
    }

    ##############################
    ## step 5: Execute and return
    ##############################
    
    set args [array get argArray]
    set cmdName "::sth::emulation_rsvp_config $args"
    set return_list [::spirent::process_cmd $cmdName]
    return $return_list
}
proc ::spirent::emulation_rsvp_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_rsvp_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_rsvp_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_rsvp_info $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_rsvp_tunnel_config {args} {

    ################################################
    ##
    ## step 1: set variables
    ## step 2: convert args vlaues to STC style
    ## step 3: Unset variables which is not is STC
    ## step 4: set manual variables values
    ## step 5: Execute and return
    ##
    ################################################

    #########################
    ## step 1: set variables
    #########################

    global return_list
    array set argArray {}
    
    ############################################
    ## step 2: convert args values to STC style
    ############################################
    
    ## convert physical port
    set args [eval ::spirent::port_converter $args]
    ## List to Array
    ::spirent::listToArray $args argArray

    ###############################################
    ## step 3: Unset variables which is not is STC
    ###############################################
    
    catch {unset argArray(-ingress_enable_interface_creation)}
    catch {unset argArray(-emulation_type)}
    catch {unset argArray(-enable_append_connected_ip)}
    catch {unset argArray(-enable_prepend_tunnel_head_ip)}
    catch {unset argArray(-enable_prepend_tunnel_leaf_ip)}
    catch {unset argArray(-enable_send_as_rro)}
    catch {unset argArray(-enable_send_as_srro)}
    catch {unset argArray(-ingress_bandwidth)}
    catch {unset argArray(-ingress_ip_count)}
    catch {unset argArray(-lsp_id_start)}
    catch {unset argArray(-path_tear_tlv)}
    catch {unset argArray(-path_tlv)}
    catch {unset argArray(-no_write)}
    catch {unset argArray(-egress_behavior)}
    catch {unset argArray(-reservation_style)}
    catch {unset argArray(-record_route)}
    catch {unset argArray(-egress_ip_count)}

    #######################################
    ## step 4: set manual variables values
    #######################################
    
    if {[info exist argArray(-fast_reroute_holding_priority)] && $argArray(-fast_reroute_holding_priority) > 7} {
        unset argArray(-fast_reroute_holding_priority)
    }
    
    if {[info exist argArray(-fast_reroute_setup_priority)] && $argArray(-fast_reroute_setup_priority) > 7} {
        unset argArray(-fast_reroute_setup_priority)
    }
    
    if {[info exist argArray(-session_attr_hold_priority)] && $argArray(-session_attr_hold_priority) > 7} {
        unset argArray(-session_attr_hold_priority)
    }
    
    if {[info exist argArray(-session_attr_setup_priority)] && $argArray(-session_attr_setup_priority) > 7} {
        unset argArray(-session_attr_setup_priority)
    }
    
    if {[info exist argArray(-tunnel_id_count)]} {
        set argArray(-tunnel_count) $argArray(-tunnel_id_count)
        unset argArray(-tunnel_id_count)
    }
    
    if {[info exist argArray(-tunnel_id_count)]} {
        set argArray(-tunnel_count) $argArray(-tunnel_id_count)
        unset argArray(-tunnel_id_count)
    }
    
    ##############################
    ## step 5: Execute and return
    ##############################
    
    set args [array get argArray]
    set cmdName "::sth::emulation_rsvp_tunnel_config $args"
    set return_list [::spirent::process_cmd $cmdName]
    return $return_list
}
proc ::spirent::emulation_rsvp_tunnel_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_rsvp_tunnel_info $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_rsvpte_tunnel_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_rsvpte_tunnel_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_sip_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_sip_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_sip_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_sip_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_sip_stats {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_sip_stats $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_vpls_site_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_vpls_site_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_mpls_tp_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_mpls_tp_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_mpls_tp_port_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_mpls_tp_port_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_mpls_tp_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_mpls_tp_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_lsp_ping_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_lsp_ping_info $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_dot1x_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_dot1x_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_dot1x_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_dot1x_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_dot1x_stats {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_dot1x_stats $args"
    return [::spirent::process_cmd $cmdName]
}

##Not matched ixia HLTAPI and not handle -vlan 0 here
##add by WestWang
proc ::spirent::emulation_stp_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_stp_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_mstp_region_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_mstp_region_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_msti_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_msti_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_stp_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_stp_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_stp_stats {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_stp_stats $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::fc_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::fc_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::fc_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::fc_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::fc_stats {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::fc_stats $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::fcoe_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::fcoe_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::fcoe_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::fcoe_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::fcoe_stats {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::fcoe_stats $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::fcoe_traffic_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    ::spirent::listToArray $args argArray
    set streamlist ""
    if {[info exists argArray(-handle)]} {
        foreach streamid $argArray(-handle) {
            if {[regexp -nocase "streamblock" $streamid]} {
                lappend streamlist $streamid
            } else {
                lappend streamlist "streamblock$streamid"
            }
        }
        set argArray(-handle) $streamlist
    }
    set args [array get argArray]
    set cmdName "::sth::fcoe_traffic_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::fip_traffic_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    ::spirent::listToArray $args argArray
    set streamlist ""
    if {[info exists argArray(-handle)]} {
        foreach streamid $argArray(-handle) {
            if {[regexp -nocase "streamblock" $streamid]} {
                lappend streamlist $streamid
            } else {
                lappend streamlist "streamblock$streamid"
            }
        }
        set argArray(-handle) $streamlist
    }
    set args [array get argArray]
    set cmdName "::sth::fip_traffic_config $args"
    return [::spirent::process_cmd $cmdName]
}

proc ::spirent::l2tp_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::l2tp_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::l2tp_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::l2tp_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::l2tp_stats {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::l2tp_stats $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::labserver_connect {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::labserver_connect $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::labserver_disconnect {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::labserver_disconnect $args"
    return [::spirent::process_cmd $cmdName]
}

proc ::spirent::packet_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::packet_info $args"
    return [::spirent::process_cmd $cmdName]
}

proc ::spirent::ppp_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::ppp_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::ppp_stats {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::ppp_stats $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::pppox_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
	array set argArray {}
    ::spirent::listToArray $args argArray
	
	array unset argArray -device_type
	
	if {[info exist argArray(-max_negotiation_retrys)]} {
	   set argArray(-max_auto_retry_count) $argArray(-max_negotiation_retrys)
	   unset argArray(-max_negotiation_retrys)
	}
	
	if {[info exist argArray(-max_lcp_failure)]} {
	   set argArray(-max_configure_req) $argArray(-max_lcp_failure)
	   unset argArray(-max_lcp_failure)
	}
	
	if {[info exist argArray(-ppp_local_ip)]} {
	   set argArray(-intf_ip_addr) $argArray(-ppp_local_ip)
	   unset argArray(-ppp_local_ip)
	}
	
	set args [array get argArray]
	set cmdName "::sth::pppox_config $args"
    return [::spirent::process_cmd $cmdName]
}

proc ::spirent::pppox_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    array set argArray {}
    ::spirent::listToArray $args argArray
    set pppclientblockconfig ""
    foreach handle $argArray(-handle) {
        lappend pppclientblockconfig [::sth::sthCore::invoke stc::get $handle -children-pppoeclientblockconfig]
    }
    if { $pppclientblockconfig ne "" } {
        foreach pppclientblkconfig $pppclientblockconfig { 
	
            if {[info exist argArray(-action)]} {
                if {$argArray(-action) eq "disable"} {
                    if {![catch {::sth::sthCore::invoke stc::config $pppclientblkconfig -active false} errmsg]} {
                        keylset retKeyedList status 1
                        keylset retKeyedList log {}
                    } else {
                        keylset retKeyedList status 0
                        keylset retKeyedList log $errmsg
                    }
                    return $retKeyedList
                } elseif {$argArray(-action) eq "enable"} {
                    if {![catch {::sth::sthCore::invoke stc::config $pppclientblkconfig -active true} errmsg]} {
                        keylset retKeyedList status 1
                        keylset retKeyedList log {}
                    } else {
                        keylset retKeyedList status 0
                        keylset retKeyedList log $errmsg
                    }
                    return $retKeyedList
                }
            }
        }
    }
    set args [array get argArray]
    set cmdName "::sth::pppox_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::pppox_server_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::pppox_server_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::pppox_server_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::pppox_server_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::pppox_server_stats {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::pppox_server_stats $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::pppox_stats {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::pppox_stats $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::test_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::test_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::test_control {args} {
    ######convert physical port
	if {([lsearch $args "-action"] > -1)} {
	    set action [lindex $args [expr {[lsearch $args "-action"] + 1}]]
        #HLTAPI Debug Function
		if {[regexp -nocase {enable} $action] || [regexp -nocase {disable} $action] || [regexp -nocase {sync} $action]} {
			set args [eval ::spirent::port_converter $args]
		    set cmdName "::sth::test_control $args"
		    return [::spirent::process_cmd $cmdName]
		} else {
			    #ixia::test_control
			    ##only handle start_all_protocols|stop_all_protocols for the time being
                switch -- $action {
                    start_protocol -
                    start_all_protocols {
                        return [::sth::start_devices]
                    }
                    stop_protocol -
                    stop_all_protocols {
                    return [::sth::stop_devices]
                    }
                    default {
                        puts "action $action is not supported in ::ixia::test_control yet\n"
					}
                }
            }
	}
	puts "Argument action is necessary! \n "
}
proc ::spirent::test_rfc2544_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    ::spirent::listToArray $args argArray
    set streamlist ""
    if {[info exists argArray(-streamblock_handle)]} {
        foreach streamid $argArray(-streamblock_handle) {
            if {[regexp -nocase "streamblock" $streamid]} {
                lappend streamlist $streamid
            } else {
                lappend streamlist "streamblock$streamid"
            }
        }
        set argArray(-streamblock_handle) $streamlist
    }
    set args [array get argArray]
    set cmdName "::sth::test_rfc2544_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::test_rfc2544_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::test_rfc2544_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::test_rfc2544_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::test_rfc2544_info $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::test_rfc3918_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    ::spirent::listToArray $args argArray
    set streamlist ""
    if {[info exists argArray(-multicast_streamblock)]} {
        foreach streamid $argArray(-multicast_streamblock) {
            if {[regexp -nocase "streamblock" $streamid]} {
                lappend streamlist $streamid
            } else {
                lappend streamlist "streamblock$streamid"
            }
        }
        set argArray(-multicast_streamblock) $streamlist
    }
    set streamlist ""
    if {[info exists argArray(-unicast_streamblock)]} {
        foreach streamid $argArray(-unicast_streamblock) {
            if {[regexp -nocase "streamblock" $streamid]} {
                lappend streamlist $streamid
            } else {
                lappend streamlist "streamblock$streamid"
            }
        }
        set argArray(-unicast_streamblock) $streamlist
    }
    set args [array get argArray]
    set cmdName "::sth::test_rfc3918_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::test_rfc3918_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::test_rfc3918_control $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::test_rfc3918_info {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::test_rfc3918_info $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_device_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "::sth::emulation_device_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::get_power_of_two {n} {
    if {$n < 1} {
        return $n
    } elseif {$n==1} {
        return 1
    } else    {
        return [expr 2 * [::spirent::get_power_of_two [expr $n/2]]]
    }
}
proc ::spirent::add_ip_router_alert {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    #-stream_id sId -ip_router_alert value
    array set myArray $args
    set ipStack [::sth::sthCore::invoke stc::get $myArray(-stream_id) -children-ipv4:ipv4]
    set optionObj [::sth::sthCore::invoke stc::get $ipStack -children-options]
    set ipv4headeroptionObj [::sth::sthCore::invoke stc::create ipv4headeroption -under $optionObj]
    set rtralertObj [::sth::sthCore::invoke stc::create rtralert -under $ipv4headeroptionObj]
    ::sth::sthCore::invoke stc::config $rtralertObj -routerAlert $myArray(-ip_router_alert)
}
proc ::spirent::add_l4_protocol_pim_hello {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    #-stream_id sId
    ::spirent::listToArray $args myArray
#    array set myArray $args
    ::sth::sthCore::invoke stc::create pim:Pimv4Hello -under $myArray(-stream_id)
}

proc ::spirent::emulation_igmp_querier_config {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    array set argArray {}
    ::spirent::listToArray $args argArray

        if {[info exists argArray(-device_type)]} {
            unset argArray(-device_type)
        }
        if {[info exists argArray(-igmp_querier_type)]} {
            set argArray(-igmp_version) $argArray(-igmp_querier_type)
            unset argArray(-igmp_querier_type)
        }
        set args [array get argArray]


    set cmdName "::sth::emulation_igmp_querier_config $args"
    return [::spirent::process_cmd $cmdName]
}
proc ::spirent::emulation_igmp_querier_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    array set argArray {}
    listToArray $args argArray

        if {[info exists argArray(-query_type)]} {
            unset argArray(-query_type)
        }
        if {[info exists argArray(-action)]} {
            if {$argArray(-action) == "add_query"} {
                return [list [list status 1]]
            }
            if {$argArray(-action) == "start_query" || $argArray(-action) == "start"} {
                unset argArray(-action)
                set argArray(-mode) "start"
            }
            if {[info exists argArray(-action)] && $argArray(-action) == "stop"} {
                unset argArray(-action)
                set argArray(-mode) "stop"
            }
        }
        set args [array get argArray]


    set cmdName "::sth::emulation_igmp_querier_control $args"
    return [::spirent::process_cmd $cmdName]
}

# Help procs start
proc ::spirent::next_traffic_profile {} {
    variable profile_counter
    incr profile_counter
    return profile$profile_counter
}

proc ::spirent::create_traffic_profile {port} {
    variable profile
    set a_profile [::spirent::next_traffic_profile]
    set profile(port,$a_profile) $port
    if ![info exists profile(profiles,$port)] {
        set profile(profiles,$port) $a_profile
    } else {
        set profile(profiles,$port) [concat $profile(profiles,$port) $a_profile]
    }
    return $a_profile
}

proc ::spirent::add_streamblock {a_profile a_streamblock} {
    variable profile
    if ![info exists profile(streamblocks,$a_profile)] {
        set profile(streamblocks,$a_profile) $a_streamblock
    } else {
        set profile(streamblocks,$a_profile) [concat $profile(streamblocks,$a_profile) $a_streamblock]
    }
    return $profile(streamblocks,$a_profile)
}

proc ::spirent::get_port_from_profile {a_profile} {
    variable profile

    if ![info exists profile(port,$a_profile)] {
        return ""
    }
    return $profile(port,$a_profile)
}

proc ::spirent::get_profile_from_port {port} {
    variable profile
    if ![info exists profile(profiles,$port)] {
        return ""
    }
    return $profile(profiles,$port)
}

proc ::spirent::get_streamblock_from_profile {a_profile} {
    variable profile
    if ![info exists profile(streamblocks,$a_profile)] {
        return ""
    }
    return $profile(streamblocks,$a_profile)
}


#shim layer used to make Cisco script writen in IXIA or Agilent HLTAPI can run with STC.

#it mainly include two parts:
# 1. convert the namespace (::spirent:: or Agilent:: to sth::)
# 2. shield the options which hltapi can support

#need to enhance: the the option which is mandtory in the procedure, need to be added.


namespace eval ::AgtTest:: {

}

namespace eval ::ixia:: {

}

array set port_convert {}
array set port_spirent_ixia_agt {}

proc ::spirent::port_converter { args } {
    set processed_args $args
    variable port_convert
    set args_to_convert "port_handle port_handle2 src_port dst_portlist dest_port_list"
    foreach arg_to_convert $args_to_convert {
        if {[lsearch $args "-$arg_to_convert"] > -1} {
            set port_list [::wrapper::get_value_list $args "-$arg_to_convert"]
            set port_logical_handle ""
            foreach port $port_list {

              if {[regexp "/" $port]} {
	      	if {[regexp {[0-9]*\/([0-9]*)\/([0-9]*)$} $port _ slot_val port_val]} {
                	set port $slot_val/$port_val
                }
                    set port_logical_handle "$port_logical_handle $port_convert($port)"
                } else {
                    set port_logical_handle "$port_logical_handle $port"
                }
            }
            set processed_args [wrapper::shield_args -total $processed_args -unsupported $arg_to_convert]
            set processed_args "-$arg_to_convert $port_logical_handle $processed_args"
        }
    }
    return $processed_args
}

proc ::spirent::ret_port_converter {ret {type {}}} {
    set new_ret $ret
    variable port_spirent_ixia_agt
    set port_list [array name port_spirent_ixia_agt]
    foreach port $port_list {
        switch $type {
            AgtTest {
                set tempValue $port_spirent_ixia_agt($port)
                set tempList [split $tempValue /]
                if {3 == [llength $tempList]} {
                    set tempValue "[lindex $tempList 1]/[lindex $tempList 2]"
                }
                regsub -all $port $new_ret $tempValue new_ret
            }
            ixia {
                set tempValue $port_spirent_ixia_agt($port)
                set tempList [split $tempValue /]
                if {2 == [llength $tempList]} {
                    set tempValue "1/[lindex $tempList 0]/[lindex $tempList 1]"
                }
                regsub -all $port $new_ret $tempValue new_ret
            }
            default {regsub -all $port $new_ret $port_spirent_ixia_agt($port) new_ret}
        }
    }
    return $new_ret
}

proc ::spirent::connect { args } {
    #remove the options which can't be supported in spirent hltapi
    #ixia::
    #agilent:: -intf_mode -mode
    variable port_convert
    variable port_spirent_ixia_agt
    #convert username bgp-nsr into bgp_nsr
    regsub -all -nocase -- "bgp-nsr"  $args "bgp_nsr" args
    # Determine the namespace of the original command.
    set parentnamespace ""
    set procedure       [info level 0]
    regexp -nocase {:*([a-z]+)::} $procedure -> parentnamespace
    global return_list
    array set argArray {}

    set args [wrapper::shield_args -total $args]
    ::spirent::listToArray $args argArray
    ## if port_list is in format x/x/x i.e. 1/2/5 then
    ##strip port list to slot/port format.
    if { [info exists argArray(-port_list)] } {
        set portList ""
        foreach tmp $argArray(-port_list) {
            if {[regexp {[0-9]*\/([0-9]*)\/([0-9]*)$} $tmp _ slot port]} {
                lappend portList $slot/$port
            } else {
                lappend portList $tmp
            }
        }
        set argArray(-port_list) $portList
    }
    set args [array get argArray]
    # MGJ: The following code is used to make sure we load the correct version of Spirent TestCenter
    #      and HLTAPI. The new "-no_version_discovery" attribute is optional, and defaults to 0, which
    #      means that the code WILL attempt to connect to the chassis and discover its version BEFORE
    #      loading Spirent TestCenter API.
    # The libraries haven't been loaded yet. Attempt to load them now.
    # If this load fails, all other commands are going to fail as well.
    # There is a new attribute (-no_version_discovery) that needs to be set
    # if you do NOT want to automatically discover the chassis version.

    if { [info exists argArray(-device)] && ( ! [info exist argArray(-no_version_discovery)] || ! $argArray(-no_version_discovery) ) } {
        # Discover the chassis version and load the appropriate API version.
        set result [::spirent::init -chassisip [lindex $argArray(-device) 0] -port [lindex $argArray(-port_list) 0]]
    } else {
        # Just load the latest versions of the APIs.
        set result [::spirent::init]
    }

    if { $::spirent::enable_debug && ! [info exists ::spirent::connect_has_been_called] } {
        set ::spirent::connect_has_been_called 1

        if { [info exists ::env(EASY_BASEDIR)] } {
             set timestamp [clock format [clock scan now] -format {%Y-%m-%d-%H-%M-%S}]
             set hltname [file join $::env(EASY_BASEDIR) HLT$timestamp]
        } else {
             set hltname "HLT_[clock format [clock scan now] -format {%Y-%m-%d-%H-%M-%S}]"
        }
        set hltapi_log_file_prefix $hltname
        ::sth::test_config  -logfile            "[set hltapi_log_file_prefix]_hltLogfile" \
                            -log                1 \
                            -vendorlogfile      "[set hltapi_log_file_prefix]_stcExport" \
                            -vendorlog          1 \
                            -hltlog             1 \
                            -hltlogfile         "[set hltapi_log_file_prefix]_hltExport" \
                            -hlt2stcmappingfile "[set hltapi_log_file_prefix]_hlt2StcMapping" \
                            -hlt2stcmapping     1 \
                            -log_level          7
    }

    array unset argArray -intf_mode
    array unset argArray -ixnetwork_tcl_server
    array unset argArray -mode
    array unset argArray -remove_streams
    array unset argArray -tcl_server
    array unset argArray -tgen_type
    array unset argArray -tool_version
    array unset argArray -master_device
    # Loop for setting the break_locks arg value
    if { [string match -nocase $parentnamespace "AgtTest"] } {
        # By default we are setting break_locks as 1 in N2X.
        set argArray(-break_locks) 1
    } elseif { [string match -nocase $parentnamespace "ixia"] } {
        if {![info exist argArray(-break_locks)]} {
            # Default value for break_locks in IXIA is 1
            set argArray(-break_locks) 1
        }
    }
    if {[info exist argArray(-tgen_reset)]} {
        set argArray(-reset) $argArray(-tgen_reset)
        unset argArray(-tgen_reset)
    }
    #need to process the 'reset', for the ixia, the reset will delete the device and the stream on the give port_list.
    #and our hltapi, will delete all the streams in the system and the delete the port in the give port_list. need to keep same with ixia.
    #if there is no port creaetd then remove the reset

    set port_list $argArray(-port_list)
    set device [lindex $argArray(-device) 0]
    set port_list_to_create ""
    set port_list_to_reset ""
    array set port_created_handles ""
    set connect_status_old ""
    set connect_status_new ""
    if {[info exist argArray(-reset)]} {
        if {[info exists ::sth::Session::PORTHNDLIST]} {
            foreach {key value} [array get ::sth::Session::PORTHNDLIST] {
                set device_connected [lindex [split $value "\/"] 0]
                set port [join "[lindex [split $value "\/"] 1] [lindex [split $value "\/"] 2]" "/"]
                if {$device_connected == $device && [lsearch $port_list $port] > -1} {
                    set port_list_to_reset [concat $port_list_to_reset $port]
                    set port_created_handles($port) $key
                }
            }
        }

    }
    if {[info exist argArray(-connect_timeout)]} {
        set argArray(-timeout) $argArray(-connect_timeout)
        unset argArray(-connect_timeout)
    }
    if {![info exist argArray(-timeout)]} {
        set argArray(-timeout) 300
    }

    keylset connect_status status 1
    if {[info exist argArray(-offline)] && $argArray(-offline)} {
        keylset connect_status offline 1
    } else {
        keylset connect_status offline 0
    }

    #do the reset for these port
    if {$port_list_to_reset != ""} {
        foreach port $port_list_to_reset {
            set created_devices [::sth::sthCore::invoke stc::get $port_created_handles($port) -AffiliationPort-Sources]
            foreach created_device $created_devices {
                ::sth::sthCore::invoke stc::delete $created_device
            }
            set streamblocks [::sth::sthCore::invoke stc::get $port_created_handles($port) -children-streamblock]
            foreach streamblock $streamblocks {
                ::sth::sthCore::invoke stc::delete $streamblock
            }
            keylset connect_status_old port_handle.$device.$port $port_created_handles($port)
        }
    }
    #if there is port need to be creaetd, then call the function directly
    if {[llength $port_list] != [llength $port_list_to_reset]} {
        foreach port $port_list {
            if {[lsearch $port_list_to_reset $port] < 0} {
                set port_list_to_create [concat $port_list_to_create $port]
            }
        }
        set argArray(-port_list) $port_list_to_create
        array unset argArray -reset
        #all the same function whose name space is sth::
        set tempArgs [array get argArray]
        set cmdName "::sth::connect $tempArgs"
        set connect_status_new [::spirent::process_cmd $cmdName]
    }

    ######concat the old connect_status and new connect together

    foreach port_loc $port_list {
        set flag 1
        if {$connect_status_old !="" } {
            set port_old [keylkeys connect_status_old port_handle.$device]
            set num [llength $port_old]
            foreach port_connect $port_old {
                if {[string equal $port_loc $port_connect ]} {
                    set flag 0
                    keylset connect_status port_handle.$device.$port_loc [keylget connect_status_old port_handle.$device.$port_loc]
                    break
                }
            }
        }
        if {$flag==1 && $connect_status_new !=""} {
            keylset connect_status port_handle.$device.$port_loc [keylget connect_status_new port_handle.$device.$port_loc]
        }
    }



    #need to do later:: merge the port reseted and the port created and then return

    keylset connect_status connection_handle "unused"
    keylset connect_status port_handles "unused"


    ####save the mapping in port_convert, port_list and device
    foreach port_loc $port_list {
        set port_convert($port_loc) [keylget connect_status port_handle.$device.$port_loc]
        # Change the port handles to match Ixia or Agilent's location format (1/2/3 or 1/2).
        switch -- [string tolower $parentnamespace] {
            "agttest" {
                # 2-octet location
                keylset connect_status port_handle.$device.$port_loc $port_loc
                set port_spirent_ixia_agt($port_convert($port_loc))  $port_loc
            }
            "ixia" {
                # 3-octet location
                keylset connect_status port_handle.$device.$port_loc "1/$port_loc"
                set port_spirent_ixia_agt($port_convert($port_loc))  "1/$port_loc"
            }
        }
    }
    # The following code makes it possible to clear stats while traffic is "running".
    # In reality, the generators are stopped, results are cleared and then the
    # generators are restarted. The whole process probably takes under two seconds.
    ::sth::sthCore::invoke stc::config system1.project.resultoptions -StopTrafficBeforeClearingResults TRUE
    
    ##enable system ARPND cache
    if {[regexp -nocase UseLinklayerCacheInStack [stc::get [stc::get project1 -children-arpndconfig]]]} {
        stc::config [stc::get project1 -children-arpndconfig] -UseLinklayerCacheInStack true
    }

    ::sth::sthCore::invoke stc::apply
    
    ##save the module type
    set SiglePort [lindex [stc::get project1 -children-port] 0]
    if {[catch {set module_model [stc::get [stc::get [stc::get [stc::get $SiglePort -physicallogical-Sources] -parent] -parent] -model]} Err]} {
        puts "Warning: can't get the model info for current test module.$Err"
    } else {
        if {[regexp -nocase "DX" $module_model]} {
            set ::spirent::module_type  "DX"
        }
        if {[regexp -nocase "FX" $module_model]} {
            set ::spirent::module_type  "FX"
        }
    }
    if {[catch {set module_model [stc::get [stc::get [stc::get [stc::get [stc::get $SiglePort -physicallogical-Sources] -parent] -parent] -parent] -PartNum]} Err]} {
        puts "Warning: can't get the model info for current test module.$Err"
    } else {
        if {[regexp -nocase "ANYWHERE|QEMU|VIRTUAL" $module_model]} {
            set ::spirent::module_type  "STCV"
        }
    }
              
    ##
    set return_list $connect_status
    return $connect_status
}

proc ::spirent::get_port_list_from_connect {connect_status chassis portlist} {
    set port_handle_list ""
    foreach port $portlist {
        lappend port_handle_list \
            [keylget connect_status port_handle.$chassis.$port]
    }
    return $port_handle_list
}

proc ::spirent::packet_config_buffers {args} {
    #remove -capture_mode
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set ixia_only_args "capture_mode data_plane_capture_enable control_plane_capture_enable control_plane_filter_pcap control_plane_trigger_pcap"
    set processed_args [wrapper::shield_args -total $args -unsupported $ixia_only_args]
    if {[lsearch $processed_args "-action"] > -1} {
        set cmdName "sth::packet_config_buffers $processed_args"
    } else {
        set cmdName "sth::packet_config_buffers $processed_args -action wrap"
    }
    return [::spirent::process_cmd $cmdName]
}

proc ::spirent::packet_config_filter {args} {
    set ixia_only_args ""
    ###for Agilent
    set parentnamespace ""
    set procedure       [info level 1]
    regexp -nocase {:*([a-z]+)::} $procedure -> parentnamespace
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    ##converting args to arrays for agilent.
    array set argArray {}
    ::spirent::listToArray $args argArray

	if { [string match -nocase $parentnamespace "AgtTest"] } {
	    if {[info exist argArray(-filter_list)]} {
            set argArray(-filter) $argArray(-filter_list)
            unset argArray(-filter_list)
            if {$argArray(-filter) == "sa" || $argArray(-filter) == "da" || $argArray(-filter) == "sa da"} {
                set cap [::sth::sthCore::invoke stc::get $argArray(-port_handle) -children-capture]
                set capfil1 [::sth::sthCore::invoke stc::get $cap -children-capturefilter]
        
                if {$argArray(-filter) == "sa"} {
                    if {[catch {::sth::sthCore::invoke stc::create captureanalyzerfilter -under $capfil1 -IsSelected "TRUE" \
                                -FilterDescription {$argArray(-protocol) Header:Source} -ValueToBeMatched $argArray(-src_addr) \
                                -RelationToNextFilter "AND"} sacapanafilt]} {
                        keylset retKeyedList status 0
                        keylset retKeyedList log $sacapanafilt
                    } else {
                        keylset retKeyedList status 1
                        keylset retKeyedList log {}
                        keylset retKeyedList fm_handles $capfil1
                    }
                } elseif {$argArray(-filter) == "da"} {
                    if {[catch {::sth::sthCore::invoke stc::create captureanalyzerfilter -under $capfil1 -IsSelected "TRUE" \
                                -FilterDescription {$argArray(-protocol) Header:Destination} -ValueToBeMatched $argArray(-dst_addr) \
                                -RelationToNextFilter "AND"} dacapanafilt]} {
                        keylset retKeyedList status 0
                        keylset retKeyedList log $dacapanafilt
                    } else {
                        keylset retKeyedList status 1
                        keylset retKeyedList log {}
                        keylset retKeyedList fm_handles $capfil1
                    }
                } elseif {$argArray(-filter) == "sa da"} {
                    if {[catch {::sth::sthCore::invoke stc::create captureanalyzerfilter -under $capfil1 -IsSelected "TRUE" \
                                -FilterDescription {$argArray(-protocol) Header:Destination} -ValueToBeMatched $argArray(-dst_addr) \
                                -RelationToNextFilter "AND"} dacapanafilt] && [catch {::sth::sthCore::invoke stc::create \
                                captureanalyzerfilter -under $capfil1 -IsSelected "TRUE" -FilterDescription \
                                {$argArray(-protocol) Header:Source} -ValueToBeMatched $argArray(-src_addr) \
                                -RelationToNextFilter "AND"} sacapanafilt]} {
                        keylset retKeyedList status 0
                        keylset retKeyedList log "$dacapanafilt $sacapanafilt"
                    } else {
                        keylset retKeyedList status 1
                        keylset retKeyedList log {}
                        keylset retKeyedList fm_handles $capfil1
                    }
                }
                return $retKeyedList
            }
		}
		
        if {[info exist argArray(-action)]} {
            if {$argArray(-action) eq "store"} {
               set argArray(-mode) add
            } elseif {$argArray(-action) eq "discard"} {
               set argArray(-mode) remove
            }
            unset argArray(-action)
        }
		
        set args [array get argArray]
        set cmdName "::sth::packet_config_filter $args"
        set retKeyedList [::spirent::process_cmd $cmdName]
        set return_list $retKeyedList
        return $retKeyedList
    }
	
    if { [string match -nocase $parentnamespace "ixia"] } {
        
        set Capture [::sth::sthCore::invoke stc::get $argArray(-port_handle) -children-capture]
        set CaptureFilter [::sth::sthCore::invoke stc::get $Capture -children-capturefilter]
                    
        if {[info exists argArray(-SA1)]} {
                set argArray(-src_mac1) $argArray(-SA1)
                unset argArray(-SA1)
                 if {[catch {::sth::sthCore::invoke stc::create "CaptureAnalyzerFilter" \
            -under $CaptureFilter \
            -IsSelected "TRUE" \
            -FilterDescription {EthernetII:Source MAC} \
            -ValueToBeMatched {$-src_mac1} \
            -Value "" \
            -Mask "" \
            -FrameConfig {<frame><config><pdus><pdu name="eth1" pdu="ethernet:EthernetII"><srcMac>"$-src_mac1"</srcMac></pdu><pdu name="ip_1" pdu="ipv4:IPv4"></pdu></pdus></config></frame>}  \
            -RelationToNextFilter "AND"} sa1CaptureAnalyserFilter] } {
                            keylset retKeyedList status 1
                            keylset retKeyedList commit_needed 0
                        } else {
                            keylset retKeyedList status 0
                        }
        }
        if {[info exists argArray(-SA2)]} {
                set argArray(-src_mac2) $argArray(-SA2)
                unset argArray(-SA2)
                 if {[catch {::sth::sthCore::invoke stc::create "CaptureAnalyzerFilter" \
            -under $CaptureFilter \
            -IsSelected "TRUE" \
            -FilterDescription {EthernetII:Source MAC} \
            -ValueToBeMatched {$-src_mac2} \
            -Value "" \
            -Mask "" \
            -FrameConfig {<frame><config><pdus><pdu name="eth1" pdu="ethernet:EthernetII"><srcMac>"$-src_mac2"</srcMac></pdu><pdu name="ip_1" pdu="ipv4:IPv4"></pdu></pdus></config></frame>}  \
            -RelationToNextFilter "AND"} sa1CaptureAnalyserFilter] } {
                            keylset retKeyedList status 1
                            keylset retKeyedList commit_needed 0
                        } else {
                            keylset retKeyedList status 0
                        }
            }
                if {[info exists argArray(-DA1)]} {
                set argArray(-dst_mac1) $argArray(-DA1)
                unset argArray(-DA1)
                 if {[catch {::sth::sthCore::invoke stc::create "CaptureAnalyzerFilter" \
            -under $CaptureFilter \
            -IsSelected "TRUE" \
            -FilterDescription {EthernetII:Source MAC} \
            -ValueToBeMatched {$-dst_mac1} \
            -Value "" \
            -Mask "" \
            -FrameConfig {<frame><config><pdus><pdu name="eth1" pdu="ethernet:EthernetII"><srcMac>"$-dst_mac1"</srcMac></pdu><pdu name="ip_1" pdu="ipv4:IPv4"></pdu></pdus></config></frame>}  \
            -RelationToNextFilter "AND"} sa1CaptureAnalyserFilter] } {
                            keylset retKeyedList status 1
                            keylset retKeyedList commit_needed 0
                        } else {
                            keylset retKeyedList status 0
                        }
            }
            if {[info exists argArray(-DA2)]} {
                set argArray(-dst_mac2) $argArray(-DA2)
                unset argArray(-DA2)
                 if {[catch {::sth::sthCore::invoke stc::create "CaptureAnalyzerFilter" \
            -under $CaptureFilter \
            -IsSelected "TRUE" \
            -FilterDescription {EthernetII:Source MAC} \
            -ValueToBeMatched {$-dst_mac2} \
            -Value "" \
            -Mask "" \
            -FrameConfig {<frame><config><pdus><pdu name="eth1" pdu="ethernet:EthernetII"><srcMac>"$-dst_mac2"</srcMac></pdu><pdu name="ip_1" pdu="ipv4:IPv4"></pdu></pdus></config></frame>}  \
            -RelationToNextFilter "AND"} sa1CaptureAnalyserFilter] } {
                            keylset retKeyedList status 1
                            keylset retKeyedList commit_needed 0
                        } else {
                            keylset retKeyedList status 0
                        }
            }
            
        if {[info exists argArray(-SA_mask1)]} {
                unset argArray(-SA_mask1)
            }
        if {[info exists argArray(-SA_mask2)]} {
                unset argArray(-SA_mask2)
            }
        if {[info exists argArray(-DA_mask1)]} {
                unset argArray(-DA_mask1)
            }
        if {[info exists argArray(-DA_mask2)]} {
                unset argArray(-DA_mask2)

        if {[info exists argArray(-pattern_offset_type1)]} {
                unset argArray(-pattern_offset_type1)
            }
        if {[info exists argArray(-pattern_offset_type2)]} {
                unset argArray(-pattern_offset_type2)
            }
            }

    }
    if {[regexp -nocase "pattern1" $args] || [regexp -nocase "pattern2" $args]} {
        ####pattern_match
        if {[lsearch $args "-pattern1"] > -1} {
            set pattern [::wrapper::get_value_list $args "-pattern1"]
        } elseif {[lsearch $args "-pattern2"] > -1} {
            set pattern [::wrapper::get_value_list $args "-pattern2"]
        }

        foreach patternbyte $pattern {
            if {[string length $patternbyte] == 1} {
                set index [lsearch $pattern $patternbyte]
                set pattern [lreplace $pattern $index $index "[set patternbyte]0"]
            }
        }

        ####pattern_mask
        if {[lsearch $args "-pattern_mask1"] > -1} {
            set pattern_mask [::wrapper::get_value_list $args "-pattern_mask1"]
        } elseif {[lsearch $args "-pattern_mask2"] > -1} {
            set pattern_mask [::wrapper::get_value_list $args "-pattern_mask2"]
        }

        set offset 0
        while {1} {
            set length [llength $pattern]
            set index1 0
            set index2 3
            if {$length < 4} {
                set index2 [expr $length -1]
            }
            set new_pattern [lrange $pattern $index1 $index2]
            set new_pattern_mask [lrange $pattern_mask $index1 $index2]

            set pattern [lrange $pattern [expr $index2 + 1] $length]
            set pattern_mask [lrange $pattern_mask [expr $index2 + 1] $length]

            if {[lsearch $args "-pattern1"] > -1} {
                set args [wrapper::shield_args -total $args -unsupported pattern1]
                set args "$args -pattern1 $new_pattern"
            } elseif {[lsearch $args "-pattern2"] > -1} {
                set args [wrapper::shield_args -total $args -unsupported pattern2]
                set args "$args -pattern2 $new_pattern"
            }

            ####pattern_mask
            if {[regexp -nocase "ff ff ff ff" $new_pattern_mask]} {
                incr offset 4
                if {$length <= 4} {
                    break
                }
                continue
            }
            if {[lsearch $args "-pattern_mask1"] > -1} {
                set args [wrapper::shield_args -total $args -unsupported pattern_mask1]
                set args "$args -pattern_mask1 $new_pattern_mask"
            } elseif {[lsearch $args "-pattern_mask2"] > -1} {
                set args [wrapper::shield_args -total $args -unsupported pattern_mask2]
                set args "$args -pattern_mask2 $new_pattern_mask"
            }

            set filter_name uds1_count
            if {[lsearch $args "-pattern1"] > -1} {
                set filter_name uds1_count
            }
            if {[lsearch $args "-pattern2"] > -1} {
                set filter_name uds2_count
            }
            set filter_args "-pattern_type $filter_name"
            listToArray $args argArray
            ####port_handle
            if {[lsearch $args "-port_handle"] > -1} {
                set port $argArray(-port_handle)
                set filter_args "$filter_args -port_handle $port"
            }
            ####pattern_match
            if {[lsearch $args "-pattern1"] > -1} {
                set pattern1 [::wrapper::get_value_list $args "-pattern1"]
                regsub -all " " $pattern1 "" pattern1
                set filter_args "$filter_args -pattern_match $pattern1"
            } elseif {[lsearch $args "-pattern2"] > -1} {
                set pattern2 [::wrapper::get_value_list $args "-pattern2"]
                regsub -all " " $pattern2 "" pattern2
                set filter_args "$filter_args -pattern_match $pattern2"
            }

            ####pattern_offset
            if {[lsearch $args "-pattern_offset1"] > -1} {
                set pattern_offset $argArray(-pattern_offset1)
                set filter_args "$filter_args -pattern_offset [expr $pattern_offset + $offset]"
            } elseif {[lsearch $args "-pattern_offset2"] > -1} {
                set pattern_offset $argArray(-pattern_offset2)
                set filter_args "$filter_args -pattern_offset [expr $pattern_offset + $offset]"
            }

            incr offset 4

            ####pattern_mask
            if {[lsearch $args "-pattern_mask1"] > -1} {
                set pattern_mask1 [::wrapper::get_value_list $args "-pattern_mask1"]
                regsub -all " " $pattern_mask1 "" pattern_mask1
                set mask ""
                set length1 [string length $pattern_mask1]
                for {set i 0} {$i < $length1} {incr i} {
                    set char [string index $pattern_mask1 $i]
                    set NotValue [format %0x [format %u [expr ~ "0x$char"]]]
                    set NotValueLen [string length $NotValue]
                    set NotValue [string index $NotValue [incr NotValueLen -1]]
                    set mask "$mask$NotValue"
                }

                set filter_args "$filter_args -pattern_mask $mask"
            } elseif {[lsearch $args "-pattern_mask2"] > -1} {
                set pattern_mask2 [::wrapper::get_value_list $args "-pattern_mask2"]
                regsub -all " " $pattern_mask2 "" pattern_mask2
                set mask ""
                set length2 [string length $pattern_mask2]
                for {set i 0} {$i < $length2} {incr i} {
                    set char [string index $pattern_mask2 $i]
                    set NotValue [format %0x [format %u [expr ~ "0x$char"]]]
                    set NotValueLen [string length $NotValue]
                    set NotValue [string index $NotValue [incr NotValueLen -1]]
                    set mask "$mask$NotValue"
                }

                set filter_args "$filter_args -pattern_mask $mask"
            }
            set cmdName "sth::packet_config_pattern $filter_args"
            set ret [::spirent::process_cmd $cmdName]
            if {![keylget ret status]} {
                return $ret
            }
            if {$length <= 4} {
                break
            }
        }
        keylset new_ret status 1
        return $new_ret
    } else {
        set cmdName "sth::packet_config_filter $args"
        return [::spirent::process_cmd $cmdName]
    }
}

proc ::AgtTest::packet_capture_config { args } {

    array set argArray {}
	array set patArray {}
	set tmp {}

	set args [eval ::spirent::port_converter $args]
    ::spirent::listToArray $args argArray
	
	if {[info exist argArray(-protocol)]} {
        set patArray(-pdu) $argArray(-protocol)
		unset argArray(-protocol)
    }
	
	if {[info exist argArray(-field_type_list)]} {
        set patArray(-field) sourceaddr
		unset argArray(-field_type_list)
    }
	
	if {[info exist argArray(-field_value_list)]} {
        set patArray(-value) $argArray(-field_value_list)
        unset argArray(-field_value_list)
    }
	set tmp "-frameconfig ethernetii:$patArray(-pdu) -pdu $patArray(-pdu) -field sourceaddr -value $patArray(-value)"
	sth::packet_config_filter -port_handle $argArray(-port_handle) \
     -filter "pattern { {$tmp } }" 
	#	parray argArray
}
	
	
proc ::spirent::packet_config_triggers {args} {
    set ixia_only_args ""
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    ####uds1/uds2
    if {[regexp -nocase uds1 $args] || [regexp -nocase uds2 $args]} {
        ::wrapper::log_ouput "skip packet_config_triggers: $args"
        keylset ret status 1
        return $ret
    }
    listToArray $args argArray

    #prepare -port_handle and capture_filter_framesize_from
    #input packet_config_filter -port_handle -filter length
    if {[lsearch $args "-port_handle"] > -1} {
        set port $argArray(-port_handle)
        lappend processed_args "-port_handle" $port
    }
    if {[lsearch $args "-capture_filter_framesize_from"] > -1} {
        set framemin $argArray(-capture_filter_framesize_from)
    }
    if {[lsearch $args "-capture_filter_framesize_to"] > -1} {
        set framemax $argArray(-capture_filter_framesize_to)
    }
    if {[info exists framemin] && [info exists framemax]} {
        if {$framemin eq $framemax} {
            lappend processed_args "-filter" "\"length $framemax\""
        } else {
            return -code 1 -errorcode -1 "capture_filter_framesize_from not equal capture_filter_framesize_to"
        }
    } else {
        #return -code 1 -errorcode -1 "capture_filter_framesize_from/capture_filter_framesize_to not pairs"
    }
    set cmdName "sth::packet_config_filter $processed_args"
    return [::spirent::process_cmd $cmdName]
}

proc ::spirent::packet_control {args} {
    set ixia_only_args ""
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    ::spirent::listToArray $args argArray
    if {([lsearch $args "-port_handle"]> -1 )&&([regexp -nocase "all" $argArray(-port_handle)])} {
        set cmdName "sth::packet_control $args"
        set output [::spirent::process_cmd $cmdName]
        return $output
    }
    set port_handle_list $argArray(-port_handle)
	
    if {[lsearch $args "-action"] > -1} {
        set action $argArray(-action)
        if {($action eq "cumulative_start") |($action eq "reset")} {
            return -code 1 -errorcode -1 "$action not supported in packet_control"
        }
        set processed_args $args
        if {[regexp "start" $action]} {
            #if action is start, need to check the status of the capture, incase the capture has already been started in the
            #interface_config.
            #Taking args to array to take care of more than one port_handle for Agilent.
            
            foreach port_handle $port_handle_list {
			    set capture_info_ret [sth::packet_info -port_handle $port_handle -action status]
                set capture_status [keylget capture_info_ret status]
                if {$capture_status == 0} {
                    keylset retKeyedList [keylget capture_info_ret log]
                    return $retKeyedList
                }
                set capture_stopped [keylget capture_info_ret stopped]
                #if the capture is in running stats, then need to stop it before start a new one.
                if {$capture_stopped != 1} {
                    set packet_ctrl [sth::packet_control -port_handle $port_handle -action stop]
                    set packet_ctrl_status [keylget packet_ctrl status]
                    if {$packet_ctrl_status == 0} {
                        keylset retKeyedList [keylget packet_ctrl_status log]
                        return $retKeyedList
                    }
                }
            }
        }
    }
	#set port_handle_list $argArray(-port_handle)
    foreach port_handle $port_handle_list {
	    set cmdName "sth::packet_control -port_handle $port_handle -action $argArray(-action)"
        set output [::spirent::process_cmd $cmdName]
    }
	return $output 
}

proc ::spirent::packet_stats {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    #only support port_handle and format: pcap/var
    #enhance hltapi code to support var format and output same keyedlist as ixia
    ############note############
    #need check whether the frame data is "12345678" of "12 34 56 78",
    #can use funtion ::wrapper::add_space to convert it
    #currently it supports "12345678",
    set processed_args $args
    if {([lsearch $args "-action"] == -1 )} {
        set processed_args "$args -action filtered"
    }
    set cmdName "sth::packet_stats $processed_args"
    return [::spirent::process_cmd $cmdName]
}


proc ::spirent::capture_packets {args} {
    #the capture should have already been start in the interface_cofnig, the -rx_port_mode should have been set to capture
    #need to check if it has been started or. not
    ######convert physical port
    set result_port_handle_list [::wrapper::get_value_list $args "-port_handle"]
    set args [eval ::spirent::port_converter $args]
    set port_handle ""
    set start 0
    set stop 0
    set packets_num 1
    set retKeyedList ""
    set port_handle_list ""
    keylset retKeyedList status 0
    if {[lsearch $args "-port_handle"] > -1} {
        set port_handle_list [::wrapper::get_value_list $args "-port_handle"]
    }
    if {$port_handle_list == ""} {
        keylset retKeyedList log "the -port_handle need to be specified"
        return $retKeyedList
    }

    if {[lsearch $args "-start"] > -1} {
        set start 1
    }
    if {[lsearch $args "-stop"] > -1} {
        set stop 1
    }
    if {[info exists argArray(-get_packets)] } {
        set packets_num $argArray(-get_packets)
    }
    foreach port_handle $port_handle_list {
        set capture_info_ret [sth::packet_info -port_handle $port_handle -action status]
        set capture_status [keylget capture_info_ret status]
        if {$capture_status == 0} {
            keylset retKeyedList [keylget capture_info_ret log]
            return $retKeyedList
        }
        set capture_stopped [keylget capture_info_ret stopped]
        if {$start == 1 && [lsearch $args "-get_packets"] < 0} {
            #need the capture be in start mode, if it is in stop mode, need to start it
            #how long will the capture be

            set packet_ctrl [sth::packet_control -port_handle $port_handle -action stop]
            set packet_ctrl_status [keylget packet_ctrl status]
            if {$packet_ctrl_status == 0} {
                keylset retKeyedList [keylget packet_ctrl_status log]
                return $retKeyedList
            }
            set packet_ctrl [sth::packet_control -port_handle $port_handle -action start]
            set packet_ctrl_status [keylget packet_ctrl status]
            if {$packet_ctrl_status == 0} {
                return $packet_ctrl
            } else {
                keylset retKeyedList status 1
            }

        }
        if {$stop == 1} {
            set packet_ctrl [sth::packet_control -port_handle $port_handle -action stop]
            set packet_ctrl_status [keylget packet_ctrl status]
            if {$packet_ctrl_status == 0} {
                return $packet_ctrl
            } else {
                keylset retKeyedList status 1
            }
        }
    }
    if {[lsearch $args "-get_packets"] < 0} {
        return $retKeyedList
    }
    #return the specified packets. CaptureGetFrameCommand
    #get the captured packets, here need to stop the capture, else, the pkts will be empty
    set pkt_data_list ""
    if {$capture_stopped != 1} {
            set packet_ctrl [sth::packet_control -port_handle $port_handle -action stop]
            set packet_ctrl_status [keylget packet_ctrl status]
            if {$packet_ctrl_status == 0} {
                    keylset retKeyedList [keylget packet_ctrl_status log]
                    return $retKeyedList
            }
    }

    foreach port_handle $port_handle_list result_port_handle $result_port_handle_list {
    	set pkt_data_list ""
        for {set frameindex 0} {$frameindex < $packets_num} {incr frameindex} {
            set get_frame [::sth::sthCore::invoke stc::perform CaptureGetFrame -captureproxyid  [::sth::sthCore::invoke stc::get $port_handle -children-capture]  -frameindex $frameindex]
            set data_len [lindex $get_frame [expr [lsearch $get_frame -DataLength] + 1]]
            set prem_len [lindex $get_frame [expr [lsearch $get_frame -PreambleLength] + 1]]
            set data_len [expr $data_len - $prem_len]
            if {$data_len <= 0} {
                #the data should not be empty
                keylset retKeyedList log "the data is empty"
                return $retKeyedList
            } else {
                set pkt_data [lindex $get_frame [expr [lsearch $get_frame -PacketData] + 1]]
                set pkt_data [string range $pkt_data [expr 2*$prem_len] [string length $pkt_data]]
                set pkt_data "{[::wrapper::add_space $pkt_data]}"
                set pkt_data_list [concat $pkt_data_list $pkt_data]
            }
        }
        keylset retKeyedList status 1
        keylset retKeyedList $result_port_handle.packets $pkt_data_list
    }
    return $retKeyedList
}

proc ::ixia::interface_config { args } {
    #for Multicast
    global return_list
    set tempArray(-connectedCount) 1
    set tempArray(-greIpv4SrcAddrStep) "0.0.0.1"
    set tempArray(-greIpv4DstAddrStep) "0.0.0.0"
    set tempArray(-ipv4AddrStep) "0.0.0.1"
    set tempArray(-ipv4GwStep) "0.0.0.0"
    set tempArray(-ipv6AddrStep) "0000::1"
    set tempArray(-ipv6GwStep) "::0"
    set tempArray(-portRxMode) ""
    set tempArray(-qosPtnOffset) 12
    set tempArray(-qosByteOffset) 14
    set tempArray(-qosPtnMatch) 8100
    set tempArray(-qosPktType) "vlan"
    set tempArray(-qosPtnMask) FFFF
    set tempArray(-srcMacAddrStep) "00:00:00:00:00:01"
    set tempArray(-vlanIdStep) 1
    set handleIndex 0
    array set argArray {}
    array set configArray {}
    array set greArray {}
    set errmsg ""
    set handlesList ""
    set greHandleList ""
    set result ""
    set tempResult ""
    keylset result status 1
    keylset result log ""

    #for ixia if -port_handle value is empty clear all the ports
    if {[lsearch $args "-port_handle"] > -1} {
        if {[regexp -nocase {port_handle[\s]*-} $args]} {
            set port_list [stc::get project1 -children-port]
            set args [linsert $args [expr [lsearch $args "-port_handle"] + 1] $port_list]
        }
    }
    set args [eval ::spirent::port_converter $args]

    ##ixia arp_req_timeout default is 10, while STC is 1000. It can help speed up 1 s.
    if {([lsearch $args "-arp_req_timeout"] == -1)} {
        set arpconfig [::sth::sthCore::invoke stc::get project1 -children-arpndconfig]
        ::sth::sthCore::invoke stc::config $arpconfig -TimeOut 10
    }

    ::spirent::listToArray $args argArray
    # Temp Fix for the empty mac
    if {[info exist argArray(-src_mac_addr)]} {
                if {($argArray(-src_mac_addr) ==  1)} {
                       array unset argArray -src_mac_addr
		}
        }
        
        array unset argArray -op_mode
	array unset argArray -internal_ppm_adjust
	array unset argArray -transmit_clock_source
	array unset argArray -create_host
	
    ##in job 7711983-1-893309-xr_marking2_defalt_cos_pwhe_ipv6, interface devices
    ##NA/NS(with default vlan pri 7) will counted in node1_egress and cause the testcase fail
    if {[info exist argArray(-vlan_id)] && ![info exist argArray(-vlan_user_priority)]} {
        set argArray(-vlan_user_priority) 0
    }
    if {[info exist argArray(-vlan_outer_id)] && ![info exist argArray(-vlan_outer_user_priority)]} {
        set argArray(-vlan_outer_user_priority) 0
    }
    if {[info exist argArray(-connected_count)] && [info exist argArray(-vlan_id_count)] \
                && $argArray(-connected_count) == $argArray(-vlan_id_count)} {
        unset argArray(-vlan_id_count)
    }
    if {[info exist argArray(-connected_count)]} {
        set tempArray(-connectedCount) $argArray(-connected_count)
        if {[info exist argArray(-mode)] && $argArray(-mode) == "modify" && $argArray(-connected_count)>1} {
            set argArray(-mode) "config"
        }
    }
    if {[info exist argArray(-intf_ip_addr_step)]} {
        set tempArray(-ipv4AddrStep) $argArray(-intf_ip_addr_step)
#        unset argArray(-intf_ip_addr_step)
    }
    if {[info exist argArray(-gateway_step)]} {
        set tempArray(-ipv4GwStep) $argArray(-gateway_step)
#        unset argArray(-gateway_step)
    }
    if {[info exist argArray(-ipv6_intf_addr_step)]} {
        set tempArray(-ipv6AddrStep) $argArray(-ipv6_intf_addr_step)
#        unset argArray(-ipv6_intf_addr_step)
    }
    if {[info exist argArray(-ipv6_gateway_step)]} {
        set tempArray(-ipv6GwStep) $argArray(-ipv6_gateway_step)
#        unset argArray(-ipv6_gateway_step)
    }
    if {[info exist argArray(-vlan_id_step)]} {
        set tempArray(-vlanIdStep) $argArray(-vlan_id_step)
#        unset argArray(-vlan_id_step)
    }
    if {[info exist argArray(-src_mac_addr_step)]} {
        set tempArray(-srcMacAddrStep) $argArray(-src_mac_addr_step)
#        unset argArray(-src_mac_addr_step)
    }
    #########add default gateway#########
    if {[info exist argArray(-mode)] && [string equal -nocase "config" $argArray(-mode)]} {
        if {![info exist argArray(-gateway)]} {
            if {[info exist argArray(-intf_ip_addr)]} {
                set tempList [split $argArray(-intf_ip_addr) .]
                set tempList [lreplace $tempList end end 1]
                set argArray(-gateway) [join $tempList .]
                #set argArray(-gateway) [::wrapper::ConvertIncrementIpAddress $argArray(-intf_ip_addr) -1]
            }
        }
    }
    #here handle Qos parameter and call ::sth::packet_config_pattern
    if {[info exist argArray(-qos_stats)] && \
                    (1 == $argArray(-qos_stats)) && \
                    [info exist argArray(-qos_pattern_match)]} {

        if {[info exist argArray(-qos_pattern_offset)]} {
            set tempArray(-qosPtnOffset) $argArray(-qos_pattern_offset)
        }
        if {[info exist argArray(-qos_pattern_match)]} {
            regsub -all { } $argArray(-qos_pattern_match) {} tempArray(-qosPtnMatch)
        }
        if {[info exist argArray(-qos_packet_type)]} {
            set tempArray(-qosPktType) $argArray(-qos_packet_type)
        }
        if {[info exist argArray(-qos_byte_offset)]} {
            set tempArray(-qosByteOffset) $argArray(-qos_byte_offset)
        }
        if {[info exist argArray(-qos_pattern_mask)]} {
            regsub -all { } $argArray(-qos_pattern_mask) {} tempArg
            set tempArray(-qosPtnMask) [string range [format %x [expr ~ $tempArg]] [expr 8 - [string length $tempArg]] end]
        }
        ##here create 2 custom filters under port.analyzer
        foreach eachPort $argArray(-port_handle) {
            set analyzer [::sth::sthCore::invoke stc::get $eachPort -children-analyzer]
            if {[regexp -nocase "analyzer16bitfilter" [::sth::sthCore::invoke stc::get $analyzer -children]]} {
                set filterList [::sth::sthCore::invoke stc::get $analyzer -children-Analyzer16BitFilter]
                if {$filterList ne ""} {
                    foreach filter $filterList {
                        ::sth::sthCore::invoke stc::delete $filter
                    }
                }
            }
            ::sth::sthCore::invoke stc::create Analyzer16BitFilter -under $analyzer -Mask [format %d 0x$tempArray(-qosPtnMask)]\
                    -StartOfRange [format %d 0x$tempArray(-qosPtnMatch)] -EndOfRange [format %d 0x$tempArray(-qosPtnMatch)] \
                    -Offset $tempArray(-qosPtnOffset) -FilterName "EtherType"
            ::sth::sthCore::invoke stc::create Analyzer16BitFilter -under $analyzer -Mask [format %d 0xE000]\
                    -StartOfRange 0 -EndOfRange 65535 -Offset $tempArray(-qosByteOffset) \
                    -FilterName "VLAN CoS"
        }
    }
    if {[info exist argArray(-port_rx_mode)]} {
        if {[regexp -nocase "data_integrity" $argArray(-port_rx_mode)]} {
            set args [array get argArray]
            wrapper::config_capture_ana_filter $args
        }
    }
    #add enable_ping_response default as 1
    if {![info exist argArray(-enable_ping_response)]} {
        set argArray(-enable_ping_response) 1
    }
    if {[info exist argArray(-speed)]} {
        if {$argArray(-speed) == "auto"} {
            unset argArray(-speed)
        } else {
            switch -- [string tolower $argArray(-speed)] {
                ether10000wan {set argArray(-speed) "ether10000"
                           set argArray(-path_signal_label) "ETHERNET_10G_WAN"}
                ether100gig -
                ether100000 -
                ether100000lan {set argArray(-speed) "ether100Gig"}
                ether40gig -
                ether40000lan {set argArray(-speed) "ether40Gig"}
                default {regsub -all "lan" $argArray(-speed) {} argArray(-speed)}
            }
        }
    }
    #if the mode is destroy, will not call hltapi, only clear the devices and streams on this ports
    if {[info exist argArray(-mode)]} {
        if {[string equal -nocase "destroy" $argArray(-mode)]} {
            foreach i $argArray(-port_handle) {
                set devices [::sth::sthCore::invoke stc::get $i -AffiliationPort-Sources]
                foreach j $devices {
                    ::sth::sthCore::invoke stc::delete $j
                }
            }
            keylset result status 1
            return [::spirent::ret_port_converter $result]
        }
    } else {
        set argArray(-mode) "config"
        foreach eachPort $argArray(-port_handle) {
            set hosts [::sth::sthCore::invoke stc::get $eachPort "-AffiliationPort-Sources"]
            foreach i $hosts {
                if {[string equal -nocase "port_address" [::sth::sthCore::invoke stc::get $i "-Name"]]} {
                    set argArray(-mode) "modify"
                    break
                }
            }
        }
    }
    #remove the options which can't be supported in spirent hltapi
    #-arp is not supported in spirent hltapi, the mean of this option is to control -arp_send_req, if -arp is 0, then arp_send_req will be ingnored,
    #the default value of arp is 1.
    if {[info exist argArray(-arp)] && (0 == $argArray(-arp))} {
        array unset argArray -arp_send_req
    }
    #the phy_mode only support to be fiber or copper
    if {[info exist argArray(-phy_mode)] && [regexp -nocase "sfp" $argArray(-phy_mode)]} {
        set argArray(-phy_mode) "fiber"
    }
    if {[info exist argArray(-duplex)] && ($argArray(-duplex) == "auto")} {
        unset argArray(-duplex)
    }
    if {[info exist argArray(-intf_mode)] && ("lan" == $argArray(-intf_mode))} {
        set argArray(-intf_mode) "ethernet"
    }
    if {[info exist argArray(-port_rx_mode)]} {
        set tempArray(-portRxMode) $argArray(-port_rx_mode)
    }
    if {[info exist argArray(-mtu)]} {
        set argArray(-control_plane_mtu) $argArray(-mtu)
        unset argArray(-mtu)
    }
    if {![info exist argArray(-arp_send_req)] && [info exist argArray(-ndp_send_req)]} {
        set argArray(-arp_send_req) $argArray(-ndp_send_req)
        unset argArray(-ndp_send_req)
    }
    if {[info exist argArray(-gateway)] && [regexp {:} $argArray(-gateway)]} {
        set argArray(-ipv6_gateway) $argArray(-gateway)
        unset argArray(-gateway)
    }
    if {[info exist argArray(-vlan_id)] && [regexp {,} $argArray(-vlan_id)]} {
        set vlanIdTemp [split $argArray(-vlan_id) {,}]
        set argArray(-vlan_id) [lindex $vlanIdTemp 1]
        set argArray(-vlan_outer_id) [lindex $vlanIdTemp 0]
    }
	##replace enable_flow_control with flow_control
	if {[info exist argArray(-enable_flow_control)]} {
		if {$argArray(-enable_flow_control) == 0} {
			 set argArray(-flow_control) "false"
		} else {
			set argArray(-flow_control) "true"
		}
        unset argArray(-enable_flow_control)
    }
    ##for GRE interface
    if {[info exist argArray(-gre_ip_addr)]} {
        set greArray(-gre_src_addr) $argArray(-gre_ip_addr)
        unset argArray(-gre_ip_addr)
    }
    if {[info exists argArray(-gre_ip_addr_step)]} {
        if {$argArray(-gre_ip_addr_step) != "0.0.0.0"} {
            set greArray(-gre_src_mode) increment
        }
        set tempArray(-greIpv4SrcAddrStep) $argArray(-gre_ip_addr_step)
        unset argArray(-gre_ip_addr_step)
    }
    if {[info exist argArray(-gre_dst_ip_addr)]} {
        set greArray(-gre_dst_addr) $argArray(-gre_dst_ip_addr)
        unset argArray(-gre_dst_ip_addr)
    }
    if {[info exists argArray(-gre_dst_ip_addr_step)]} {
        if {$argArray(-gre_dst_ip_addr_step) != "0.0.0.0"} {
            set greArray(-gre_dst_mode) increment
        }
        set tempArray(-greIpv4DstAddrStep) $argArray(-gre_dst_ip_addr_step)
        unset argArray(-gre_dst_ip_addr_step)
    }
    if {[info exist argArray(-gateway)] && [info exist argArray(-port_handle)]} {
        set greArray(-gre_tnl_addr) $argArray(-gateway)
    }
    if {[info exist argArray(-gre_ip_prefix_length)]} {
        set temp $argArray(-gre_ip_prefix_length)
        unset argArray(-gre_ip_prefix_length)
        if {[info exist argArray(-netmask)]} {
            set tempList [split $argArray(-netmask) .]
            set mask 0
            for {set i 0} {$i<4} {incr i} {
                set token [lindex $tempList $i]
                for {set j 8} {$j>0} {incr j -1} {
                    if {1 == [expr $token%2]} {
                        break
                    }
                    set token [expr $token/2]
                }
                incr mask $j
                if {$j<8} {break}
            }
            set greArray(-gre_prefix_len) $mask
            unset mask
            unset tempList
            unset token
        }
        set argArray(-netmask) [sth::sthCore::prefixLengthToIpMask $temp 4]
        unset temp
    }
    if {[info exists argArray(-intf_ip_addr)] && [info exists argArray(-port_handle)]} {
        for {set i 0} {$i<[llength $argArray(-port_handle)]} {incr i} {
            keylset ::spirent::intf_ip_addr_from_port [lindex $argArray(-port_handle) $i] [lindex $argArray(-intf_ip_addr) $i]
        }
    }
    #ixia::  -arp -connected_count -data_integrity -integrity_signature -integrity_signature_offset -pgid_offset -port_rx_mode -signature_offset
    #-transmit_mode -ndp_send_req -qos_stats -signature
    array unset argArray -action
    array unset argArray -arp
    array unset argArray -arp_on_linkup
    array unset argArray -ns_on_linkup
    array unset argArray -check_gateway_exists
    array unset argArray -connected_count
    array unset argArray -data_integrity
    array unset argArray -gateway_incr_mode
    array unset argArray -ignore_link
    array unset argArray -integrity_signature
    array unset argArray -integrity_signature_offset
    array unset argArray -l23_config_type
    array unset argArray -no_sut
    array unset argArray -num_intf_ip_addr
    array unset argArray -num_ipv4_pools
    array unset argArray -pgid_offset
    array unset argArray -pgid_mode
    array unset argArray -port_rx_mode
    array unset argArray -qos_byte_offset
    array unset argArray -qos_packet_type
    array unset argArray -qos_pattern_offset
    array unset argArray -qos_pattern_mask
    array unset argArray -qos_pattern_match
    array unset argArray -qos_stats
    array unset argArray -sequence_checking
    array unset argArray -sequence_num_offset
    array unset argArray -signature
    array unset argArray -signature_offset
    array unset argArray -signature_start_offset
    array unset argArray -transmit_mode
    array unset argArray -check_opposite_ip_version
    array unset argArray -single_arp_per_gateway
    array unset argArray -single_ns_per_gateway
    array unset argArray -target_link_layer_address
    array unset argArray -tx_gap_control_mode
    array unset argArray -vlan_tpid
    if {[info exist argArray(-arp_send_req)]} {
        array unset argArray -ndp_send_req
        if {![info exist argArray(-arp_target)]} {
            set argArray(-arp_target) "all"
        }
    }

    #ixia support list for the port_handle, and also the vlaue of other option can be a list, but spirent not support port handle list,
    #so need to handle it here, also the retured value need to be processed.
    foreach i $argArray(-port_handle) {
        set args_to_config ""
        set skip_port 0
        foreach j [array name argArray] {
            if {[llength $argArray($j)]>1} {
                set configArray($j) [lindex $argArray($j) $handleIndex]
            } else {
                set configArray($j) $argArray($j)
                if {(($j == "-gateway") ||($j == "-ipv6_gateway")) && ($handleIndex > 0)} {
                    set skip_port 1
                }
            }
        }
        if {$skip_port} {
            continue
        }

        if {[info exist greArray(-gre_src_addr)] && [info exist argArray(-intf_ip_addr)]} {
            set configArray(-intf_ip_addr) $greArray(-gre_src_addr)
            set greArray(-gre_src_addr) $argArray(-intf_ip_addr)
            catch {
                set temp $tempArray(-ipv4AddrStep)
                set tempArray(-ipv4AddrStep) $tempArray(-greIpv4SrcAddrStep)
                set tempArray(-greIpv4SrcAddrStep) $temp
                unset temp
            }
            # Create new gateway for GRE
            set tempList [split $argArray(-intf_ip_addr) .]
            set tempList [lreplace $tempList end end 1]
            set argArray(-gateway_ip_addr) [join $tempList .]
            # Create new gre tunnel address for GRE
            if {[info exists greArray(-gre_tnl_addr)]} {
                set tempList [split $greArray(-gre_tnl_addr) .]
                set tempList [lreplace $tempList end end 1]
                set greArray(-gre_tnl_addr) [join $tempList .]
            }
        }

        #####add for connected_count#######
        if {$tempArray(-connectedCount) > 1} {
            ##wizard way
            set interfaceGen [::sth::sthCore::invoke stc::create HostGenParams -under project1\
                -SelectedPort-targets $i -BlockMode MULTIPLE_NETWORKS_PER_BLOCK -Count $tempArray(-connectedCount)]
            
            set ethGen [::sth::sthCore::invoke stc::create DeviceGenEthIIIfParams -under $interfaceGen]
            if {[info exists configArray(-src_mac_addr)]} {
                ::sth::sthCore::invoke stc::config $ethGen -SrcMac $configArray(-src_mac_addr)]
            }
            set Lowif $ethGen
            
            if {[info exists configArray(-vlan_id)]} {
                set vlan1Gen [::sth::sthCore::invoke stc::create DeviceGenVlanIfParams -under $interfaceGen]
                ::sth::sthCore::invoke stc::config $vlan1Gen -vlanId $configArray(-vlan_id) -DeviceGenStackedOnIf-targets $ethGen
                if {[info exists configArray(-vlan_id_count)]} {
                    ::sth::sthCore::invoke stc::config $vlan1Gen -Count $configArray(-vlan_id_count)
                }
                if {[info exists configArray(-vlan_id_step)]} {
                    ::sth::sthCore::invoke stc::config $vlan1Gen -IdStep $configArray(-vlan_id_step)
                }
                if {[info exists configArray(-vlan_user_priority)]} {
                    ::sth::sthCore::invoke stc::config $vlan1Gen -Priority $configArray(-vlan_user_priority)
                }
                set Lowif $vlan1Gen
            }
            
            if {[info exists configArray(-vlan_outer_id)] && [info exists vlan1Gen]} {
                set vlan2Gen [::sth::sthCore::invoke stc::create DeviceGenVlanIfParams -under $interfaceGen]
                ::sth::sthCore::invoke stc::config $vlan2Gen -vlanId $configArray(-vlan_outer_id) -DeviceGenStackedOnIf-targets $ethGen
                ::sth::sthCore::invoke stc::config $vlan1Gen -DeviceGenStackedOnIf-targets $vlan2Gen
                if {[info exists configArray(-vlan_outer_id_count)]} {
                    ::sth::sthCore::invoke stc::config $vlan2Gen -Count $configArray(-vlan_outer_id_count)
                }
                if {[info exists configArray(-vlan_outer_id_step)]} {
                    ::sth::sthCore::invoke stc::config $vlan2Gen -IdStep $configArray(-vlan_outer_id_step)
                }
                if {[info exists configArray(-vlan_outer_user_priority)]} {
                    ::sth::sthCore::invoke stc::config $vlan2Gen -Priority $configArray(-vlan_outer_user_priority)
                }
            }
            
            if {[info exists configArray(-intf_ip_addr)]} {
                set ipv4Gen [::sth::sthCore::invoke stc::create DeviceGenIpv4IfParams -under $interfaceGen\
                    -Addr $configArray(-intf_ip_addr) -DeviceGenStackedOnIf-targets $Lowif \
                    -DeviceGenTopLevelIf-sources $interfaceGen]
                if {[info exists configArray(-intf_ip_addr_step)]} {
                    ::sth::sthCore::invoke stc::config $ipv4Gen -AddrStep $configArray(-intf_ip_addr_step)
                }
                if {[info exists configArray(-gateway)]} {
                    ::sth::sthCore::invoke stc::config $ipv4Gen -Gateway $configArray(-gateway)
                }
                if {[info exists configArray(-gateway_step)]} {
                    ::sth::sthCore::invoke stc::config $ipv4Gen -GatewayStep $configArray(-gateway_step)
                }
            }
            if {[info exists configArray(-ipv6_intf_addr)]} {
                set ipv6Gen1 [::sth::sthCore::invoke stc::create DeviceGenIpv6IfParams -under $interfaceGen -AddrType NON_LINK_LOCAL \
                    -Addr $configArray(-ipv6_intf_addr) -DeviceGenStackedOnIf-targets $Lowif \
                    -DeviceGenTopLevelIf-sources $interfaceGen]
                if {[info exists configArray(-ipv6_intf_addr_step)]} {
                    ::sth::sthCore::invoke stc::config $ipv6Gen1 -AddrStep $configArray(-ipv6_intf_addr_step)
                }
                if {[info exists configArray(-ipv6_gateway)]} {
                    ::sth::sthCore::invoke stc::config $ipv6Gen1 -Gateway $configArray(-ipv6_gateway)
                }
                if {[info exists configArray(-ipv6_gateway_step)]} {
                    ::sth::sthCore::invoke stc::config $ipv6Gen1 -GatewayStep $configArray(-ipv6_gateway_step)
                }
                if {[info exists configArray(-ipv6_prefix_length)]} {
                    ::sth::sthCore::invoke stc::config $ipv6Gen1 -PrefixLength $configArray(-ipv6_prefix_length)
                }
                set ipv6Gen2 [::sth::sthCore::invoke stc::create DeviceGenIpv6IfParams -under $interfaceGen -AddrType LINK_LOCAL \
                    -AutoAddrEnable TRUE -UseEui64LinkLocalAddress TRUE -DeviceGenStackedOnIf-targets $Lowif \
                    -DeviceGenTopLevelIf-sources $interfaceGen]
            }
            
            array set return [::sth::sthCore::invoke stc::perform devicegenconfigexpand -deleteexisting no -genparams $interfaceGen]
            set handlesList $return(-ReturnList)
            
            ##Perform Arp per arp_send_req
            if {[info exists configArray(-arp_send_req)] && (1 == $configArray(-arp_send_req))} {
                if {[catch {set arpResults [::sth::sthCore::invoke ::stc::perform ArpNdStart -HandleList "$handlesList"]} err]} {
                    keylset result status 0
                    keylset result log $err
                    return [::spirent::ret_port_converter $result]
                }
                if {[regexp -nocase "ArpNdState FAILURE" $arpResults]} {
                    keylset result arpnd_status $::sth::sthCore::FAILURE
                    keylset result $i.arp_request_success $::sth::sthCore::FAILURE
                } else {
                    keylset result arpnd_status $::sth::sthCore::SUCCESS
                    keylset result $i.arp_request_success $::sth::sthCore::SUCCESS
                }
            }
            
            foreach device $handlesList {
                ::sth::sthCore::invoke stc::config $device -name "port_address"
                ::sth::sthCore::invoke stc::config $device -EnablePingResponse TRUE
                ###Gre part
                if {[array size greArray] > 1} {
                    set gre_param_list [array get greArray]
                    ##add gre stack start
                    set tempList ""
                    set greArgs ""
                    set greArgs [::spirent::emulation_gre_config $gre_param_list]
                    ::spirent::listToArray $greArgs greArray
                    ##prepare gre addresses

                    set greArgs [array get greArray]
                    set greResult [eval sth::emulation_gre_config $greArgs]
                    set greTopIf [::sth::sthCore::invoke stc::get $device -TopLevelIf-targets]
                    set greLowerIf [::sth::sthCore::invoke stc::get $greTopIf -StackedOnEndpoint-targets]
                    if {[catch {::sth::createGreStack [join $greResult] $device $greLowerIf 1} greIf]} {
                        ::sth::sthCore::processError returnKeyedList "::sth::createGreStack Failed: $greIf" {}
                        return $::sth::sthCore::FAILURE
                    }
                    ::sth::sthCore::invoke stc::config $greTopIf "-StackedOnEndpoint-targets $greIf"
                    set greHandleList [concat $greHandleList $device]
                    ##add gre stack end
                }
            }
            ::sth::sthCore::invoke stc::delete $interfaceGen
        } else {
            if {[info exists configArray(-intf_ip_addr)]} {
                set existdevice [::wrapper::get_device_with_ip_new $configArray(-intf_ip_addr) $i]
                if {$existdevice == ""} {
                    set configArray(-mode) "config"
                }
            }
            set args_to_config [array get configArray]
            set cmdName "::sth::interface_config $args_to_config"
            set tempResult [::spirent::process_cmd $cmdName]
            if {1 == [keylget tempResult status]} {
                if {[keylget tempResult handles] != 0} {
                    set handlesList [concat $handlesList [keylget tempResult handles]]
                    ::wrapper::addL3Forwardinglink [keylget tempResult handles] $i
                    if {[info exist configArray(-intf_ip_addr)]} {
                        set ::spirent::ip_device($configArray(-intf_ip_addr)) [keylget tempResult handles]
                        set configArray(-intf_ip_addr) [::sth::sthCore::updateIpAddress 4  $configArray(-intf_ip_addr) $tempArray(-ipv4AddrStep) 1]
                    }
           
                    if {[info exist configArray(-ipv6_intf_addr)]} {
                        set ::spirent::ip_device([::sth::sthCore::normalizeIPv6Addr $configArray(-ipv6_intf_addr)]) [keylget tempResult handles]
                        set configArray(-ipv6_intf_addr) [::sth::sthCore::updateIpAddress 6  $configArray(-ipv6_intf_addr) $tempArray(-ipv6AddrStep) 1]
                    }
                }
                if {[regexp -nocase "capture" $tempArray(-portRxMode)]} {
                    set capture_ctrl_ret [sth::packet_control -port_handle $i -action start]
                    set capture_status [keylget capture_ctrl_ret status]
                    if {$capture_status == 0} {
                        keylset result status 0
                        set errmsg [concat $errmsg " [keylget capture_ctrl_ret log]"]
                        keylset result log $errmsg
                    }
                }
                if {[info exist configArray(-arp_send_req)] && (1 == $configArray(-arp_send_req))} {
                    keylset result $i.arp_request_success [keylget tempResult arpnd_status]
                }

                if {[array size greArray] > 1} {
                    set gre_param_list [array get greArray]
                    ##add gre stack start
                    set tempList ""
                    set greArgs ""
                    set greArgs [::spirent::emulation_gre_config $gre_param_list]
                    ::spirent::listToArray $greArgs greArray
                    ##prepare gre addresses

                    set greArgs [array get greArray]
                    set greResult [eval sth::emulation_gre_config $greArgs]
                    set hostHandle [keylget tempResult handles]
                    set greTopIf [::sth::sthCore::invoke stc::get $hostHandle -TopLevelIf-targets]
                    set greLowerIf [::sth::sthCore::invoke stc::get $greTopIf -StackedOnEndpoint-targets]
                    if {[catch {::sth::createGreStack [join $greResult] $hostHandle $greLowerIf 1} greIf]} {
                        ::sth::sthCore::processError returnKeyedList "::sth::createGreStack Failed: $greIf" {}
                        return $::sth::sthCore::FAILURE
                    }
                    ::sth::sthCore::invoke stc::config $greTopIf "-StackedOnEndpoint-targets $greIf"
                    set greHandleList [concat $greHandleList $hostHandle]
                    ##add gre stack end
                }
            } else {
                keylset result status 0
                set errmsg [concat $errmsg " [keylget tempResult log]"]
                keylset result log $errmsg
                return [::spirent::ret_port_converter $result]
            }

            #prepare new ip_addr and gw
            if {[info exist configArray(-gateway)]} {
                set configArray(-gateway) [::sth::sthCore::updateIpAddress 4  $configArray(-gateway) $tempArray(-ipv4GwStep) 1]
            }
            if {[info exist configArray(-ipv6_gateway)]} {
                set configArray(-ipv6_gateway) [::sth::sthCore::updateIpAddress 6  $configArray(-ipv6_gateway) $tempArray(-ipv6GwStep) 1]
            }
            if {[info exist configArray(-src_mac_addr)]} {
                set configArray(-src_mac_addr) [::wrapper::incrMacAddress \
                        [::wrapper::macAddressToStcFormat $configArray(-src_mac_addr)] \
                        [::wrapper::macAddressToStcFormat $tempArray(-srcMacAddrStep)]]
            }
            if {[info exist configArray(-vlan_id)]} {
                incr configArray(-vlan_id) $tempArray(-vlanIdStep)
            }
            if {[info exist greArray(-gre_src_addr)]} {
                set greArray(-gre_src_addr) [::sth::sthCore::updateIpAddress 4  $greArray(-gre_src_addr) $tempArray(-greIpv4SrcAddrStep) 1]
            }
            if {[info exist greArray(-gre_dst_addr)]} {
                set greArray(-gre_dst_addr) [::sth::sthCore::updateIpAddress 4  $greArray(-gre_dst_addr) $tempArray(-greIpv4DstAddrStep) 1]
            }
        }
        incr handleIndex
    } ;#each port_handle over
    # currently, the arp information in the returned value hasn't been used in the script, so will not processe it. later if it is used, will process it.
    keylset result handles $handlesList
    keylset result interface_handle $handlesList
    keylset result gre_interface_handle $greHandleList
    keylset result routed_interface_handle $handlesList
    set return_list $result
    return [::spirent::ret_port_converter $result]
}

proc ::spirent::interface_stats {args} {
    set ixia_only_args ""
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    listToArray $args argArray
    set processed_args [array get argArray]
    if {[info exists argArray(-port_handle)]} {
        set port $argArray(-port_handle)
    } else {
        puts "no port_handle in interface_stats"
    }
    set cmdName "sth::interface_stats $processed_args"
    set ret [::spirent::process_cmd $cmdName]
    keylset newkeyedlist $port $ret
    keylset newkeyedlist status [keylget ret status]
    set intf_speed [keylget newkeyedlist $port.intf_speed]
    #here make sure speed is same as interface_config
    if {$intf_speed >= "10000"} {
        set intf_speed "ether[set intf_speed]lan"
    } else {
        set intf_speed "ether[set intf_speed]"
    }
    keylset newkeyedlist $port.intf_speed $intf_speed
    keylset newkeyedlist $port.elapsed_time "N/A"
    keylset newkeyedlist $port.framing "N/A"
    keylset newkeyedlist $port.late_collisions "N/A"
    keylset newkeyedlist $port.portCpuMemory "N/A"
    keylset newkeyedlist $port.rx_collisions "N/A"
    keylset newkeyedlist $port.total_collisions "N/A"
    keylset newkeyedlist $port.fcs_errors [keylget newkeyedlist $port.rx_fcs_error]

    return [::spirent::ret_port_converter $newkeyedlist]
}
proc ::spirent::packet_capture_decode {args} {
    #delete -port_handle
    global return_list
    ::spirent::listToArray $args argArray
    if {[info exist argArray(-port_handle)]} {
        array unset argArray -port_handle
    }
    set args [array get argArray]
    set cmdName "::sth::packet_decode $args"
    set return_list [::spirent::process_cmd $cmdName]
    return $return_list
}

####copy interface_config from ixia::interface_config and default gateway
####currently only add ipv4
proc ::AgtTest::interface_config { args } {
    #options process in this function includes:
    #-arp
    #-mtu
    #-connected_count
    #-data_integrity
    #-integrity_signature
    #-integrity_signature_offset
    #-pgid_offset
    #-port_rx_mode: when it is capture, need to start the capture of this port.
    #-signature_offset
    #-transmit_mode
    #-ndp_send_req
    #-qos_stats
    #-signature
    #-mode
    ######convert physical port

    array set argArray {}
    array set tempArray {}
    array set configArray {}
    array set greArray {}
    set tempArray(-connectedCount) 1
    set tempArray(-portRxMode) ""
    set handleIndex 0
    set result ""
    set tempResult ""
    keylset result status 1
    keylset result log ""
    set errmsg ""
    set handlesList ""

    ##ixia arp_req_timeout default is 10, while STC is 1000. It can help speed up 1 s.
    if {([lsearch $args "-arp_req_timeout"] == -1)} {
        set arpconfig [::sth::sthCore::invoke stc::get project1 -children-arpndconfig]
        ::sth::sthCore::invoke stc::config $arpconfig -TimeOut 10
    }
    
    set args [wrapper::shield_args -total $args -unsupported "enable_ndp"]
    set args [eval ::spirent::port_converter $args]
    ::spirent::listToArray $args argArray

	if {[info exist argArray(-mac_flag)]} {
		unset argArray(-mac_flag)
	}

    if {[info exist argArray(-connected_count)] && [info exist argArray(-vlan_id_count)] \
                && $argArray(-connected_count) == $argArray(-vlan_id_count)} {
        unset argArray(-vlan_id_count)
    }
    if {[info exist argArray(-connected_count)]} {
        set tempArray(-connectedCount) $argArray(-connected_count)
    }
    if {[info exist argArray(-port_rx_mode)]} {
        set tempArray(-portRxMode) $argArray(-port_rx_mode)
    }
    ########add default gateway#########
    if {![info exist argArray(-gateway)]} {
        if {[info exist argArray(-intf_ip_addr)]} {
            set tempList [split $argArray(-intf_ip_addr) .]
            set tempList [lreplace $tempList end end 1]
            set argArray(-gateway) [join $tempList .]
            #set argArray(-gateway) [::wrapper::ConvertIncrementIpAddress $argArray(-intf_ip_addr) -1]
        }
    }
    #add enable_ping_response default as 1
    if {![info exist argArray(-enable_ping_response)]} {
        set argArray(-enable_ping_response) 1
    }
    if {[info exist argArray(-speed)]} {
        switch -- [string tolower $argArray(-speed)] {
            ether10000wan {set argArray(-speed) "ether10000"
                           set argArray(-path_signal_label) "ETHERNET_10G_WAN"}
            ether100gig -
            ether100000lan {set argArray(-speed) "ether100Gig"}
            ether40gig -
            ether40000lan {set argArray(-speed) "ether40Gig"}
            default {regsub -all "lan" $argArray(-speed) {} argArray(-speed)}
        }
    }
    #if the mode is destroy, will not call hltapi, only clear the devices and streams on this ports
    if {[info exist argArray(-mode)]} {
        if {[string equal -nocase "destroy" $argArray(-mode)]} {
            foreach i $argArray(-port_handle) {
                set devices [::sth::sthCore::invoke stc::get $i -AffiliationPort-Sources]
                foreach j $devices {
                    ::sth::sthCore::invoke stc::delete $j
                }
            }
            keylset result status 1
            return [::spirent::ret_port_converter $result]
        }
    } else {
        set argArray(-mode) "config"
        foreach eachPort $argArray(-port_handle) {
            set hosts [::sth::sthCore::invoke stc::get $eachPort "-AffiliationPort-Sources"]
            foreach i $hosts {
                if {[string equal -nocase "port_address" [::sth::sthCore::invoke stc::get $i "-Name"]]} {
                    set argArray(-mode) "modify"
                    break
                }
            }
        }
    }
    #remove the options which can't be supported in spirent hltapi
    #-arp is not supported in spirent hltapi, the mean of this option is to control -arp_send_req, if -arp is 0, then arp_send_req will be ingnored,
    #the default value of arp is 1.
    if {[info exist argArray(-arp)] && (0 == $argArray(-arp))} {
        array unset argArray -arp_send_req
    }
    #the phy_mode only support to be fiber or copper
    if {[info exist argArray(-phy_mode)] && [regexp -nocase "sfp" $argArray(-phy_mode)]} {
        set argArray(-phy_mode) "fiber"
    }
    if {[info exist argArray(-duplex)] && [info exist argArray(-phy_mode)] && ("fiber" == $argArray(-phy_mode))} {
            unset argArray(-duplex)
    }
    if {[info exist argArray(-intf_mode)] && ("lan" == $argArray(-intf_mode))} {
        set argArray(-intf_mode) "ethernet"
    }
    if {[info exist argArray(-port_rx_mode)]} {
        set tempArray(-portRxMode) $argArray(-port_rx_mode)
    }
    #-mtu in ixia hltapi is same with the -control_plane_mtu in spirent hltapi. so replace it if there is such option in the script.
    if {[info exist argArray(-mtu)]} {
        set argArray(-control_plane_mtu) $argArray(-mtu)
        unset argArray(-mtu)
    }
    if {![info exist argArray(-arp_send_req)] && [info exist argArray(-ndp_send_req)]} {
        set argArray(-arp_send_req) $argArray(-ndp_send_req)
        unset argArray(-ndp_send_req)
    }
    if {[info exist argArray(-gateway)] && [regexp {:} $argArray(-gateway)]} {
        set argArray(-ipv6_gateway) $argArray(-gateway)
        unset argArray(-gateway)
    }
    if {[info exist argArray(-vlan_id)] && [regexp {,} $argArray(-vlan_id)]} {
        set vlanIdTemp [split $argArray(-vlan_id) {,}]
        set argArray(-vlan_id) [lindex $vlanIdTemp 1]
        set argArray(-vlan_outer_id) [lindex $vlanIdTemp 0]
    }
    ##for GRE interface
    if {[info exist argArray(-gre_ip_addr)]} {
        set greArray(-gre_src_addr) $argArray(-gre_ip_addr)
        unset argArray(-gre_ip_addr)
        if {[info exist argArray(-intf_ip_addr)]} {
            set greArray(-intf_ip_addr) $argArray(-intf_ip_addr)
        }
        if {[info exist argArray(-intf_ip_addr_step)]} {
            set greArray(-intf_ip_addr_step) $argArray(-intf_ip_addr_step)
        }
    }
    if {[info exist argArray(-gre_ip_prefix_length)]} {
#        set greArray(-gre_ip_prefix_length) $argArray(-gre_ip_prefix_length)
        unset argArray(-gre_ip_prefix_length)
    }
    if {[info exist argArray(-gre_ip_addr_step)]} {
        set greArray(-gre_ip_addr_step) $argArray(-gre_ip_addr_step)
        unset argArray(-gre_ip_addr_step)
    }
    if {[info exist argArray(-gre_dst_ip_addr)]} {
        set greArray(-gre_dst_ip_addr) $argArray(-gre_dst_ip_addr)
        unset argArray(-gre_dst_ip_addr)
    }
    if {[info exist argArray(-gre_dst_ip_addr_step)]} {
        set greArray(-gre_dst_ip_addr_step) $argArray(-gre_dst_ip_addr_step)
        unset argArray(-gre_dst_ip_addr_step)
    }
    if {[info exist argArray(-gateway)] && [info exist argArray(-port_handle)]} {
#        keylset int_gateway_ip_addr_from_port $argArray(-port_handle) $argArray(-gateway)
        set greArray(-gateway) $argArray(-gateway)
    }
    if {[info exists argArray(-intf_ip_addr)] && [info exists argArray(-port_handle)]} {
        for {set i 0} {$i<[llength $argArray(-port_handle)]} {incr i} {
            keylset ::spirent::intf_ip_addr_from_port [lindex $argArray(-port_handle) $i] [lindex $argArray(-intf_ip_addr) $i]
        }
    }
    #ixia::  -arp -connected_count -data_integrity -integrity_signature -integrity_signature_offset -pgid_offset -port_rx_mode -signature_offset
    #-transmit_mode -ndp_send_req -qos_stats -signature

    array unset argArray -action
    array unset argArray -arp
    array unset argArray -connected_count
    array unset argArray -data_integrity
    array unset argArray -gateway_incr_mode
    array unset argArray -ignore_link
    array unset argArray -integrity_signature
    array unset argArray -integrity_signature_offset
    array unset argArray -no_sut
    array unset argArray -pgid_offset
    array unset argArray -port_rx_mode
    array unset argArray -qos_stats
    array unset argArray -sequence_checking
    array unset argArray -sequence_num_offset
    array unset argArray -signature
    array unset argArray -signature_offset
    array unset argArray -signature_start_offset
    array unset argArray -transmit_mode
    array unset argArray -vlan_id_mode
    array unset argArray -auto_configuration
    array unset argArray -laser_on
    array unset argArray -ether_pause_mode

    if {[info exist argArray(-arp_send_req)]} {
        array unset argArray -ndp_send_req
    }
    
    if {[string equal -nocase "config" $argArray(-mode)] && ![info exist argArray(-src_mac_addr)]} {
        set lastdevice [lindex [::sth::sthCore::invoke stc::get project1 -children-emulateddevice] end]
        if {$lastdevice != ""} {
            set macaddr [::sth::sthCore::invoke stc::get [::sth::sthCore::invoke stc::get $lastdevice -children-ethiiif] -SourceMac]
            set argArray(-src_mac_addr) [::wrapper::incrMacAddress $macaddr]
        }
    }

    ## This block of code is used to create multiple address pools using VLANs
    if {[info exists argArray(-vlan_id)] && ([info exists argArray(-num_ipv6_pools)] || [info exists argArray(-num_ipv4_pools)])} {
        set argArray(-create_host) false
        if {[info exists argArray(-port_handle)]} {
            set portH $argArray(-port_handle)
        }
        if {[info exists argArray(-num_ipv4_pools)] && [info exists argArray(-num_ipv6_pools)]} {
            if {$argArray(-num_ipv4_pools) == $argArray(-num_ipv6_pools)} {
                set noofAddrPools $argArray(-num_ipv4_pools)
            } else {
                puts "ERROR : Number of IPv4 and IPv6 pools are different. It should be same"
                keylset result status 0
                return $result
            }
        } elseif {[info exists argArray(-num_ipv4_pools)]} {
            set noofAddrPools $argArray(-num_ipv4_pools)
        } elseif {[info exists argArray(-num_ipv6_pools)]} {
            set noofAddrPools $argArray(-num_ipv6_pools)
        }
        if {[info exists argArray(-vlan_id)] && $argArray(-vlan_id) > 0} {
            set vlanId $argArray(-vlan_id)
        }
        if {[info exists argArray(-vlan_id_inner)] && $argArray(-vlan_id_inner) > 0} {
            set vlanId2 $argArray(-vlan_id_inner)
        }
        if {[info exists argArray(-vlan_id_step)]} {
            set vlanMod $argArray(-vlan_id_step)
            set InPoolMod $argArray(-vlan_id_step)
        } else {
            set InPoolMod 1
            set vlanMod 1
        }
        if {[info exist argArray(-num_intf_ip_addr)] && [info exist argArray(-num_ipv6_intf_addr)]} {
            if {$argArray(-num_intf_ip_addr) == $argArray(-num_ipv6_intf_addr)} {
                set AddrperPool $argArray(-num_intf_ip_addr)
            } else {
                puts "ERROR : Number of IPv4 and IPv6 addresses are different. It should be same"
                keylset result status 0
                return $result
            }
            unset argArray(-num_intf_ip_addr)
            unset argArray(-num_ipv6_intf_addr)
        } elseif {[info exist argArray(-num_intf_ip_addr)]} {
            set AddrperPool $argArray(-num_intf_ip_addr)
            unset argArray(-num_intf_ip_addr)
        } elseif {[info exist argArray(-num_ipv6_intf_addr)]} {
            set AddrperPool $argArray(-num_ipv6_intf_addr)
            unset argArray(-num_ipv6_intf_addr)
        } else {
            set AddrperPool 1
        }

        #Create EmulatedDeviceGenparams
        set Edgp [::sth::sthCore::invoke stc::create EmulatedDeviceGenParams -under project1 -BlockMode ONE_NETWORK_PER_BLOCK -Count $AddrperPool -SelectedPort-targets $portH]
        set ethHandle [::sth::sthCore::invoke stc::create DeviceGenEthIIIfParams -under $Edgp -SrcMac $argArray(-src_mac_addr)]
        set vlanHandle [::sth::sthCore::invoke stc::create DeviceGenVlanIfParams -under $Edgp -Count $noofAddrPools -vlanId $vlanId -IdStep $vlanMod]
        if {[info exists argArray(-vlan_id_inner)]} {
            set vlaninnerHandle [::sth::sthCore::invoke stc::create DeviceGenVlanIfParams -under $Edgp -Count $noofAddrPools -vlanId $vlanId2]
        }

        if {[info exist argArray(-vlan_protocol_id)]} {
            ::sth::sthCore::invoke stc::config $vlanHandle -tpid $argArray(-vlan_protocol_id)
            unset argArray(-vlan_protocol_id)
        }
        if {[info exists argArray(-num_ipv4_pools)]} {
            #IPv4 Address
            # Create IP params
            if {[info exists argArray(-intf_ip_addr)]} {
                set ip $argArray(-intf_ip_addr)
            }
            if {[info exists argArray(-netmask)]} {
                set mask [::sth::Session::getPrefixLength 4 $argArray(-netmask)]
            } else {
                set mask 24
            }
            if {$mask > 24} {
                set networkincr "0.0.0.$InPoolMod"
            } elseif {$mask > 16 && $mask < 25} {
                set networkincr "0.0.$InPoolMod.0"
            } elseif {$mask > 8 && $mask < 17} {
                set networkincr "0.$InPoolMod.0.0"
            } elseif {$mask < 9} {
                set networkincr "$InPoolMod.0.0.0"
            }
            if {[info exists argArray(-gateway)]} {
                set gateway $argArray(-gateway)
                unset argArray(-gateway)
            }
            set ipincr "0.0.0.$InPoolMod"
            set ipv4Handle [::sth::sthCore::invoke stc::create DeviceGenIpv4IfParams -under $Edgp -addr $ip -AddrStep $ipincr -PrefixLength $mask -Gateway $gateway]
            ::sth::sthCore::invoke stc::create DeviceGenLinkedStep -under $ipv4Handle -PropertyId {Addr} -LinkToId {VlanIf1} -Step $networkincr
            if {[info exists argArray(-vlan_id_inner)]} {
                ::sth::sthCore::invoke stc::config $ipv4Handle -DeviceGenStackedOnIf-targets $vlaninnerHandle -DeviceGenTopLevelIf-sources $Edgp
            } else {
                ::sth::sthCore::invoke stc::config $ipv4Handle -DeviceGenStackedOnIf-targets $vlanHandle -DeviceGenTopLevelIf-sources $Edgp
            }
            unset argArray(-num_ipv4_pools)
        }
        if {[info exists argArray(-num_ipv6_pools)]} {
            # IPv6 Address
            # Create IP params
            if {[info exists argArray(-ipv6_intf_addr)]} {
                set ip $argArray(-ipv6_intf_addr)
            }
            if {[info exists argArray(-ipv6_prefix_length)]} {
                set mask $argArray(-ipv6_prefix_length)
            } else {
                set mask 64
            }
            if {$mask > 112} {
                set networkincr "0000:0000:0000:0000:0000:0000:0000:$InPoolMod"
            } elseif {$mask > 96 && $mask < 113} {
                set networkincr "0000:0000:0000:0000:0000:0000:$InPoolMod:0000"
            } elseif {$mask > 80 && $mask < 97} {
                set networkincr "0000:0000:0000:0000:0000:$InPoolMod:0000:0000"
            } elseif {$mask > 64 && $mask < 81} {
                set networkincr "0000:0000:0000:0000:$InPoolMod:0000:0000:0000"
            } elseif {$mask > 48 && $mask < 65} {
                set networkincr "0000:0000:0000:$InPoolMod:0000:0000:0000:0000"
            } elseif {$mask > 32 && $mask < 49} {
                set networkincr "0000:0000:$InPoolMod:0000:0000:0000:0000:0000"
            } elseif {$mask > 16 && $mask < 33} {
                set networkincr "0000:$InPoolMod:0000:0000:0000:0000:0000:0000"
            } elseif {$mask < 17} {
                set networkincr "$InPoolMod:0000:0000:0000:0000:0000:0000:0000"
            }
            if {[info exists argArray(-ipv6_gateway)]} {
                set gateway $argArray(-ipv6_gateway)
                unset argArray(-ipv6_gateway)
            }
            set ipincr "0000::$InPoolMod"
            set ipv6Handle [::sth::sthCore::invoke stc::create DeviceGenIpv6IfParams -under $Edgp -addr $ip -AddrStep $ipincr -PrefixLength $mask -Gateway $gateway]
            set ipv6Handle1 [::sth::sthCore::invoke stc::create DeviceGenIpv6IfParams -under $Edgp -AddrType LINK_LOCAL -AutoAddrEnable TRUE -UseEui64LinkLocalAddress TRUE]
            ::sth::sthCore::invoke stc::create DeviceGenLinkedStep -under $ipv6Handle -PropertyId {Addr} -LinkToId {VlanIf1} -Step $networkincr
            if {[info exists argArray(-vlan_id_inner)]} {
                ::sth::sthCore::invoke stc::config $ipv6Handle -DeviceGenStackedOnIf-targets $vlaninnerHandle -DeviceGenTopLevelIf-sources $Edgp
                ::sth::sthCore::invoke stc::config $ipv6Handle1 -DeviceGenStackedOnIf-targets $vlaninnerHandle -DeviceGenTopLevelIf-sources $Edgp
            } else {
                ::sth::sthCore::invoke stc::config $ipv6Handle -DeviceGenStackedOnIf-targets $vlanHandle -DeviceGenTopLevelIf-sources $Edgp
                ::sth::sthCore::invoke stc::config $ipv6Handle1 -DeviceGenStackedOnIf-targets $vlanHandle -DeviceGenTopLevelIf-sources $Edgp
            }
            unset argArray(-num_ipv6_pools)
        }
        ## Stacking the DeciveParams
        ::sth::sthCore::invoke stc::config $vlanHandle -DeviceGenStackedOnIf-targets $ethHandle
        if {[info exists argArray(-vlan_id_inner)]} {
            ::sth::sthCore::invoke stc::config $vlaninnerHandle -DeviceGenStackedOnIf-targets $vlanHandle
        }
        array set ouputarray [::sth::sthCore::invoke stc::perform devicegenconfigexpand -deleteexisting no -genparams $Edgp]
        set handlesList [concat $handlesList $ouputarray(-ReturnList)]
        array unset argArray -vlan_id_inner
    } else {
        array unset argArray -num_intf_ip_addr
        array unset argArray -num_ipv6_intf_addr
        array unset argArray -num_ipv4_pools
        array unset argArray -num_ipv6_pools
    }

    #ixia support list for the port_handle, and also the vlaue of other option can be a list, but spirent not support port handle list,
    #so need to handle it here, also the retured value need to be processed.
    foreach i $argArray(-port_handle) {
        set args_to_config ""
        foreach j [array name argArray] {
            if {[llength $argArray($j)]>1} {
                set configArray($j) [lindex $argArray($j) $handleIndex]
            } else {
                set configArray($j) $argArray($j)
            }
        }
        set args_to_config [array get configArray]
        set cmdName "::sth::interface_config $args_to_config"
        set tempResult [::spirent::process_cmd $cmdName]
        if {1 == [keylget tempResult status]} {
            if {[keylget tempResult handles] != 0} {
                set handlesList [concat $handlesList [keylget tempResult handles]]
                if {[info exist configArray(-intf_ip_addr)]} {
                    set ::spirent::ip_device($configArray(-intf_ip_addr)) [keylget tempResult handles]
                }

                if {[info exist configArray(-ipv6_intf_addr)]} {
                    set ::spirent::ip_device([::sth::sthCore::normalizeIPv6Addr $configArray(-ipv6_intf_addr)]) [keylget tempResult handles]
                }
            }
            if {[regexp -nocase "capture" $tempArray(-portRxMode)]} {
                set capture_ctrl_ret [sth::packet_control -port_handle $i -action start]
                set capture_status [keylget capture_ctrl_ret status]
                if {$capture_status == 0} {
                    keylset result status 0
                    set errmsg [concat $errmsg " [keylget capture_ctrl_ret log]"]
                    keylset result log $errmsg
                }
            }
        } else {
            keylset result status 0
            set errmsg [concat $errmsg " [keylget tempResult log]"]
            keylset result log $errmsg
        }
        incr handleIndex
    }

    # currently, the arp information in the returned value hasn't been used in the script, so will not processe it. later if it is used, will process it.
    keylset result handles $handlesList
    keylset result interface_handle $handlesList
    keylset result port_handle $argArray(-port_handle)
    return $result
}

proc ::ixia::traffic_config { args } {
    
    ##check whether it's more than 4 modifier in DX card.
    ##if yes, need create seperate streamblock
    ##for now, only consider about all counter are same
    set args [eval ::spirent::port_converter $args]
    ::spirent::listToArray $args argArray
    if {[info exist argArray(-mac_dst_mode)] && [string equal -nocase "discovery" $argArray(-mac_dst_mode)]} {
        array unset argArray -mac_dst_count
    }
    if {![info exist argArray(-mac_dst)] && [info exist argArray(-ip_dst_addr)]} {
        if {[regexp "^(\\d+)\." $argArray(-ip_dst_addr) _ firstoct]} {
            if {$firstoct >= 224 && $firstoct <= 239} {
                set argArray(-mac_dst) [::wrapper::ip_to_mac $argArray(-ip_dst_addr) ":"]
            }
        }
    }
    set args [array get argArray]
    set cmdName "::spirent::count_traffic_config_modifier $args"
    set modifier_list [eval $cmdName]
    
    set cmdName "::spirent::traffic_config_step_power2 $args"
    set StepIsPower2 [eval $cmdName]
    
    if {(([llength $modifier_list] > 4) && (($::spirent::module_type eq "DX") || ($::spirent::module_type eq "STCV"))) ||
        (($::spirent::module_type eq "DX") && ([keylget StepIsPower2 flag] == 0))} {
        ::spirent::listToArray $args argArray
        
        set port_level_rate 0
        
        ##here the default traffic speed is the 100% port bandwidth
        if {![info exist argArray(-rate_bps)] && ![info exist argArray(-rate_percent)] && ![info exist argArray(-rate_pps)] && [info exists argArray(-mode)] && $argArray(-mode) == "create"} {
            if {! ([info exists argArray(-type)] && [string equal -nocase "profile" $argArray(-type)])} {
                if {[info exist argArray(-port_handle)]} {
                    set porthndl $argArray(-port_handle)
                    set genconfig [::sth::sthCore::invoke stc::get [::sth::sthCore::invoke stc::get $porthndl -children-Generator] -children-GeneratorConfig]
                    ::sth::sthCore::invoke stc::config $genconfig -SchedulingMode PORT_BASED -LoadUnit PERCENT_LINE_RATE -FixedLoad 100
                }
                set port_level_rate 1
            }
        }
        
        if {[keylget StepIsPower2 flag] == 0} {
            set key [keylget StepIsPower2 key]
            set streamblocknum $argArray(-$key\_count)
            
            if {($port_level_rate == 0) && ([info exist argArray(-rate_bps)])} {
                set argArray(-rate_bps) [expr $argArray(-rate_bps) / $streamblocknum]
            }
            if {($port_level_rate == 0) && ([info exist argArray(-rate_percent)])} {
                set argArray(-rate_percent) [expr $argArray(-rate_percent) / $streamblocknum]
            }
            if {($port_level_rate == 0) && ([info exist argArray(-rate_pps)])} {
                set argArray(-rate_pps) [expr $argArray(-rate_pps) / $streamblocknum]
            }
            
            ##handle the first streamblock
            array unset argArray -$key\_count
            
            set stepValue $argArray(-$key\_step)
            array unset argArray -$key\_step
            
            set cmd "::ixia::traffic_config [array get argArray]"
            set ret [eval $cmd]
            if { ![keylget ret status] } {
                return $ret
            }
            
            ##handle the loop streamblocks
            for {set i 1} {$i < $streamblocknum} {incr i} {
                switch -exact -- $key {
                    arp_dst_hw -
                    arp_src_hw -
                    mac_dst -
                    mac_src {
                        if { ![info exists stepValue] } {
                            set argArray(-$key\_step) 1
                        }
                        set argArray(-$key) [::wrapper::incrMacAddress \
                        [::wrapper::macAddressToStcFormat $argArray(-$key)] \
                        [::wrapper::macAddressToStcFormat $stepValue]]
                    }
                    ip_dst -
                    igmp_group -
                    inner_ip_dst -
                    inner_ip_src -
                    ip_src {
                        if { ![info exists stepValue] } {
                            set argArray(-$key\_step) "0.0.0.1"
                        }
                        set argArray(-$key\_addr) [::sth::sthCore::updateIpAddress 4  $argArray(-$key\_addr) $stepValue 1]
                    }
                    ipv6_src -
                    ipv6_src {
                        if { ![info exists stepValue] } {
                            set argArray(-$key\_step) "0::1"
                        }
                        set argArray(-$key\_addr) [::sth::sthCore::updateIpAddress 6  $argArray(-$key\_addr) $stepValue 1]
                    }
                    ip_dscp -
                    vci -
                    vpi -
                    ip_precedence -
                    mpls_ttl -
                    tcp_src_port -
                    tcp_dst_port -
                    udp_dst_port -
                    udp_src_port -
                    vlan_user_priority -
                    vlan_id {
                        if { ![info exists stepValue] } {
                            set argArray(-$key\_step) 1
                        }
                        incr argArray(-$key) $stepValue
                    }
                    default {
                        puts "Warning: $key\_count is ignored in ixia::traffic_config"
                    }
                }

                set cmd "::ixia::traffic_config [array get argArray]"
                set retloop [eval $cmd]
                if {[keylget retloop status] } {
                    set streamblocklist [keylget ret stream_id]
                    lappend streamblocklist [keylget retloop stream_id]
                    keylset ret stream_id $streamblocklist
                    set trafficitemlist [keylget ret traffic_item]
                    lappend trafficitemlist [keylget retloop traffic_item]
                    keylset ret traffic_item $trafficitemlist
                } else {
                    return $retloop
                }
            }
            return $ret
            
        }
        set streamblocknum $argArray(-[lindex $modifier_list 0]_count)
        
        if {($port_level_rate == 0) && ([info exist argArray(-rate_bps)])} {
            set argArray(-rate_bps) [expr $argArray(-rate_bps) / $streamblocknum]
        }
        if {($port_level_rate == 0) && ([info exist argArray(-rate_percent)])} {
            set argArray(-rate_percent) [expr $argArray(-rate_percent) / $streamblocknum]
        }
        if {($port_level_rate == 0) && ([info exist argArray(-rate_pps)])} {
            set argArray(-rate_pps) [expr $argArray(-rate_pps) / $streamblocknum]
        }
        
        ##handle the first streamblock
        foreach modifier $modifier_list {
            array unset argArray -$modifier\_count
        }
        set cmd "::ixia::traffic_config [array get argArray]"
        set ret [eval $cmd]
        if { ![keylget ret status] } {
            return $ret
        }
        
        ##handle the loop streamblocks
        for {set i 1} {$i < $streamblocknum} {incr i} {
            foreach modifier $modifier_list {
                switch -exact -- $modifier {
                    arp_dst_hw -
                    arp_src_hw -
                    mac_dst -
                    mac_src {
                        if { ![info exists argArray(-$modifier\_step)] } {
                            set argArray(-$modifier\_step) 1
                        }
                        set argArray(-$modifier) [::wrapper::incrMacAddress \
                        [::wrapper::macAddressToStcFormat $argArray(-$modifier)] \
                        [::wrapper::macAddressToStcFormat $argArray(-$modifier\_step)]]
                    }
                    ip_dst -
                    igmp_group -
                    inner_ip_dst -
                    inner_ip_src -
                    ip_src {
                        if { ![info exists argArray(-$modifier\_step)] } {
                            set argArray(-$modifier\_step) "0.0.0.1"
                        }
                        set argArray(-$modifier\_addr) [::sth::sthCore::updateIpAddress 4  $argArray(-$modifier\_addr) $argArray(-$modifier\_step) 1]
                    }
                    ipv6_src -
                    ipv6_src {
                        if { ![info exists argArray(-$modifier\_step)] } {
                            set argArray(-$modifier\_step) "0::1"
                        }
                        set argArray(-$modifier\_addr) [::sth::sthCore::updateIpAddress 6  $argArray(-$modifier\_addr) $argArray(-$modifier\_step) 1]
                    }
                    ip_dscp -
                    vci -
                    vpi -
                    ip_precedence -
                    mpls_ttl -
                    tcp_src_port -
                    tcp_dst_port -
                    udp_dst_port -
                    udp_src_port -
                    vlan_user_priority -
                    vlan_id {
                        if { ![info exists argArray(-$modifier\_step)] } {
                            set argArray(-$modifier\_step) 1
                        }
                        incr argArray(-$modifier) $argArray(-$modifier\_step)
                    }
                    default {
                        puts "Warning: $modifier\_count is ignored in ixia::traffic_config"
                    }
                }
            }
            set cmd "::ixia::traffic_config [array get argArray]"
            set retloop [eval $cmd]
            if {[keylget retloop status] } {
                set streamblocklist [keylget ret stream_id]
                lappend streamblocklist [keylget retloop stream_id]
                keylset ret stream_id $streamblocklist
                set trafficitemlist [keylget ret traffic_item]
                lappend trafficitemlist [keylget retloop traffic_item]
                keylset ret traffic_item $trafficitemlist
            } else {
                return $retloop
            }
        }
        return $ret
    }
    
    set ::spirent::pkts_per_burst 0
    array set argArray {}
    array set tempArray {}
    array set vlanArray {}
    set tempArgs ""

    regsub -all "incr_global_site_level" $args "increment" args
    #process the "-mpls_labels" with null value
    if {[set index [lsearch $args "-mpls_labels"]] > -1} {
        set value [lindex $args [expr $index + 1]]
        if {$value == "" || [regexp ^- $value]} {
            set args [lreplace $args $index $index]
        }
    }
    ::spirent::listToArray $args argArray
    
    ##here the default traffic speed is the 100% port bandwidth
    if {![info exist argArray(-rate_bps)] && ![info exist argArray(-rate_percent)] && ![info exist argArray(-rate_pps)] && [info exists argArray(-mode)] && $argArray(-mode) == "create"} {
        if {! ([info exists argArray(-type)] && [string equal -nocase "profile" $argArray(-type)])} {
            if {[info exist argArray(-port_handle)]} {
            set porthndl $argArray(-port_handle)
                set genconfig [::sth::sthCore::invoke stc::get [::sth::sthCore::invoke stc::get $porthndl -children-Generator] -children-GeneratorConfig]
                ::sth::sthCore::invoke stc::config $genconfig -SchedulingMode PORT_BASED -LoadUnit PERCENT_LINE_RATE -FixedLoad 100
            }
        }
    }
    
    if { [info exists argArray(-vlan_enable)] } {
        # Disable vlans.
        if {! $argArray(-vlan_enable) } {
            array unset argArray -vlan_id
            array unset argArray -vlan_id_count
            array unset argArray -vlan_id_mode
            array unset argArray -vlan_id_step
        }
        array unset argArray -vlan_enable
    }
    if {[info exist argArray(-vlan)]} {
        set tempArray(-vlan) $argArray(-vlan)
    }
##shield field
    catch {set tempArray(-duration) $argArray(-duration)}
    catch {set tempArray(-udf1_counter_init_value) $argArray(-udf1_counter_init_value)}
    catch {set tempArray(-udf1_counter_mode) $argArray(-udf1_counter_mode)}
    catch {set tempArray(-udf1_counter_repeat_count) $argArray(-udf1_counter_repeat_count)}
    catch {set tempArray(-udf1_counter_step) $argArray(-udf1_counter_step)}
    catch {set tempArray(-udf1_counter_type) $argArray(-udf1_counter_type)}
    catch {set tempArray(-udf1_counter_up_down) $argArray(-udf1_counter_up_down)}
    catch {set tempArray(-udf1_offset) $argArray(-udf1_offset)}
    catch {set tempArray(-udf1_mode) $argArray(-udf1_mode)}
    catch {set tempArray(-vlan) $argArray(-vlan)}
    array unset argArray -adjust_rate

    ###allow_self_destined means whether send to itself (tx_port_sending_traffic_to_self_en)
    if {[info exist argArray(-allow_self_destined)] && (1 == $argArray(-allow_self_destined))} {
        set argArray(-tx_port_sending_traffic_to_self_en) true
    }
    array unset argArray -allow_self_destined
	array unset argArray -circuit_type
    array unset argArray -data_pattern_mode
    array unset argArray -duration
	array unset argArray -destination_filter
	array unset argArray -egress_tracking
    array unset argArray -enable_auto_detect_instrumentation
    array unset argArray -enable_data_integrity
    array unset argArray -enable_dynamic_mpls_labels
    array unset argArray -enable_pgid
    array unset argArray -enable_time_stamp
    array unset argArray -enable_udf1
    array unset argArray -enable_udf4
	array unset argArray -endpointset_count
	array unset argArray -enforce_min_gap
	array unset argArray -frame_rate_distribution_port
	array unset argArray -frame_rate_distribution_stream
	array unset argArray -frame_sequencing
	array unset argArray -frame_sequencing_mode
	array unset argArray -frame_size_distribution
    
    ##mapping it into arp option
    if {[info exist argArray(-global_dest_mac_retry_count)] && (1 == $argArray(-global_dest_mac_retry_count))} {
        set arpconfig [::sth::sthCore::invoke stc::get project1 -children-arpndconfig]
        ::sth::sthCore::invoke stc::config $arpconfig -RetryCount $argArray(-global_dest_mac_retry_count)
    }
	array unset argArray -global_dest_mac_retry_count
	array unset argArray -global_dest_mac_retry_delay
	array unset argArray -global_enable_dest_mac_retry
    
    array unset argArray -global_display_mpls_current_label_value
	array unset argArray -global_enable_mac_change_on_fly
	array unset argArray -global_enable_min_frame_size
	array unset argArray -global_enable_staggered_transmit
	array unset argArray -global_enable_stream_ordering
	array unset argArray -global_large_error_threshhold
	array unset argArray -global_max_traffic_generation_queries
	array unset argArray -global_mpls_label_learning_timeout
	array unset argArray -global_refresh_learned_info_before_apply
	array unset argArray -global_stream_control
	array unset argArray -global_stream_control_iterations
	array unset argArray -global_use_tx_rx_sync
	array unset argArray -global_wait_time
	array unset argArray -hosts_per_net
	array unset argArray -ip_cost
	array unset argArray -ip_cost_mode
	array unset argArray -ip_cost_tracking
	array unset argArray -ip_cu_mode
	array unset argArray -ip_cu_tracking
	array unset argArray -ip_delay
	array unset argArray -ip_delay_mode
	array unset argArray -ip_delay_tracking
	array unset argArray -ip_dst_tracking
	array unset argArray -ip_id_tracking
	array unset argArray -ip_id_mode
    array unset argArray -frame_sequencing_offset
    array unset argArray -integrity_signature_offset
	array unset argArray -ip_fragment_last
	array unset argArray -ip_fragment_last_mode
	array unset argArray -ip_fragment_last_tracking
	array unset argArray -ip_fragment_mode
	array unset argArray -ip_fragment_offset_mode
	array unset argArray -ip_fragment_offset_tracking
	array unset argArray -ip_fragment_tracking
	array unset argArray -ip_precedence_tracking
	array unset argArray -ip_reliability
	array unset argArray -ip_reliability_mode
	array unset argArray -ip_reliability_tracking
	array unset argArray -ip_reserved
	array unset argArray -ip_reserved_mode
	array unset argArray -ip_reserved_tracking
	array unset argArray -ip_src_tracking
	array unset argArray -ip_throughput
	array unset argArray -ip_throughput_mode
	array unset argArray -ip_throughput_tracking
	array unset argArray -ip_ttl_mode
	array unset argArray -ip_ttl_tracking
    array unset argArray -ipv6_dst_mask
    array unset argArray -ipv6_src_mask
	array unset argArray -mac_src_tracking
	array unset argArray -mac_dst_tracking
	array unset argArray -loop_count
	array unset argArray -merge_destinations
	array unset argArray -min_gap_bytes
    array unset argArray -mpls
    array unset argArray -mpls_bottom_stack_bit_tracking
    array unset argArray -mpls_exp_bit_tracking
    array unset argArray -mpls_labels_tracking
    array unset argArray -mpls_ttl_tracking
    array unset argArray -preamble_size_mode
    array unset argArray -pgid_offset
    array unset argArray -pgid_value
    array unset argArray -qos_type_ixn
	array unset argArray -route_mesh
    array unset argArray -signature
    array unset argArray -signature_offset
	array unset argArray -source_filter
    ##none|fully|one_to_one|many_to_many
    set traffic_pattern ""
    if {[info exist argArray(-src_dest_mesh)]} {
        if {[regexp -nocase "fully" $argArray(-src_dest_mesh)]} {
            set traffic_pattern "MESH"
        } elseif {[regexp -nocase "many_to_many" $argArray(-src_dest_mesh)]} {
            set traffic_pattern "BACKBONE"
        } elseif {[regexp -nocase "one_to_one" $argArray(-src_dest_mesh)]} {
            set traffic_pattern "PAIR"
        }
    }
	array unset argArray -src_dest_mesh
    array unset argArray -tcp_data_offset_mode
	array unset argArray -tx_delay_unit
    array unset argArray -udf1_counter_init_value
    array unset argArray -udf1_counter_mode
    array unset argArray -udf1_counter_repeat_count
    array unset argArray -udf1_counter_step
    array unset argArray -udf1_counter_type
    array unset argArray -udf1_counter_up_down
    array unset argArray -udf1_mode
    array unset argArray -udf1_offset
    array unset argArray -udf4_counter_init_value
    array unset argArray -udf4_counter_repeat_count
    array unset argArray -udf4_counter_step
    array unset argArray -udf4_counter_type
    array unset argArray -udf4_inner_repeat_count
    array unset argArray -udf4_inner_repeat_value
    array unset argArray -udf4_inner_step
    array unset argArray -udf4_mode
    array unset argArray -udf4_offset
    array unset argArray -vlan
	array unset argArray -ip_total_length_mode
	array unset argArray -transmit_distribution
	array unset argArray -tx_delay
    array unset argArray -vlan_user_priority_tracking
    array unset argArray -vlan_user_priority_mode
    array unset argArray -vlan_cfi_mode
    array unset argArray -vlan_cfi_tracking
    array unset argArray -vlan_id_tracking
    #array unset argArray -tx_mode
    array unset argArray -ipv6_flow_version_tracking
    array unset argArray -ipv6_flow_label
    array unset argArray -ipv6_flow_version_mode
    array unset argArray -ipv6_traffic_class_mode
    array unset argArray -ipv6_flow_label_tracking
    array unset argArray -ipv6_flow_version
    array unset argArray -ipv6_dst_tracking
    array unset argArray -ipv6_src_tracking
    array unset argArray -ipv6_hop_limit_mode
    array unset argArray -ipv6_hop_limit_tracking
    array unset argArray -ipv6_traffic_class_tracking
    array unset argArray -ipv6_flow_label_mode
    array unset argArray -traffic_generate
    
    set preamble_custom_size ""
    if {[info exist argArray(-preamble_custom_size)]} {
        set preamble_custom_size $argArray(-preamble_custom_size)
    	array unset argArray -preamble_custom_size
    }
    
    ##for ip_cu: Configures 2-bit Diff-serv currently unused(CU) field in IP header.
    ##mapping to diffserv -reserved
    ##but script is using -qos_type_ixn {tos}, so ignore here
    if {[info exist argArray(-ip_cu)]} {
        set ip_cu $argArray(-ip_cu)
    	array unset argArray -ip_cu
    }
    
    variable ::spirent::topoHdl_devicegroupHdl

    #### For NGPF traffic, set all streamblock as inactive firstly.
    set activeFlag TRUE
    
    if {[info exists argArray(-emulation_src_handle)]} {
        
        set ipv4grouplist ""
        set port_flag 0
        set port_handle ""
        if {![info exists argArray(-port_handle)]} {
            set port_flag 1
        }
        foreach eachsrc $argArray(-emulation_src_handle) {
            if {[regexp -nocase "Topology_" $eachsrc] } {
                set activeFlag FALSE
                set Topology_device [::sth::sthCore::invoke stc::get $::spirent::topoHdl_devicegroupHdl($eachsrc) -groupmembership-Targets]
                #puts "\n MODE: $argArray(-mode) \n"
	        ## if traffic_generator is ixnetwork_540, then port_handle is not passed.
	        ## But port_handle is compulsary for Spirent, so below code gets the port_handle by using the emulation_src_handle
	        if {[info exist argArray(-traffic_generator)]} {
		    if {[string equal -nocase "ixnetwork_540" $argArray(-traffic_generator)] && [string equal -nocase "create" $argArray(-mode)]} {
	                array set resultarray [::sth::sthCore::invoke stc::perform GetObjectInfo -Object $Topology_device]
			set temp $resultarray(-Object)
			array set resultarray [::sth::sthCore::invoke stc::get $temp]
                        if {$port_flag} {
                            if {![regexp -nocase $resultarray(-affiliationport-Targets) $port_handle ]} {
                                lappend port_handle $resultarray(-affiliationport-Targets)
                            }
                        }
			unset argArray(-traffic_generator)
		    }
	        }
                lappend ipv4grouplist $Topology_device
            }
			if {[regexp -nocase "devicegroup" $eachsrc] } {
                set activeFlag FALSE
                set Topology_device [::sth::sthCore::invoke stc::get $eachsrc -groupmembership-Targets]
                
				if {[info exist argArray(-traffic_generator)]} {
					if {[string equal -nocase "ixnetwork_540" $argArray(-traffic_generator)] && [string equal -nocase "create" $argArray(-mode)]} {
						array set resultarray [::sth::sthCore::invoke stc::perform GetObjectInfo -Object $Topology_device]
						set temp $resultarray(-Object)
						array set resultarray [::sth::sthCore::invoke stc::get $temp]
						if {$port_flag} {
							if {![regexp -nocase $resultarray(-affiliationport-Targets) $port_handle ]} {
								lappend port_handle $resultarray(-affiliationport-Targets)
							}
						}
						unset argArray(-traffic_generator)
					}
				}
                lappend ipv4grouplist $Topology_device
            }
            if {[regexp -nocase {(::ixNet::OBJ-\/vport:\d+)\/([a-z]+)\/} $eachsrc]} {
                set handle [split $eachsrc "/"]
                if {[lindex $handle 2] eq "protocols" } {
                    set proto [lindex $handle 3]
                    set hport [lindex $handle 1]
                    set index [lindex [split $hport ":"] 1]
                    set port "port$index"
                    if {$port_flag} {
                        if {![regexp -nocase $port $port_handle]} {
                            lappend port_handle $port
                        }
                    }
                    foreach device [::sth::sthCore::invoke stc::get $port -affiliationport-Sources] {
                        set result  [::sth::sthCore::invoke stc::get $device -children]
                        set var  "routerconfig"
                        if { [regexp -nocase $proto $result]} {
                            foreach temp $result {
                                if {[regexp -nocase $var $temp]} {
                                    foreach temp1 [::sth::sthCore::invoke stc::get $temp -children]  {
                                        if { $proto  eq "ospf" } {
                                            if {[regexp -nocase "externallsablock" $temp1 ] || [regexp -nocase "summarylsablock" $temp1]} {
                                                lappend  ipv4grouplist $temp1
                                            } elseif {[regexp -nocase "routerlsa" $temp1 ] } {
                                                lappend  ipv4grouplist $temp1
                                            }  
                                            
                                        } elseif {$proto  eq "isis"} {
                                            if {[regexp -nocase "isislspconfig" $temp1 ] } {
                                                foreach results3 [::sth::sthCore::invoke stc::get $temp1 -children] {
                                                    if {[regexp -nocase "ipv4isisroutesconfig" $results3]} {
                                                        lappend  ipv4grouplist [::sth::sthCore::invoke ::stc::get $results3 -children-Ipv4NetworkBlock]
                                                        
                                                    
                                                    } elseif {[regexp -nocase "ipv6isisroutesconfig" $results3]} {
                                                        lappend  ipv4grouplist [::sth::sthCore::invoke ::stc::get $results3 -children-Ipv6NetworkBlock]
                                                        
                                                    
                                                    }
                                                }
                                            }
                                        } elseif {[regexp -nocase "routeconfig" $temp1 ]} {
                                            lappend ipv4grouplist $temp1
                                        }
                                        
                                    }
                                }
                                    
                                    
                            }
                        }
                           
                           
                    }
                            
                    
                    
                }
                    
                
            } elseif {[regexp -nocase {(::ixNet::OBJ-\/vport:\d+)/} $eachsrc] } {
                set handle [split $eachsrc "/"]
                
                if {[lindex $handle 2] eq "protocols" } {
                    set hport [lindex $handle 1]
                    set index [lindex [split $hport ":"] 1]
                    set port "port$index"
                    if {$port_flag} {
                        if {![regexp -nocase $port $port_handle]} {
                            lappend port_handle $port
                        }
                    }
                    set devices  [::sth::sthCore::invoke stc::get $port -affiliationport-Sources] 
                           
                } elseif {[lindex $handle 2] eq "interface" } {
                    set hport [lindex $handle 1]
                    set index [lindex [split $hport ":"] 1]
                    set port "port$index"
                    if {$port_flag} {
                       if {![regexp -nocase $port $port_handle]} {
                            lappend port_handle $port
                        }
                    }
                    set devices  [::sth::sthCore::invoke stc::get $port -affiliationport-Sources] 
                        
                }
                foreach device $devices {
                    set reslut [::sth::sthCore::invoke stc::get $device -children]
                    if {[regexp -nocase  {igmphostconfig} $reslut]} {
                        lappend ipv4grouplist [::sth::sthCore::invoke stc::get $device.igmphostconfig.igmpgroupmembership -subscribedgroups-Targets]
                    } elseif {[regexp -nocase  {MldHostConfig} $reslut]} {
                        lappend ipv4grouplist [::sth::sthCore::invoke stc::get $device.MldHostConfig.MldGroupMembership -subscribedgroups-Targets]
                    } else {
                        lappend ipv4grouplist $device
                    }
                    
                }
                
            }
            if {[regexp -nocase  {port}  $eachsrc]} {
                
                foreach hport [::sth::sthCore::invoke stc::get project1 -children-port] {
                    if {$hport eq $eachsrc} {
                        if {$port_flag} {
                            if {![regexp -nocase $port $port_handle]} {
                                lappend port_handle $port
                            }
                        }
                        foreach device [::sth::sthCore::invoke $port -affiliationport-Sources] {
                            set reslut [::sth::sthCore::invoke stc::get $device -children]
                            if {[regexp -nocase  {igmphostconfig} $reslut]} {
                                lappend ipv4grouplist [::sth::sthCore::invoke stc::get $device.igmphostconfig.igmpgroupmembership -subscribedgroups-Targets]
                            } elseif {[regexp -nocase  {MldHostConfig} $reslut]} {
                                lappend ipv4grouplist [::sth::sthCore::invoke stc::get $device.MldHostConfig.MldGroupMembership -subscribedgroups-Targets]
                            } else {
                                lappend ipv4grouplist $device
                            }
                        }
                        
                    }
                }
            
            }
            
        }
        if { $ipv4grouplist ne "" } {
            set argArray(-emulation_src_handle) $ipv4grouplist
        }
        if {$port_flag && $port_handle ne ""} {
            set argArray(-port_handle) $port_handle
        }
    }
    
    
    
    
    if {[info exists argArray(-emulation_dst_handle)]} {
       
        set ipv4grouplist ""
        foreach eachDst $argArray(-emulation_dst_handle) {
            if {[regexp -nocase "Topology_" $eachDst] } {
                set activeFlag FALSE
	        lappend ipv4grouplist [::sth::sthCore::invoke stc::get $::spirent::topoHdl_devicegroupHdl($eachDst) -groupmembership-Targets]
            }
			if {[regexp -nocase "devicegroup" $eachDst] } {
                set activeFlag FALSE
				lappend ipv4grouplist [::sth::sthCore::invoke stc::get $eachDst -groupmembership-Targets]
            }
            if {[regexp -nocase {(::ixNet::OBJ-\/vport:\d+)\/([a-z]+)\/} $eachDst]} {
                set handle [split $eachDst "/"]
                if {[lindex $handle 2] eq "protocols" } {
                    set proto [lindex $handle 3]
                    
                    set hport [lindex $handle 1]
                    set index [lindex [split $hport ":"] 1]
                    set port "port$index"
                   
                    foreach device [::sth::sthCore::invoke stc::get $port -affiliationport-Sources] {
                        set result  [::sth::sthCore::invoke stc::get $device -children]
                        set var  "routerconfig"
                        if { [regexp -nocase $proto $result]} {
                            foreach temp $result {
                                if {[regexp -nocase $var $temp]} {
                                    foreach temp1 [::sth::sthCore::invoke stc::get $temp -children]  {
                                        if { $proto  eq "ospf" } {
                                            if {[regexp -nocase "externallsablock" $temp1 ] || [regexp -nocase "summarylsablock" $temp1]} {
                                                lappend  ipv4grouplist $temp1
                                            } elseif {[regexp -nocase "routerlsa" $temp1 ] } {
                                                
                                                lappend  ipv4grouplist $temp1
                                            }  
                                            
                                        } elseif {$proto  eq "isis"} {
                                            if {[regexp -nocase "isislspconfig" $temp1 ] } {
                                                foreach results3 [::sth::sthCore::invoke stc::get $temp1 -children] {
                                                    if {[regexp -nocase "ipv4isisroutesconfig" $results3]} {
                                                        lappend  ipv4grouplist [::sth::sthCore::invoke ::stc::get $results3 -children-Ipv4NetworkBlock]
                                                        
                                                    } elseif {[regexp -nocase "ipv6isisroutesconfig" $results3]} {
                                                        lappend  ipv4grouplist [::sth::sthCore::invoke ::stc::get $results3 -children-Ipv6NetworkBlock]
                                                        
                                                    
                                                    }
                                                }
                                            }
                                        } elseif {[regexp -nocase "routeconfig" $temp1 ]} {
                                            lappend ipv4grouplist $temp1
                                        }
                                        
                                    }
                                }
                                    
                                    
                            }
                        }
                           
                           
                    }
                            
                    
                    
                }
                    
                
            } elseif {[regexp -nocase {(::ixNet::OBJ-\/vport:\d+)/} $eachsrc] } {
                set handle [split $eachDst "/"]
                if {[lindex $handle 2] eq "protocols" } {
                    
                    set hport [lindex $handle 1]
                    set index [lindex [split $hport ":"] 1]
                    set port "port$index"
                    
                    set devices [::sth::sthCore::invoke stc::get $port -affiliationport-Sources] 
                    
                } elseif {[lindex $handle 2] eq "interface" } {
                   
                    set hport [lindex $handle 1]
                    set index [lindex [split $hport ":"] 1]
                    set port "port$index"
                    set devices [::sth::sthCore::invoke stc::get $port -affiliationport-Sources] 
                        
                    
                }
                foreach device $devices {
                    set reslut [::sth::sthCore::invoke stc::get $device -children]
                    if {[regexp -nocase  {igmphostconfig} $reslut]} {
                        lappend ipv4grouplist [::sth::sthCore::invoke stc::get $device.igmphostconfig.igmpgroupmembership -subscribedgroups-Targets]
                    } elseif {[regexp -nocase  {MldHostConfig} $reslut]} {
                        lappend ipv4grouplist [::sth::sthCore::invoke stc::get $device.MldHostConfig.MldGroupMembership -subscribedgroups-Targets]
                    } else {
                        lappend ipv4grouplist $device
                    }
                    
                }
                
            }
            if {[regexp -nocase  {port}  $eachDst]} {
                foreach hport [::sth::sthCore::invoke stc::get project1 -children-port] {
                    if {$hport eq $eachDst} {
                        foreach device [::sth::sthCore::invoke $port -affiliationport-Sources] {
                            set reslut [::sth::sthCore::invoke stc::get $device -children]
                            if {[regexp -nocase  {igmphostconfig} $reslut]} {
                                lappend ipv4grouplist [::sth::sthCore::invoke stc::get $device.igmphostconfig.igmpgroupmembership -subscribedgroups-Targets]
                            } elseif {[regexp -nocase  {MldHostConfig} $reslut]} {
                                lappend ipv4grouplist [::sth::sthCore::invoke stc::get $device.MldHostConfig.MldGroupMembership -subscribedgroups-Targets]
                            } else {
                                lappend ipv4grouplist $device
                            }
                        }
                        
                    }
                }
            
            }
       
        }
        if { $ipv4grouplist ne "" } {
            set argArray(-emulation_dst_handle) $ipv4grouplist
        }
    }

    if {[info exist argArray(-port_handle)] && [info exist argArray(-tx_mode)]} {
        if {[regexp -nocase "advanced" $argArray(-tx_mode)]} {
            set generatorhandle [::sth::sthCore::invoke stc::get $argArray(-port_handle) -children-generator]
            set generatorconfighandle [::sth::sthCore::invoke stc::get $generatorhandle -children-generatorconfig]
            ::sth::sthCore::invoke stc::config $generatorconfighandle -AdvancedInterleaving TRUE
        }
    }
	array unset argArray -tx_mode
	array unset argArray -traffic_generator	
    
	if {[info exist argArray(-ip_precedence_mode)]} {
		if {[string equal -nocase "fixed" $argArray(-ip_precedence_mode)] || [string equal -nocase "list" $argArray(-ip_precedence_mode)]} {
			unset argArray(-ip_precedence_mode)
		} elseif {[string equal -nocase "incr" $argArray(-ip_precedence_mode)]} {
			set argArray(-ip_precedence_mode) "increment"
		} elseif {[string equal -nocase "decr" $argArray(-ip_precedence_mode)]} {
			set argArray(-ip_precedence_mode) "decrement"
		}
	}

    # MGJ.
    # Ixia allows a -vlan_id_count 0, which disables vlans.
    if { [info exists argArray(-vlan_id_count)] && $argArray(-vlan_id_count) == 0 } {
        # Disable VLANs.
        array unset argArray -vlan
        array unset argArray -vlan_id
        array unset argArray -vlan_id_count
        array unset argArray -vlan_protocol_tag_id
    }
    if {![info exist argArray(-vlan_id)]} {
        array unset argArray -vlan_user_priority
    }
    if {[info exist argArray(-mode)] && [string equal -nocase "create" $argArray(-mode)]} {
        if {![info exist argArray(-mac_discovery_gw)]} {
            if {[info exist argArray(-ip_src_addr)] && [info exist argArray(-port_handle)]} {
                set device [::wrapper::get_device_with_ip_new $argArray(-ip_src_addr) $argArray(-port_handle)]
                if {$device != ""} {
                    ::sth::sthCore::invoke stc::perform ArpNdStartOnAllDevicesCommand -PortList $argArray(-port_handle)
                    set iph [::sth::sthCore::invoke stc::get $device -children-Ipv4If]
                    set ethhndl [::sth::sthCore::invoke stc::get $device -children-EthIIIf]
                    if {![info exist argArray(-mac_src)]} {
                        set argArray(-mac_src) [::sth::sthCore::invoke stc::get $ethhndl -SourceMac]
                    }
                    set argArray(-mac_discovery_gw) [::sth::sthCore::invoke stc::get $iph -Gateway]
                    if {![info exist argArray(-mac_dst)]} {
                        set argArray(-mac_dst) [::sth::sthCore::invoke stc::get $iph -GatewayMac]
                    }
                } else {
                    set tempList [split $argArray(-ip_src_addr) .]
                    set tempList [lreplace $tempList end end 1]
                    set argArray(-mac_discovery_gw) [join $tempList .]
                    #set argArray(-mac_discovery_gw) [::wrapper::ConvertIncrementIpAddress $argArray(-ip_src_addr) -1]
                }
            }
        }
    }
##convert field
    if {[info exist argArray(-data_pattern)]} {
		if {$argArray(-data_pattern) ne ""} {
			set argArray(-custom_pattern) $argArray(-data_pattern)
		}
        unset argArray(-data_pattern)
    }
    if {[info exist argArray(-integrity_signature)]} {
        set argArray(-fill_value) $argArray(-integrity_signature)
        unset argArray(-integrity_signature)
    }
    if {[info exist argArray(-mpls_exp_bit)]} {
        set argArray(-mpls_cos) $argArray(-mpls_exp_bit)
        unset argArray(-mpls_exp_bit)
    }
    if {[info exist argArray(-mpls_exp_bit_count)]} {
        set argArray(-mpls_cos_count) $argArray(-mpls_exp_bit_count)
        unset argArray(-mpls_exp_bit_count)
    }
    if {[info exist argArray(-mpls_exp_bit_mode)]} {
        set argArray(-mpls_cos_mode) $argArray(-mpls_exp_bit_mode)
        unset argArray(-mpls_exp_bit_mode)
    }
    if {[info exist argArray(-mpls_exp_bit_step)]} {
        set argArray(-mpls_cos_step) $argArray(-mpls_exp_bit_step)
        unset argArray(-mpls_exp_bit_step)
    }
    if {[info exist argArray(-mpls_label_mode)]} {
        set argArray(-mpls_labels_mode) $argArray(-mpls_label_mode)
        unset argArray(-mpls_label_mode)
    }
    if {[info exist argArray(-mpls_type)]} {
        if {[string equal -nocase "unicast" $argArray(-mpls_type)]} {
            set argArray(-ether_type) 8847
        } elseif {[string equal -nocase "multicast" $argArray(-mpls_type)]} {
            set argArray(-ether_type) 8848
        }
        unset argArray(-mpls_type)
    }
    if {[info exist argArray(-vlan_protocol_tag_id)]} {
        set argArray(-vlan_tpid) $argArray(-vlan_protocol_tag_id)
        unset argArray(-vlan_protocol_tag_id)
    }
##convert end

    if {[info exist argArray(-pgid_value)]} {
        set tempArray(-pgid_value) $argArray(-pgid_value)
    }
    ###add l3_protocol ipv4 if specify ip_precedence in traffic_config
    if {[info exist argArray(-ip_precedence)] && ![info exist argArray(-l3_protocol)]} {
        set argArray(-l3_protocol) "ipv4"
    }
    if {![info exist argArray(-ip_ttl)] && [info exist argArray(-l3_protocol)] && [string equal -nocase "ipv4" $argArray(-l3_protocol)]} {
        set argArray(-ip_ttl) 64
    }

    #mode: reset, and the -port_handle is provided, delete the streamblock here
    if {[string equal -nocase "reset" $argArray(-mode)] && [info exist argArray(-port_handle)]} {
        foreach eachPort $argArray(-port_handle) {
            set streamBlockList [::sth::sthCore::invoke stc::get $eachPort -children-streamblock]
            set generator [::sth::sthCore::invoke stc::get $eachPort -children-generator]
            set generatorcfg [::sth::sthCore::invoke stc::get $generator -children-generatorconfig]
            ::sth::sthCore::invoke stc::config $generatorcfg -duration 1 -SchedulingMode rate_based
            foreach i $streamBlockList {
                ::sth::sthCore::invoke stc::delete $i
            }
        }
        keylset result status 1
        return [::spirent::ret_port_converter $result]
    }

    #mode: remove, and the -stream_id is provided, delete the streamblock here
    if {[string equal -nocase "remove" $argArray(-mode)] && [info exist argArray(-stream_id)]} {
        foreach stream_id $argArray(-stream_id) {
            if {[catch {::sth::sthCore::invoke stc::delete $stream_id} Err]} {
                puts "\nWarning: $Err\n Already  stream id $stream_id has deleted. \n"
            }
        }
        keylset result status 1
        return $result
    }
    
    #mode: disable, and the -stream_id is provided, disable the streamblock here
    if {([string equal -nocase "disable" $argArray(-mode)] || [string equal -nocase "remove" $argArray(-mode)]) \
                    && [info exist argArray(-stream_id)]} {
        foreach eachStream $argArray(-stream_id) {
            if {[string is integer $eachStream]} {
                set eachStream streamblock$eachStream
            }
            set active_state [::sth::sthCore::invoke stc::get $eachStream -active]
            if {[regexp -nocase "true" $active_state]} {
                ::sth::sthCore::invoke stc::config $eachStream -active false
                set port [::sth::sthCore::invoke stc::get $eachStream -parent]
                set genCfg [::sth::sthCore::invoke stc::get [::sth::sthCore::invoke stc::get $port -children-Generator] -children-GeneratorConfig]
                set scheduleMode [::sth::sthCore::invoke stc::get $genCfg -SchedulingMode]
                if {[regexp -nocase "PRIORITY_BASED" $scheduleMode]} {
                    set duration [::sth::sthCore::invoke stc::get $genCfg -Duration]
                    if {[lsearch [keylkeys ::spirent::pkts_per_burst_list] $eachStream] > -1} {
                        set pkts_per_burst [keylget ::spirent::pkts_per_burst_list $eachStream]
                        set duration_changed [expr $duration - $pkts_per_burst]
                        if {$duration_changed <= 0} {
                            set duration_changed 1
                        }
                        ::sth::sthCore::invoke stc::config $genCfg -Duration $duration_changed
                    }
                }
            }
        }
        keylset result status 1
        return [::spirent::ret_port_converter $result]
    }
    if {[string equal -nocase "enable" $argArray(-mode)] && [info exist argArray(-stream_id)]} {
        foreach eachStream $argArray(-stream_id) {
            if {[string is integer $eachStream]} {
                set eachStream streamblock$eachStream
            }
            catch {
            set active_state [::sth::sthCore::invoke stc::get $eachStream -active]
                if {[regexp -nocase "false" $active_state]} {
                    ::sth::sthCore::invoke stc::config $eachStream -active true
                    set port [::sth::sthCore::invoke stc::get $eachStream -parent]
                    set genCfg [::sth::sthCore::invoke stc::get [::sth::sthCore::invoke stc::get $port -children-Generator] -children-GeneratorConfig]
                    set scheduleMode [::sth::sthCore::invoke stc::get $genCfg -SchedulingMode]
                    if {[regexp -nocase "PRIORITY_BASED" $scheduleMode]} {
                        set duration [::sth::sthCore::invoke stc::get $genCfg -Duration]
                        if {$duration == 1} {
                            set duration 0
                        }
                        if {[lsearch [keylkeys ::spirent::pkts_per_burst_list] $eachStream] > -1} {
                            set pkts_per_burst [keylget ::spirent::pkts_per_burst_list $eachStream]
                            set duration_changed [expr $duration + $pkts_per_burst]
                            ::sth::sthCore::invoke stc::config $genCfg -Duration $duration_changed
                        }
                    }
                }
            }
        }
        keylset result status 1
        return [::spirent::ret_port_converter $result]
    }
    # process the -signature, since STC dosen't support the signature_offset, map -signature to the -fill_value and change the value
    # from hex to dec.
    if {[info exist argArray(-fill_value)]} {
        set tempList $argArray(-fill_value)
        if {[llength $tempList] > 1} {
            set argArray(-fill_value) [expr 0x[join [concat [lindex $tempList 0] [lindex $tempList 1]] {}] + 0]
        } elseif {1 == [llength $tempList]} {
            set argArray(-fill_value) [expr 0x$tempList + 0]
        }
    }

    #process the "-port_handle2", if there is no -bidirectional or bidirectional = 0, ignore -port_handle2
    if {[info exist argArray(-port_handle2)]} {
        if {[info exist argArray(-bidirectional)] && [string equal "1" $argArray(-bidirectional)]} {
            if {![info exist argArray(-mac_dst)] && [info exist argArray(-mac_src2)]} {
                set argArray(-mac_dst) $argArray(-mac_src2)
            }
            if {![info exist argArray(-mac_dst2)] && [info exist argArray(-mac_src)]} {
                set argArray(-mac_dst2) $argArray(-mac_src)
            }
        } else {
            unset argArray(-port_handle2)
        }
    } else {
        array  unset argArray -bidirectional
    }
    if {[info exist argArray(-custom_pattern)]} {
        regsub -all { } $argArray(-custom_pattern) {} argArray(-custom_pattern)
    }

    #3. process manadory arguments
    #maybe the update is needed here ......
    #process l2_encap in some conditions: vlan existing => set l2_encap vlan
    if {[regexp -nocase "vlan" $args] && [regexp -nocase "mpls" $args]} {
        set argArray(-l2_encap) "ethernet_ii_vlan_mpls"
    } elseif {[regexp -nocase "vlan" $args] && ![regexp -nocase "mpls" $args]} {
        set argArray(-l2_encap) "ethernet_ii_vlan"
    } elseif {![regexp -nocase "vlan" $args] && [regexp -nocase "mpls" $args] && ![regexp -nocase "enable_dynamic_mpls_labels" $args]} {
        set argArray(-l2_encap) "ethernet_ii_unicast_mpls"
    }

    #process the list of vlan_id,vlan_cfi and vlan_protocol_tag_id, the list means stacked VLAN (QinQ), maps to outer vlan headr in hltapi
    set vlanArray(-vlan_id) "-vlan_id_outer"
    set vlanArray(-vlan_cfi) "-vlan_outer_cfi"
    set vlanArray(-vlan_tpid) "-vlan_outer_tpid"
    set vlanArray(-vlan_user_priority) "-vlan_outer_user_priority"
    set vlanArray(-vlan_id_mode) "-vlan_id_outer_mode"
    set vlanArray(-vlan_id_count) "-vlan_id_outer_count"
    set vlanArray(-vlan_id_step) "-vlan_id_outer_step"
    foreach eachName [array names vlanArray] {
        if {[info exist argArray($eachName)] && (2 == [llength $argArray($eachName)])} {
            set argArray($vlanArray($eachName)) [lindex $argArray($eachName) 0]
            set argArray($eachName) [lindex $argArray($eachName) 1]
        }
    }
    if {[info exist argArray(-vlan_tpid)]} {
        regsub -nocase "0x" $argArray(-vlan_tpid) {} argArray(-vlan_tpid)
        set argArray(-vlan_tpid) [expr 0x$argArray(-vlan_tpid) + 0]
    }
    if {[info exist argArray(-vlan_outer_tpid)]} {
        regsub -nocase "0x" $argArray(-vlan_outer_tpid) {} argArray(-vlan_outer_tpid)
        set argArray(-vlan_outer_tpid) [expr 0x$argArray(-vlan_outer_tpid) + 0]
    }



    #process the "transmit_mode", if pkts_per_burst is more than 1, then change the "continuous" to "continuous_burst"
    #if the transmit_mode is continuous and the duration is set, then set transmit_mode to seconds, or else remove duration
    #if the transmit_mode is single_burst, need to check if there are more than one streamblock under this port, if so, set burst_loop_count = streamblock count
    if {[info exist argArray(-transmit_mode)]} {
        #hltapi has one limitation, if -transmit_mode is configured, then port_handle is mandatory
        if {![info exist argArray(-port_handle)]} {
            if {[string is integer $argArray(-stream_id)]} {
                set streamValue "streamblock$argArray(-stream_id)"
            } else {
                set streamValue $argArray(-stream_id)
            }
            set argArray(-port_handle) [::sth::sthCore::invoke stc::get $streamValue -parent]
        }
        if {[string equal -nocase "continuous" $argArray(-transmit_mode)]} {
            if {[info exist argArray(-pkts_per_burst)] && (1 != $argArray(-pkts_per_burst))} {
                set argArray(-transmit_mode) "single_burst"
            }
            ##-duration has been cut, so this is useless branch
            if {![info exist argArray(-pkts_per_burst)] && [info exist tempArray(-duration)]} {
                set argArray(-transmit_mode) "seconds"
            }
        }
        if {[info exist argArray(-number_of_packets_per_stream)] && (1 != $argArray(-number_of_packets_per_stream))} {
            set argArray(-pkts_per_burst) $argArray(-number_of_packets_per_stream)
            unset argArray(-number_of_packets_per_stream)
            set argArray(-transmit_mode) "single_burst"
        }
    }
    array unset argArray -number_of_packets_per_stream

    #process the condition that more than one streamblocks are under one port
    if {[info exist argArray(-port_handle)] \
                && !([info exist argArray(-transmit_mode)] && [string compare -nocase "single_burst" $argArray(-transmit_mode)]) \
                && [info exist argArray(-pkts_per_burst)] && [info exist argArray(-rate_pps)]} {
        set ::spirent::pkts_per_burst $argArray(-pkts_per_burst)
        set portHandles $argArray(-port_handle)
        if {[info exist argArray(-bidirectional)] && [string equal "1" $argArray(-bidirectional)] && [info exist argArray(-port_handle2)]} {
            lappend portHandles $argArray(-port_handle2)
        }
        foreach eachPort $portHandles {
            set generator [::sth::sthCore::invoke stc::get $eachPort -children-generator]
            set strmblklst [::sth::sthCore::invoke stc::get $eachPort -children-streamblock]
            set generatorCfg [::sth::sthCore::invoke stc::get $generator -children-GeneratorConfig]
            set schedulingMode [::sth::sthCore::invoke stc::get $generatorCfg -SchedulingMode]
            if {[regexp -nocase "PRIORITY_BASED" $schedulingMode]} {
                set exist_ppb [::sth::sthCore::invoke stc::get $generatorCfg -Duration]
            } else {
                if {$strmblklst != ""} {
                    set exist_ppb [::sth::sthCore::invoke stc::get $generatorCfg -Duration]
                } else {
                    #entering this branch means it is the first streamblock under this port for single_burst mode
                    set exist_ppb 0
                }
                
            }

            #if it is modify mode, the duration needs to be updated before plusing one new value
            if {[string equal -nocase "modify" $argArray(-mode)]} {
                if {[string is integer $argArray(-stream_id)]} {
                    set streamValue streamblock$argArray(-stream_id)
                } else {
                    set streamValue $argArray(-stream_id)
                }
                set targets [::sth::sthCore::invoke stc::get $streamValue -AffiliationStreamBlockLoadProfile-targets]
                set streamLoad [::sth::sthCore::invoke stc::get $targets -load]
                set seconds [expr $argArray(-pkts_per_burst)/$argArray(-rate_pps)]
                set strblk_ppb [expr $streamLoad * $seconds]
                set exist_ppb [expr $exist_ppb - $strblk_ppb]
            }
            #incase the exist_ppb + ppb will exceed the range of Tcl inter, add .0 to calculate it.
            set update_ppb [expr $exist_ppb.0 + $argArray(-pkts_per_burst).0]
            
            ##add by west. Here need check whether the module is DX-module, which doesn't support PRIORITY_BASED
            if {[catch {set module_model [stc::get [stc::get [stc::get [stc::get $eachPort -physicallogical-Sources] -parent] -parent] -model]} Err]} {
                set arglist "-Duration $update_ppb -SchedulingMode PRIORITY_BASED -DurationMode bursts -burstsize $argArray(-pkts_per_burst)"
                puts "Warning: can't get the model info for current test module.$Err"
            } else {
                if {[regexp -nocase "DX|FX" $module_model]} {
                    set arglist "-Duration $update_ppb -SchedulingMode RATE_BASED -DurationMode bursts -burstsize 1"
                } else {
                    set arglist "-Duration $update_ppb -SchedulingMode PRIORITY_BASED -DurationMode bursts -burstsize $argArray(-pkts_per_burst)"
                }
            }
            ::sth::sthCore::invoke stc::config $generatorCfg $arglist
        }
        array unset argArray -transmit_mode
        array unset argArray -pkts_per_burst
    }

    foreach i "-mac_src -mac_dst -mac_src2 -mac_dst2" {
        if {[info exist argArray($i)]} {
            set argArray($i) [::wrapper::macAddressToStcFormat $argArray($i)]
        }
    }
    #process the "mac_src_step" and "mac_dst_step", hltapi only supports the integer value
    foreach eachMacStep "-mac_src_step -mac_dst_step" {
        if {[info exist argArray($eachMacStep)] && [regexp {[.|\-|:]} $argArray($eachMacStep)]} {
            regsub -all -- {[.|\-|:]} $argArray($eachMacStep) {} tempValue
            set tempValue [format %f [expr 0x$tempValue + 0]]
            regsub {\..*} $tempValue {} argArray($eachMacStep)
        }
        catch {unset tempValue}
    }
    if {![info exist argArray(-mac_dst_step)]} {
        if {[info exist argArray(-mac_dst_mode)] && ![string equal -nocase "discovery" $argArray(-mac_dst_mode)]} {
            set argArray(-mac_dst_step) 1
        }
        if {![info exist argArray(-mac_dst_mode)] && [info exist argArray(-mac_dst_count)]} {
            set argArray(-mac_dst_step) 1
        }
    }
    if {![info exist argArray(-mac_src_step)] && ([info exist argArray(-mac_src_mode)] || [info exist argArray(-mac_src_count)])} {
        set argArray(-mac_src_step) 1
    }
    #process the "ipv6_dst_mode and ipv6_src_mode", if the value is incr_intf_id, then maps to increment
    if {[info exist argArray(-ipv6_src_mode)]} {
        if {[string equal -nocase "incr_intf_id" $argArray(-ipv6_src_mode)]} {
            set argArray(-ipv6_src_mode) "increment"
        }
        if {[string equal -nocase "incr_mcast_group" $argArray(-ipv6_src_mode)]} {
            # "incr_mcast_group" indicates that the incrementation should start at the least-significant bytes.
            # This is Spirent TestCenter's default, so we can just ignore this setting.
            set argArray(-ipv6_src_mode) "increment"
        }
        if {[string equal -nocase "incr_global_site_level" $argArray(-ipv6_src_mode)]} {
            # "incr_global_site_level" means incrementing the following bytes: 0:0:0:xxxx::0.
            set argArray(-ipv6_src_mode) "increment"
            if { [info exists argArray(-ipv6_src_step)] } {
                set step $argArray(-ipv6_src_step)
            } else {
                set step 1
            }
            set step [format %x $step]
            set argArray(-ipv6_src_step) 0:0:0:${step}::0
        }
    }
    if {[info exist argArray(-ipv6_dst_mode)]} {
        if {[string equal -nocase "incr_intf_id" $argArray(-ipv6_dst_mode)]} {
            set argArray(-ipv6_dst_mode) "increment"
        }
        if {[string equal -nocase "incr_mcast_group" $argArray(-ipv6_dst_mode)]} {
            # "incr_mcast_group" indicates that the incrementation should start at the least-significant bytes.
            # This is Spirent TestCenter's default, so we can just ignore this setting.
            set argArray(-ipv6_dst_mode) "increment"
        }
        if {[string equal -nocase "incr_global_site_level" $argArray(-ipv6_dst_mode)]} {
            # "incr_global_site_level" means incrementing the following bytes: 0:0:0:xxxx::0.
            set argArray(-ipv6_dst_mode) "increment"
            if { [info exists argArray(-ipv6_dst_step)] } {
                set step $argArray(-ipv6_dst_step)
            } else {
                set step 1
            }
            set step [format %x $step]
            set argArray(-ipv6_dst_step) 0:0:0:${step}::0
        }

    }
    #process the "-vlan", it is used in modify mode
    #if "-vlan" is disabled, set l2_encap: ethernet_ii, then hltapi will remove the vlan header
    if {[info exist tempArray(-vlan)] && [string equal -nocase "disable" $tempArray(-vlan)]} {
        set argArray(-l2_encap) "ethernet_ii"
        array unset argArray -vlan_user_priority
    }
    #process the "udf1_mode counter", need to draft more here in the future for more test cases
    if {[info exist tempArray(-udf1_mode)] && [info exist tempArray(-udf1_counter_up_down)]} {
        set tempArgs [array get argArray]
        set tempArgs [wrapper::process_udf_tmp $args $tempArgs]
        ::spirent::listToArray $tempArgs argArray
    }
    #process the l3_protocol "ipx", when it is ipx, need to remove the l3_protocol and set the ipx_header
    #since now in the cisco hero bu qos script ipx is not really used, it is used because there is a bug
    #when modify the l3_protocol from the arp to the ipv4, so it use arp->ipx->ipv4 as an workaround to change
    #the l3_protocol from the arp to the ipv4. so here when the l3_ptotocol is  ipx and mode is modify, we just return
    #later, if the ipx is realy used, we need to enhance here
    if {[info exist argArray(-l3_protocol)] && [string equal -nocase "ipx" $argArray(-l3_protocol)] && [string equal -nocase "modify" $argArray(-mode)]} {
        keylset result status 1
        return [::spirent::ret_port_converter $result]
    }

    ###change Rate_bps per frame_length
    ###get frame_length
    set tempArgs [array get argArray]
    if {[info exist argArray(-frame_size)]} {
        set frameSize $argArray(-frame_size)
    } elseif {[info exist argArray(-l3_length)]} {
        #check if the vlan exists
        if {[regexp -nocase "vlan_outer_" $tempArgs]} {
            set frameSize [expr $argArray(-l3_length) + 18 + 8]
        } elseif {[regexp -nocase "vlan_" $tempArgs]} {
            set frameSize [expr $argArray(-l3_length) + 18 + 4]
        } else {
            set frameSize [expr $argArray(-l3_length) + 18]
        }
        if {[info exist argArray(-mpls_labels)]} {
            incr frameSize [expr 4 * [llength $argArray(-mpls_labels)]]
        }
    } else {
        if {[regexp -nocase "vlan_outer_" $tempArgs]} {
            set frameSize [expr 128 + 8]
        } elseif {[regexp -nocase "vlan_" $tempArgs]} {
            set frameSize [expr 128 + 4]
        } else {
            set frameSize 128
        }
    }
    if {[info exist argArray(-rate_bps)]} {
        set argArray(-rate_bps) [regsub {\..*} [expr $argArray(-rate_bps)/$frameSize*(20.0+$frameSize)] {}]
    }
    #process the inter_stream_gap, the default value of hltapi
    if {([info exist argArray(-pkts_per_burst)] && (1 != $argArray(-pkts_per_burst)) && ![info exist argArray(-inter_stream_gap)]) \
                || [info exist update_ppb]} {
        #the gap value may need to update when necessary
        if {[info exist argArray(-rate_pps)] || [info exist argArray(-rate_bps)] || ([info exist argArray(-mode)] && ("modify" == $argArray(-mode)))} {
            set tempArgs [array get argArray]
            set tempArgs [concat $tempArgs [::wrapper::calculate_gap $tempArgs]]
            ::spirent::listToArray $tempArgs argArray
        }
    }
    
    if {(([info exist argArray(-mode)] && ("modify" == $argArray(-mode))) && ([info exist argArray(-l4_protocol)] && \
    		("icmp" == $argArray(-l4_protocol))))} {
        array unset argArray -l4_protocol
    }

#call the common part of ixia and agttest
    set tempArgs [array get argArray]
    set result [wrapper::traffic_config_common $tempArgs]
    if {!([info exist argArray(-bidirectional)] && [string equal "1" $argArray(-bidirectional)])} {
        ##handle traffic_pattern
        if {!([info exist argArray(-type)] && ($argArray(-type) == "profile"))} {
            if {$argArray(-mode) == "create"} {
                set stream_ids [keylget result stream_id]
            } elseif {$argArray(-mode) == "modify"} {
            set stream_ids $argArray(-stream_id)
            }
            foreach id $stream_ids {
                if {![regexp -nocase "streamblock" $id]} {
                    set id streamblock$id
                }
                if {$traffic_pattern != ""} {
                    ::sth::sthCore::invoke stc::config $id -TrafficPattern $traffic_pattern
                }
            }

            ##assume preamble is no more than 8.
            if {$preamble_custom_size != ""} {
                if {$argArray(-mode) == "create"} {
                    set stream_ids [keylget result stream_id]
                } elseif {$argArray(-mode) == "modify"} {
                    set stream_ids $argArray(-stream_id)
                }
                foreach id $stream_ids {
                    if {![regexp -nocase "streamblock" $id]} {
                        set id streamblock$id
                    }
                    set ethheader [::sth::sthCore::invoke stc::get $id -children-ethernet:EthernetII]
                    if { $ethheader != "" } {
                        if {($preamble_custom_size <= 8)} {
                            ::sth::sthCore::invoke stc::config $ethheader -preamble [string range "fb555555555555d5" 0 [expr $preamble_custom_size * 2 - 1]]
                        } else {
                            set preamble "555555555555d5"
                            for {set i 8} {$i < $preamble_custom_size} {incr i} {
                                set preamble "55$preamble"
                            }
                            set preamble "fb$preamble"
                            ::sth::sthCore::invoke stc::config $ethheader -preamble $preamble
                        }
                    }
                }
            }
        }

        #####store ipv4 header args into ::spirent::stream_ipv4_config
        if {[info exist argArray(-l3_protocol)] && [string equal -nocase "ipv4" $argArray(-l3_protocol)] \
                && [info exist argArray(-mode)] && [string equal -nocase "create" $argArray(-mode)]} {
            set stream_ids [keylget result stream_id]
            set argList ""
            foreach eachArg $::spirent::StreamArgList {
                if {[info exist argArray(-$eachArg)]} {
                    lappend argList -$eachArg $argArray(-$eachArg)
                }
            }
            foreach eachStream $stream_ids {
                set ::spirent::stream_ipv4_config($eachStream) $argList
            }
        }

        if {[info exists tempArray(-pgid_value)]} {
            set streamList [keylget result stream_id]
            if {[llength $streamList] == 1} {
                set ::spirent::stream_pgid($streamList) $tempArray(-pgid_value)
            } else {
                set portlist ""
                foreach id $streamList {
                    set port [::sth::sthCore::invoke stc::get streamblock$id -ExpectedRxPort]
                    lappend portlist $port
                }
                foreach port $portList {
                    set ::spirent::stream_pgid([keylget streamList $port]) $tempArray(-pgid_value)
                }
            }
        }
    
        ###set activeFlag
        if {[regexp -nocase "stream_id" $result]} {
            if {([info exist argArray(-mode)] && ($argArray(-mode) == "create"))} {
                set streamList [keylget result stream_id]
                keylset result traffic_item $streamList
                foreach id $streamList {
                    if {![regexp -nocase "streamblock" $id]} {
                        set id streamblock$id
                    }
                    ::sth::sthCore::invoke stc::config $id -active $activeFlag
                }
            }
        }
    }

    return [::spirent::ret_port_converter $result]
}

#AgtTest function is called in span_main.tcl, vpls_main.tcl, mpls_ldp_oam, urpf_enhancements.tcl,
#AgtTest and ixia are different in libInit in l3vpn_load_balance, l3vpn_routing, the namespace is ixia::traffic_config, no need to convert the args in AgtTest::traffic_config
proc ::AgtTest::traffic_config { args } {

    set ::spirent::pkts_per_burst 0
    array set argArray {}

    set args [wrapper::shield_args -total $args -unsupported "stream_gen_in_mesh"]
    regsub mld-report $args mld_report args
    set args [eval ::spirent::port_converter $args]
    ::spirent::listToArray $args argArray
    
    ##here the default traffic speed is the 100% port bandwidth
    if {![info exist argArray(-rate_bps)] && ![info exist argArray(-rate_percent)] && ![info exist argArray(-rate_pps)] && [info exists argArray(-mode)] && $argArray(-mode) == "create"} {
        if {! ([info exists argArray(-type)] && [string equal -nocase "profile" $argArray(-type)])} {
            if {[info exist argArray(-port_handle)]} {
            set porthndl $argArray(-port_handle)
                set genconfig [::sth::sthCore::invoke stc::get [::sth::sthCore::invoke stc::get $porthndl -children-Generator] -children-GeneratorConfig]
                ::sth::sthCore::invoke stc::config $genconfig -SchedulingMode PORT_BASED -LoadUnit PERCENT_LINE_RATE -FixedLoad 100
            }
        }
    }

##shield field
    array unset argArray -enable_udf1
    array unset argArray -enable_udf4
    array unset argArray -stream_gen_field
    array unset argArray -mesh_src_addr_endpoint_type
##for GRE
    array unset argArray -udf1_counter_init_value
    array unset argArray -udf1_counter_mode
    array unset argArray -udf1_counter_repeat_count
    array unset argArray -udf1_counter_step
    array unset argArray -udf1_counter_type
    array unset argArray -udf1_counter_up_down
    array unset argArray -udf1_mode
    array unset argArray -udf1_offset
    array unset argArray -udf4_counter_init_value
    array unset argArray -udf4_counter_repeat_count
    array unset argArray -udf4_counter_step
    array unset argArray -udf4_counter_type
    array unset argArray -udf4_inner_repeat_count
    array unset argArray -udf4_inner_repeat_value
    array unset argArray -udf4_inner_step
    array unset argArray -udf4_mode
    array unset argArray -udf4_offset
##convert field

    ## Changing the load into Port based if line percent is given
    if {[info exist argArray(-rate_percent)] && [info exist argArray(-port_handle)]} {
        foreach porth $argArray(-port_handle) {
        set genh [::sth::sthCore::invoke stc::get $porth -children-generator]
        set genconfig [::sth::sthCore::invoke stc::get $genh -children-generatorconfig]
        ::sth::sthCore::invoke stc::config $genconfig -SchedulingMode port_based -FixedLoad $argArray(-rate_percent)
        unset argArray(-rate_percent)
        }
    }
    if {![info exist argArray(-bidirectional)]} {
        array unset argArray -port_handle2
    }
    if {[info exist argArray(-vlan_id)]} {
        if {[info exist argArray(-l2_encap)] && [string match -nocase $argArray(-l2_encap) "ethernet_ii"]} {
            set argArray(-l2_encap) "ethernet_ii_vlan"
        }
    }
    if {[info exist argArray(-mpls_label_count)]} {
        set argArray(-mpls_labels_count) $argArray(-mpls_label_count)
        unset argArray(-mpls_label_count)
    }

    if {[info exist argArray(-ipv6_dst_mask)]} {
        set argArray(-ipv6_dstprefix_len) $argArray(-ipv6_dst_mask)
        unset argArray(-ipv6_dst_mask)
    }

    if {[info exist argArray(-ipv6_src_mask)]} {
        set argArray(-ipv6_srcprefix_len) $argArray(-ipv6_src_mask)
        unset argArray(-ipv6_src_mask)
    }
    
    if {[info exist argArray(-mpls_label_step)]} {
        set argArray(-mpls_labels_step) $argArray(-mpls_label_step)
        unset argArray(-mpls_label_step)
    }
    
    if {[info exist argArray(-mpls_label_mode)]} {
        set argArray(-mpls_labels_mode) $argArray(-mpls_label_mode)
        unset argArray(-mpls_label_mode)
    }
    
    if {[info exist argArray(-l2_length)]} {
        set argArray(-frame_size) $argArray(-l2_length)
        unset argArray(-l2_length)
    }
    if {[info exist argArray(-l2_length_max)]} {
        set argArray(-frame_size_max) $argArray(-l2_length_max)
        unset argArray(-l2_length_max)
    }
    if {[info exist argArray(-l2_length_min)]} {
        set argArray(-frame_size_min) $argArray(-l2_length_min)
        unset argArray(-l2_length_min)
    }
    if {[info exist argArray(-l2_length_step)]} {
        set argArray(-frame_size_step) $argArray(-l2_length_step)
        unset argArray(-l2_length_step)
    }
    if {[info exist argArray(-single_shot_traffic)]} {
        set argArray(-pkts_per_burst) $argArray(-single_shot_traffic)
        unset argArray(-single_shot_traffic)
    }

	if {[info exists argArray(-ip_src_mode)] && $argArray(-ip_src_mode) == "emulation"} {
        set argArray(-ip_src_mode) fixed
    }

	if {[info exists argArray(-l4_protocol)] && $argArray(-l4_protocol) == "icmp"} {
        set argArray(-icmp_type) 0
    }
	
	
	if {[info exists argArray(-l4_protocol)] && $argArray(-l4_protocol) == "icmp_v6"} {
        set argArray(-icmpv6_type) 143
    }
    
    if {![info exist argArray(-ip_ttl)] && [info exist argArray(-l3_protocol)] && [string equal -nocase "ipv4" $argArray(-l3_protocol)]} {
        set argArray(-ip_ttl) 64
    }
    ##Multicast HLTAPI 1.00
#    if {![info exists argArray(-enable_stream_only_gen)]} {
#        # HLTAPI sets this to true, but it is not desirable.
#        set argArray(-enable_stream_only_gen) 0
#    }
##convert end

    # Converting the stream handle
    if {[info exist argArray(-stream_id)]} {
        if {![regexp -nocase "streamblock" $argArray(-stream_id)]} {
            set stream_id ""
            if {[regexp "(\\d+)\-(\\d+)" $argArray(-stream_id) temp start end]} {
                for {set i $start} {$i <= $end} {incr i} {
                    lappend stream_id streamblock$i
                }
            } else {
                foreach stream $argArray(-stream_id) {
                    if {[string is integer $stream]} {
                        lappend stream_id streamblock$stream
                    }
                }
            }
            set argArray(-stream_id) $stream_id
        }
    }

    if {[string equal -nocase "reset" $argArray(-mode)] && [info exist argArray(-port_handle)]} {
        foreach eachPort $argArray(-port_handle) {
            set strBlkList [::sth::sthCore::invoke stc::get $eachPort -children-streamblock]
            set generator [::sth::sthCore::invoke stc::get $eachPort -children-generator]
            set generatorCfg [::sth::sthCore::invoke stc::get $generator -children-generatorconfig]
            ::sth::sthCore::invoke stc::config $generatorCfg -duration 1 -SchedulingMode rate_based
            foreach strblk $strBlkList {
                ::sth::sthCore::invoke stc::delete $strblk
            }
        }
        keylset result status 1
        return $result
    }
    
    #mode: remove, and the -stream_id is provided, delete the streamblock here
    if {[string equal -nocase "remove" $argArray(-mode)] && [info exist argArray(-stream_id)]} {
        foreach stream_id $argArray(-stream_id) {
            if {[catch {::sth::sthCore::invoke stc::delete $stream_id} Err]} {
                puts "\nWarning: $Err\n Already  stream id $stream_id has deleted. \n"
            }
        }
        keylset result status 1
        return $result
    }

    #mode: disable, and the -stream_id is provided, disable the streamblock here
    if {[string equal -nocase "disable" $argArray(-mode)] && [info exist argArray(-stream_id)]} {
        foreach stream_id $argArray(-stream_id) {
            set active_state [::sth::sthCore::invoke stc::get $stream_id -active]
            if {[regexp -nocase "true" $active_state]} {
                ::sth::sthCore::invoke stc::config $stream_id -active false
                set port [::sth::sthCore::invoke stc::get $stream_id -parent]
                set genCfg [::sth::sthCore::invoke stc::get [::sth::sthCore::invoke stc::get $port -children-Generator] -children-GeneratorConfig]
                set scheduleMode [::sth::sthCore::invoke stc::get $genCfg -SchedulingMode]
                if {[regexp -nocase "PRIORITY_BASED" $scheduleMode]} {
                    set duration [::sth::sthCore::invoke stc::get $genCfg -Duration]
                    if {[lsearch [keylkeys ::spirent::pkts_per_burst_list] $stream_id] > -1} {
                        set pkts_per_burst [keylget ::spirent::pkts_per_burst_list $stream_id]
                        set duration_changed [expr $duration - $pkts_per_burst]
                        if {$duration_changed <= 0} {
                            set duration_changed 1
                        }
                        ::sth::sthCore::invoke stc::config $genCfg -Duration $duration_changed
                    }
                }
            }
        }
        keylset result status 1
        keylset result stream_id $argArray(-stream_id)
        return $result
    }
    if {[string equal -nocase "enable" $argArray(-mode)] && [info exist argArray(-stream_id)]} {
        foreach stream_id $argArray(-stream_id) {
            if {[string is integer $stream_id]} {
                set stream_id streamblock$stream_id
            }
            set active_state [::sth::sthCore::invoke stc::get $stream_id -active]
            if {[regexp -nocase "false" $active_state]} {
                ::sth::sthCore::invoke stc::config $stream_id -active true
                set port [::sth::sthCore::invoke stc::get $stream_id -parent]
                set genCfg [::sth::sthCore::invoke stc::get [::sth::sthCore::invoke stc::get $port -children-Generator] -children-GeneratorConfig]
                set scheduleMode [::sth::sthCore::invoke stc::get $genCfg -SchedulingMode]
                if {[regexp -nocase "PRIORITY_BASED" $scheduleMode]} {
                    set duration [::sth::sthCore::invoke stc::get $genCfg -Duration]
                    if {$duration == 1} {
                        set duration 0
                    }
                    if {[lsearch [keylkeys ::spirent::pkts_per_burst_list] $stream_id] > -1} {
                        set pkts_per_burst [keylget ::spirent::pkts_per_burst_list $stream_id]
                        set duration_changed [expr $duration + $pkts_per_burst]
                        ::sth::sthCore::invoke stc::config $genCfg -Duration $duration_changed
                    }
                }
            }
        }
        keylset result status 1
        keylset result stream_id $argArray(-stream_id)
        return [::spirent::ret_port_converter $result]
    }

    if {![info exist argArray(-l2_encap)] && [regexp -nocase vlan $args]} {
        set argArray(-l2_encap) "ethernet_ii_vlan"
    }

    if {[info exist argArray(-transmit_mode)] && [string equal -nocase "continuous_single_shot" $argArray(-transmit_mode)]} {
        set argArray(-transmit_mode) "multi_burst"
    }

    if {[info exist argArray(-port_handle)] \
                && !([info exist argArray(-transmit_mode)] && [string compare -nocase "single_burst" $argArray(-transmit_mode)]) \
                && [info exist argArray(-pkts_per_burst)] && [info exist argArray(-rate_pps)]} {
        set ::spirent::pkts_per_burst $argArray(-pkts_per_burst)
        foreach eachPort $argArray(-port_handle) {
            set generator [::sth::sthCore::invoke stc::get $eachPort -children-generator]
            set strmblklst [::sth::sthCore::invoke stc::get $eachPort -children-streamblock]
            set generatorCfg [::sth::sthCore::invoke stc::get $generator -children-GeneratorConfig]
            set current_schedule_mode [::sth::sthCore::invoke stc::get $generatorCfg -SchedulingMode]
            if {[regexp -nocase "PRIORITY_BASED" $current_schedule_mode]} {
                set exist_ppb [::sth::sthCore::invoke stc::get $generatorCfg -Duration]
            } else {
                if {$strmblklst != ""} {
                    set exist_ppb [::sth::sthCore::invoke stc::get $generatorCfg -Duration]
                } else {
                    #entering this branch means it is the first streamblock under this port for single_burst mode
                    set exist_ppb 0
                }
                
            }
            #if it is modify mode, the duration needs to be updated before plusing one new value
            if {[string equal -nocase "modify" $argArray(-mode)]} {
                if {[string is integer $argArray(-stream_id)]} {
                    set stream_id streamblock$argArray(-stream_id)
                } else {
                    set stream_id $argArray(-stream_id)
                }
                set strblkloadprofile [::sth::sthCore::invoke stc::get $stream_id -AffiliationStreamBlockLoadProfile-targets]
                set last_rate [::sth::sthCore::invoke stc::get $strblkloadprofile -load]
                set curr_rate $argArray(-rate_pps)
                set seconds [expr $argArray(-pkts_per_burst)/$curr_rate]
                set strblk_ppb [expr $last_rate * $seconds]
                set exist_ppb [expr $exist_ppb - $strblk_ppb]
            }
            set update_ppb [expr $exist_ppb + $argArray(-pkts_per_burst)]
            ##add by west. Here need check whether the module is DX-module, which doesn't support PRIORITY_BASED
            if {[catch {set module_model [stc::get [stc::get [stc::get [stc::get $eachPort -physicallogical-Sources] -parent] -parent] -model]} Err]} {
                set arglist "-Duration $update_ppb -SchedulingMode PRIORITY_BASED -DurationMode bursts -burstsize $argArray(-pkts_per_burst)"
                puts "Warning: can't get the model info for current test module. $Err"
            } else {
                if {[regexp -nocase "DX|FX" $module_model]} {
                    set arglist "-Duration $update_ppb -SchedulingMode RATE_BASED -DurationMode bursts -burstsize 1"
                } else {
                    set arglist "-Duration $update_ppb -SchedulingMode PRIORITY_BASED -DurationMode bursts -burstsize $argArray(-pkts_per_burst)"
                }
            }
            ::sth::sthCore::invoke stc::config $generatorCfg $arglist
        }
        array unset argArray -transmit_mode
        array unset argArray -pkts_per_burst
    }
	
	
	if {([info exist argArray(-length_mode)] && [string match -nocase $argArray(-length_mode) quad])} {
	   array unset argArray -l3_gaus1_halfbw
	   array unset argArray -l3_gaus2_halfbw
	   array unset argArray -l3_gaus3_halfbw
	   array unset argArray -l3_gaus4_halfbw
	   
	   
        set argArray(-length_mode) imix
        if {[info exist argArray(-l3_gaus1_avg)]} {
            set argArray(-l3_imix1_size) $argArray(-l3_gaus1_avg)
            unset argArray(-l3_gaus1_avg)
        }
		if {[info exist argArray(-l3_gaus2_avg)]} {
            set argArray(-l3_imix2_size) $argArray(-l3_gaus2_avg)
            unset argArray(-l3_gaus2_avg)
        }
		if {[info exist argArray(-l3_gaus3_avg)]} {
            set argArray(-l3_imix3_size) $argArray(-l3_gaus3_avg)
            unset argArray(-l3_gaus3_avg)
        }
		if {[info exist argArray(-l3_gaus4_avg)]} {
            set argArray(-l3_imix4_size) $argArray(-l3_gaus4_avg)
            unset argArray(-l3_gaus4_avg)
        }
		if {[info exist argArray(-l3_gaus1_weight)]} {
            set argArray(-l3_imix1_ratio) $argArray(-l3_gaus1_weight)
            unset argArray(-l3_gaus1_weight)
        }
		if {[info exist argArray(-l3_gaus2_weight)]} {
            set argArray(-l3_imix2_ratio) $argArray(-l3_gaus2_weight)
            unset argArray(-l3_gaus2_weight)
        }
		if {[info exist argArray(-l3_gaus3_weight)]} {
            set argArray(-l3_imix3_ratio) $argArray(-l3_gaus3_weight)
            unset argArray(-l3_gaus3_weight)
        }
		if {[info exist argArray(-l3_gaus4_weight)]} {
            set argArray(-l3_imix4_ratio) $argArray(-l3_gaus4_weight)
            unset argArray(-l3_gaus4_weight)
        }
	}
    #process the inter_stream_gap, the default value of hltapi
    if {([info exist argArray(-pkts_per_burst)] && (1 != $argArray(-pkts_per_burst)) && ![info exist argArray(-inter_stream_gap)]) \
                || [info exist update_ppb]} {
        #the gap value may need to update when necessary
        set tempArgs [array get argArray]
        set tempArgs [concat $tempArgs [::wrapper::calculate_gap $tempArgs]]
        ::spirent::listToArray $tempArgs argArray
    }
    
	#Handling rate_pps in Agilent
	set temp_portlst ""
    if {[info exist argArray(-rate_pps)] || [info exist argArray(-rate_bps)]} {
		if {[info exist argArray(-port_handle)]} {
			set temp_portlst [concat $temp_portlst $argArray(-port_handle)]
			if {[info exist argArray(-port_handle2)]} {
				set temp_portlst [concat $temp_portlst $argArray(-port_handle2)]
			}
			foreach porth $temp_portlst {
				set strmcount [llength [::sth::sthCore::invoke stc::get $porth -children-streamblock]]
				if {$strmcount >= 1} {
					set genh [::sth::sthCore::invoke stc::get $porth -children-generator]
					set genconfig [::sth::sthCore::invoke stc::get $genh -children-generatorconfig]
					if {[info exist argArray(-rate_pps)]} {
					   ::sth::sthCore::invoke stc::config $genconfig -SchedulingMode port_based -FixedLoad $argArray(-rate_pps) -LoadUnit FRAMES_PER_SECOND
					} else {
					   ::sth::sthCore::invoke stc::config $genconfig -SchedulingMode port_based -FixedLoad $argArray(-rate_bps) -LoadUnit "BITS_PER_SECOND"
					}   
				}
			}
		}
	}
	
#Added by Sukesh
 if {(![info exist argArray(-mac_dst)] && ![info exist argArray(-mac_dst_mode)])} {
     set argArray(-mac_dst_mode) discovery
  }
    #call the common part of ixia and agttest
    set tempArgs [array get argArray]
    set result [wrapper::traffic_config_common $tempArgs]
    # Handling transmit_mode single_burst/multi_burst
    if {([info exist argArray(-transmit_mode)]) && (($argArray(-transmit_mode) == "single_burst") || ($argArray(-transmit_mode) == "multi_burst"))} {
        if {[info exist argArray(-port_handle)]} {
	        foreach eachPorthandle $argArray(-port_handle) {
	            set streamblockcount [llength [::sth::sthCore::invoke stc::get $eachPorthandle -children-streamBlock]]
	            set genconfighndl [::sth::sthCore::invoke stc::get $eachPorthandle.generator -children-generatorconfig]
	            set numberofbursts [::sth::sthCore::invoke stc::get $genconfighndl -duration]
	            if {$streamblockcount > $numberofbursts} {
	                ::sth::sthCore::invoke stc::config $genconfighndl -duration $streamblockcount
	                ::sth::sthCore::invoke stc::apply
	            }
	        }
        }
    }
    if {[catch {keylget result profile_handle}]} {
    	if {[regexp -nocase stream_id [keylkeys result]]} {
        	keylset result profile_handle [keylget result stream_id]
	}
    }
    return [::spirent::ret_port_converter $result]
}

proc ::spirent::emulation_bgp_config { args } {

    #bfd_registration_mode          not supported by STC, removed
    #local_loopback_ip_addr         same with local_router_id, removed or changed to local_router_id
    #local_loopback_ip_addr_step    same with local_router_id_step, removed or changed to local_router_id
    #local_router_id_enable         not supported by STC, removed
    #remote_loopback_ip_addr        not supported by STC, should be same with remote_ip_addr, removed
    #remote_loopback_ip_addr_step   not supported by STC, should be same with remote_ip_addr_step, removed
    #tcp_window_size                not supported by STC, removed
    #updates_per_iteration          not supported by STC, removed
    #neighbor_type                  not supported by STC, but can be correctly mapped to local_as and remote_as, removed this
    #gateway_ip_addr                can be mapped to next_hop_ip or next_hop_ipv6, changed to next_hop_ipv6
    #advertise_host_route           by default enabled in STC, removed
    #timeout                        by default taken care in STC, removed
	
    global return_list
	
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set unsupportArgsList "advertise_host_route timeout"
    ::spirent::listToArray $args argArray
    
    if {[info exists argArray(-staggered_start_time)]&&![info exists argArray(-staggered_start_enable)]} {
    #need add staggered_start_enable if not have this parameter
        set argArray(-staggered_start_enable) 1
    }
    
    ##in case -vlan 0
    if { [info exists argArray(-vlan)] } {        
        set vlan $argArray(-vlan)
        set vlanArgList "vlan"
        if {$vlan == 0} {
            set vlanArgList "$vlanArgList vlan_id vlan_id_mode vlan_id_step vlan_user_priority"
        }
        set unsupportArgsList [concat $unsupportArgsList $vlanArgList]
    }
    
    ##start
    ## description: In Cisco scripts "-local_router_id" is set by the value of port_handle.
    ##             In Ixia hltapi, port_handle is formated as "a/b/c", Cisco set
    ##             local_router_id as "b.c.0.1". But in Spirent hltapi port_handle is
    ##             format as "port*", so Cisco cannot set up correct local_router_id.
    ##             These code below can help to send correct address to Spirent hltapi.
    if {[info exists argArray(-local_router_id)]} {
        set value_local_router_id $argArray(-local_router_id)
        if {$value_local_router_id eq "..0.1"} {
            if {[info exists argArray(-port_handle)]} {
                set value_port_handle $argArray(-port_handle)
            }
            if {[info exists ::sth::Session::PORTHNDLIST]} {
                if {[catch {set port_value $::sth::Session::PORTHNDLIST($value_port_handle)} msg_session_porthnd]} {
                    return -code error $msg_session_porthnd
                } else {
                    set second [lindex [split $port_value /] 1]
                    set third [lindex [split $port_value /] 2]
                    set value_local_router_id "$second.$third.0.1"
                    set argArray(-local_router_id) $value_local_router_id
                }
            } else {
                return -code error "::sth::Session::PORTHNDLIST does not exist"
            }
        }
    }
    ##end
    if {[info exists argArray(-local_ipv6_addr)] && ![info exists argArray(-ip_version)]} {
        set argArray(-ip_version) 6
    }
    if {[info exists argArray(-ip_version)] && $argArray(-ip_version)!=6 && ![info exists argArray(-local_ip_addr)] && [info exists argArray(-local_router_id)]} {
        set argArray(-local_ip_addr) $argArray(-local_router_id)
    }
    
    if {[info exists argArray(-remote_as_flag)]} {
            set remote_as 1000
            set unsupportArgsList [concat $unsupportArgsList remote_as_flag]
    } else {
            set remote_as 100
    }
    
    #spirent hltapi dosen't support neighbor_type, when neighbor_type is internal,
    #in spirent hltapi it means local_as and remote_as are same
    if {[info exists argArray(-neighbor_type)]} {
        set neighbor_type $argArray(-neighbor_type)
        # assume the defualt value of the remote as is 100 when the neighbor_type is external
        if {[regexp "internal" $neighbor_type]&&[info exists argArray(-local_as)]} {
            set remote_as $argArray(-local_as)
        }
        if {![info exists argArray(-remote_as)]} {
            set argArray(-remote_as) $remote_as
        }
    }

    if {[info exists argArray(-md5_enable)]} {
        set md5_enable $argArray(-md5_enable)
        if {!($md5_enable== 1  || $md5_enable==0) } {
            #remove amd5_enable
            set unsupportArgsList [concat $unsupportArgsList md5_enable]
        }
    }
	
    #gateway_ip_addr will be mapped to next_hop_ip if the ip version is ipv4 or next_hop_ipv6 if the ip version is ipv6
    if {[info exists argArray(-gateway_ip_addr)]} {
        set unsupportArgsList [concat $unsupportArgsList gateway_ip_addr]
        set gateway_ip_addr $argArray(-gateway_ip_addr)
        if {[::ip::is 4 $gateway_ip_addr]} {
            set argArray(-next_hop_ip) $gateway_ip_addr
            set unsupportArgsList [concat $unsupportArgsList next_hop_ipv6]
        } else {
            set argArray(-next_hop_ipv6) $gateway_ip_addr
            set unsupportArgsList [concat $unsupportArgsList next_hop_ip]
        }
    }
	
    #nexthop validation 
    if {[info exists argArray(-next_hop_ip)] && $argArray(-next_hop_ip) eq "0.0.0.0"} {
        set unsupportArgsList [concat $unsupportArgsList next_hop_ip]
    }

    #local_loopback_ip_addr local_loopback_ip_addr_step
    #the local_loopback_ip_addr will be mapped to the local_router_id, but the BGP session Ip addrress need to be configured to
    # Router Id if you want to use the loopback address to setup the bgp sesssion.
    if {[info exists argArray(-local_loopback_ip_addr)]&&![info exists argArray(-local_router_id)]} {
        #if -local_router_id has been configured, so just remove this local_loopback_ip_addr, else will confgiure the value
        #of local_loopback_ip_addr to local_router_id
        set local_loopback_ip_addr $argArray(-local_loopback_ip_addr)
        set argArray(-local_router_id) $local_loopback_ip_addr
    }

    if {[info exists argArray(-local_loopback_ip_addr_step)]&&![info exists argArray(-local_router_id_step)]} {
        #if -local_router_id has been configured, so just remove this local_loopback_ip_addr_step, else will confgiure the value
        #of local_loopback_ip_addr_step to local_router_id_step
        set local_loopback_ip_addr_step $argArray(-local_loopback_ip_addr_step)
        set argArray(-local_router_id_step) $local_loopback_ip_addr_step
    }

    #remove the options which can't be supported in spirent hltapi

    set ixia_only_args "bfd_registration_mode interface_handle\
                        local_loopback_ip_addr local_loopback_ip_addr_step \
                        local_router_id_enable \
                        remote_loopback_ip_addr remote_loopback_ip_addr_step\
                        neighbor_type tcp_window_size updates_per_iteration \
                        ttl_value enable_4_byte_as next_hop_enable \
                        originator_id_enable originator_id"
    set unsupportArgsList [concat $unsupportArgsList $ixia_only_args]
    #if the next_hop_ip or next_hop_ipv6 is not given, need to give one default value to make it in the same networks
    #local_addr_step should be mapped to local_ipv6_addr_step when is used
    if {[info exists argArray(-local_ipv6_addr)]} {
        #need to normalize the ipv6 address, since STC don't recgonize the different format of the ipv6 as the same ipve address.
        set local_ipv6 $argArray(-local_ipv6_addr)
        set argArray(-local_ipv6_addr) [::sth::sthCore::normalizeIPv6Addr $local_ipv6]

        if {[info exists argArray(-local_addr_step)]} {
            set argArray(-local_ipv6_addr_step) $argArray(-local_addr_step)
            set unsupportArgsList [concat $unsupportArgsList local_addr_step]
        }

        if {![info exists argArray(-next_hop_ipv6)]&&[info exists argArray(-remote_ipv6_addr)]} {
            set next_hop_ipv6 [::sth::sthCore::normalizeIPv6Addr $argArray(-remote_ipv6_addr)]
            set argArray(-remote_ipv6_addr) $next_hop_ipv6
            set argArray(-next_hop_ipv6) $next_hop_ipv6
            if {[info exists argArray(-remote_addr_step)]} {
                set argArray(-next_hop_ipv6_step) $argArray(-remote_addr_step)
            }
        }
    }
    if {[info exists argArray(-local_ip_addr)]&&![info exists argArray(-next_hop_ip)]&&[info exists argArray(-remote_ip_addr)]} {
        set argArray(-next_hop_ip) $argArray(-remote_ip_addr) 
        if {[info exists argArray(-remote_addr_step)]} {
            set argArray(-next_hop_ip_step) $argArray(-remote_addr_step) 
        }    
    }
    #if "-remote_loopback_ip_addr" is configured, based on the existing scenarios, the DUT configures the neighbor using routerid instead of interface_ip\
    #so config "router_id" as "bgp_session_ip_addr", and also maps "remote_loopback_ip_addr remote_loopback_ip_addr_step" to "remote_ip_addr remote_addr_step"
    if {[info exists argArray(-remote_loopback_ip_addr)]} {
        set argArray(-remote_ip_addr) $argArray(-remote_loopback_ip_addr)
        if {[info exists argArray(-remote_loopback_ip_addr_step)]} {
            set argArray(-remote_addr_step) $argArray(-remote_loopback_ip_addr_step)
        }
        if {![info exists argArray(-bgp_session_ip_addr)]} {
            set argArray(-bgp_session_ip_addr) router_id
        }
    }

    if {![info exists argArray(-ip_stack_version)]&&[info exists argArray(-ip_version)]} {
        set argArray(-ip_stack_version) $argArray(-ip_version)
    }
    #the reset mode for the ixia hltapi means delete all the bgp session one the bgp router for all the bgp routers on the specified port, and enable a new bgp session
    #on these handle
    set mode $argArray(-mode)
    if {$mode == "reset" && [info exists argArray(-port_handle)]} {
        set port_handle $argArray(-port_handle)
        set devices [::sth::sthCore::invoke stc::get $port_handle -AffiliationPort-Sources]
        set bgp_devices ""
        foreach device $devices {
            set bgp_session [::sth::sthCore::invoke stc::get $device -children-BgpRouterConfig]
            if {$bgp_session != ""} {
                #this is a bgp router
                set bgp_devices [concat $bgp_devices $device]
                ::sth::sthCore::invoke stc::delete $bgp_session
            }
        }
        #need to change the mode to enable and port handle to handle
        if {$bgp_devices != ""} {
            set argArray(-handle) $bgp_devices
            set unsupportArgsList [concat $unsupportArgsList port_handle]               
        }
        set argArray(-mode) "enable"
    }
    if {$mode == "disable"} {
        set argArray(-mode) "inactive"
    }
    if {[info exists argArray(-count)]&& ($argArray(-count)>1)} {
	set count $argArray(-count)
        set ret ""
        keylset ret status 1
        keylset ret handle ""
        set argArray(-count) 1

        if {[info exists argArray(-port_handle)]} {
            set port_handle $argArray(-port_handle)
        }
        set flag 0

        for {set counti 0} {$counti < $count } {incr counti} {
            set args [wrapper::shield_args -total [array get argArray] -unsupported $unsupportArgsList]
            unset unsupportArgsList
            set unsupportArgsList ""
            listToArray $args argArray
            ##local_ip_addr          
            if {[info exists argArray(-local_ip_addr)]} {
                set local_ip_addr $argArray(-local_ip_addr)
                set local_addr_step "0.0.0.1"
                if {[info exists argArray(-local_addr_step)]} {
                    set local_addr_step $argArray(-local_addr_step)
                }
                if {$counti == 0} {
                    set local_addr_step "0.0.0.0"
                }
                set local_ip_addr [::sth::sthCore::updateIpAddress 4  $local_ip_addr $local_addr_step 1]
                set argArray(-local_ip_addr) $local_ip_addr
            }
            ##local_ipv6_addr
            if {[info exists argArray(-local_ipv6_addr)]} {
                set local_ipv6_addr $argArray(-local_ipv6_addr)
                set local_ipv6_addr_step "::1"
                if {[info exists argArray(-local_ipv6_addr_step)]} {
                    set local_ipv6_addr_step $argArray(-local_ipv6_addr_step)
                }
                if {$counti == 0} {
                    set local_ipv6_addr_step "::0"
                }
                set local_ipv6_addr [::sth::sthCore::updateIpAddress 6  $local_ipv6_addr $local_ipv6_addr_step 1]
                set argArray(-local_ipv6_addr) $local_ipv6_addr
            }
            ##remote_ip_addr
            if {[info exists argArray(-remote_ip_addr)]} {
                set remote_ip_addr $argArray(-remote_ip_addr)
                set remote_addr_step "0.0.0.1"
                if {[info exists argArray(-remote_addr_step)]} {
                    set remote_addr_step $argArray(-remote_addr_step)
                }
                if {$counti == 0} {
                    set remote_addr_step "0.0.0.0"
                }
                set remote_ip_addr [::sth::sthCore::updateIpAddress 4  $remote_ip_addr $remote_addr_step 1]
                set argArray(-remote_ip_addr) $remote_ip_addr
            }
            ##remote_ipv6_addr
            if {[info exists argArray(-remote_ipv6_addr)]} {
                set remote_ipv6_addr $argArray(-remote_ipv6_addr)
                set remote_addr_step "::1"
                if {[info exists argArray(-remote_addr_step)]} {
                    set remote_addr_step $argArray(-remote_addr_step)
                }
                if {$counti == 0} {
                    set remote_addr_step "::0"
                }
                set remote_ipv6_addr [::sth::sthCore::updateIpAddress 6  $remote_ipv6_addr $remote_addr_step 1]
                set argArray(-remote_ipv6_addr) $remote_ipv6_addr
            }

            ##local_router_id
            if {[info exists argArray(-local_router_id)]} {
                set local_router_id $argArray(-local_router_id)
                set local_router_id_step "0.0.0.1"
                if {[info exists argArray(-local_router_id_step)]} {
                    set local_router_id_step $argArray(-local_router_id_step)
                }
                if {$counti == 0} {
                    set local_router_id_step "0.0.0.0"
                }
                set local_router_id [::sth::sthCore::updateIpAddress 4  $local_router_id $local_router_id_step 1]
                set argArray(-local_router_id) $local_router_id
            }
            
            ##next_hop_ip
            if {[info exists argArray(-next_hop_ip)]} {
                set next_hop_ip $argArray(-next_hop_ip)
                if {$next_hop_ip eq "0.0.0.0"} {
                    set unsupportArgsList [concat $unsupportArgsList next_hop_ip]
                } else {
                    set next_hop_ip_step "0.0.0.1"
                    if {[info exists argArray(-next_hop_ip_step)]} {
                        set next_hop_ip_step $argArray(-next_hop_ip_step)
                    } else {
                        if {[info exists argArray(-local_addr_step)]} {
                            set next_hop_ip_step $argArray(-local_addr_step)
                        }
                    }
                    if {$counti == 0} {
                        set next_hop_ip_step "0.0.0.0"
                    }
                    set next_hop_ip [::sth::sthCore::updateIpAddress 4  $next_hop_ip $next_hop_ip_step 1]
                    set argArray(-next_hop_ip) $next_hop_ip
                }
            }

            ##next_hop_ipv6
            if {[info exists argArray(-next_hop_ipv6)]} {
                set next_hop_ipv6 $argArray(-next_hop_ipv6)
                set next_hop_ipv6_step "::1"
                if {[info exists argArray(-next_hop_ipv6_step)]} {
                    set next_hop_ipv6_step $argArray(-next_hop_ipv6_step)
                } else {
                    if {[info exists argArray(-local_ipv6_addr_step)]} {
                        set next_hop_ipv6_step $argArray(-local_ipv6_addr_step)
                    }
                }
                if {$counti == 0} {
                    set next_hop_ipv6_step "::0"
                }
                set next_hop_ipv6 [::sth::sthCore::updateIpAddress 6  $next_hop_ipv6 $next_hop_ipv6_step 1]
                set argArray(-next_hop_ipv6) $next_hop_ipv6
            }

            #handle in qos, local_ip_addr and gw are not same domain
            if {![info exists argArray(-remote_loopback_ip_addr)]&&[info exists argArray(-next_hop_ip)]&&[info exists argArray(-local_ip_addr)]} {
                set next_hop_ip $argArray(-next_hop_ip)
                set local_ip_addr $argArray(-local_ip_addr)
                set gwList [split $next_hop_ip "."]
                set ipList [split $local_ip_addr "."]
                if {([lindex $gwList 0] ne [lindex $ipList 0]) || ([lindex $gwList 1] ne [lindex $ipList 1])} {
                    if {![info exists argArray(-bgp_session_ip_addr)]} {
                        set argArray(-bgp_session_ip_addr) router_id
                    }
                    set argArray(-local_router_id) $local_ip_addr
                    set local_ip_addr [::sth::sthCore::updateIpAddress 4  $next_hop_ip "0.0.0.1" 1]
                    set argArray(-local_ip_addr) $local_ip_addr
                }                
            }

            #check if there is already one device created with the same ip, then use this mac address as mac_address_start
            foreach ip_addr_arg "-local_ip_addr -local_ipv6_addr" {
                #check if there is already one device created with the same ip, then use this mac address as mac_address_start
                if {[info exists argArray($ip_addr_arg)]&&[info exists argArray(-port_handle)]} {
                    set intf_ip_addr $argArray($ip_addr_arg)
                    set port_hdl $argArray(-port_handle)
                    set device [::wrapper::get_device_with_ip_new $intf_ip_addr $port_hdl]

                    catch {unset bgpRoute}
                    catch {unset existedBgpVersion}
                    catch {unset configBgpVersion}
                    if {$device != ""} {
                        set bgpRoute [stc::get $device -children-bgprouterconfig]
                        if {"" != $bgpRoute} {
                            set existedBgpVersion [stc::get $bgpRoute -IpVersion]
                            if {[info exists argArray(-ip_version)] && ($argArray(-ip_version)==6)} {                                       
                                set configBgpVersion ipv6
                            } else {
                                set configBgpVersion ipv4
                            }
                        }
                        if {![info exist existedBgpVersion] || [string equal -nocase $existedBgpVersion $configBgpVersion]} {
                            set argArray(-handle) $device
                            set unsupportArgsList [concat $unsupportArgsList port_handle]
                            set flag 1
                            ##need modify hosts gw if exist next hop
                            if {[info exists argArray(-next_hop_ipv6)]} {
                                set next_hop_ipv6 $argArray(-next_hop_ipv6)
                                set ipv6if [lindex [::sth::sthCore::invoke stc::get $device -children-ipv6if] 0]
                                ::sth::sthCore::invoke stc::config $ipv6if -Gateway $next_hop_ipv6
                            }
                            if {[info exists argArray(-next_hop_ip)]} {
                                set next_hop_ip $argArray(-next_hop_ip)
                                set ipv4if [lindex [::sth::sthCore::invoke stc::get $device -children-ipv4if] 0]
                                ::sth::sthCore::invoke stc::config $ipv4if -Gateway $next_hop_ip
                            }
                        }
                    }
                }
            }
            set args [wrapper::shield_args -total [array get argArray] -unsupported $unsupportArgsList]
            unset unsupportArgsList
            set unsupportArgsList ""
            listToArray $args argArray
            set cmdName "sth::emulation_bgp_config $args"
            set reti [::spirent::process_cmd $cmdName]
            if {[keylget reti status] == 0} {
                keylset ret status 1
                keylset ret log [keylget reti log]
                return $ret
            }
            if {[info exists argArray(-local_ip_addr)]} {
                set intf_ip_addr $argArray(-local_ip_addr)
                set ::spirent::ip_device($intf_ip_addr) [keylget reti handle]
            }
            if {[info exists argArray(-local_ipv6_addr)]} {
                set intf_ip_addr $argArray(-local_ipv6_addr)
                set ::spirent::ip_device([::sth::sthCore::normalizeIPv6Addr $intf_ip_addr]) [keylget reti handle]
            }
            ##when create BGP on an existed interface handle, -AddrStepMask can not be set correctly
            if {$flag && [info exists argArray(-netmask)]} {
                set value $argArray(-netmask)
                if {[info exists argArray(-local_ip_addr)]} {
                    set ipVersion 4
                    # allow user to specify netmask in IP notation (for backwards compatibility)
                    if {[llength [split $value .]] == 4 && [::ip::is $ipVersion $value]} {
                        set ipMask $value
                        set prefixLength [::ip::maskToLength $ipMask]
                    } else {
                        set ipMask [sth::sthCore::prefixLengthToIpMask $value $ipVersion]
                        set prefixLength $value
                    }
                    set tempHandle [::sth::sthCore::invoke stc::get [keylget reti handle] -children-ipv4if]
                    ::sth::sthCore::invoke stc::config $tempHandle [list -PrefixLength $prefixLength -AddrStepMask $ipMask]
                }
                if {[info exists argArray(-local_ipv6_addr)]} {
                    set ipVersion 6
                    set ipMask [sth::sthCore::prefixLengthToIpMask $value $ipVersion]
                    set prefixLength $value
                    set tempHandle [lindex [::sth::sthCore::invoke stc::get [keylget reti handle] -children-ipv6if] 0]
                    ::sth::sthCore::invoke stc::config $tempHandle [list -PrefixLength $prefixLength -AddrStepMask $ipMask]
                }
            }
            set unsupported_args ""
            if {$flag} {
                set flag 0
                set unsupported_args [concat $unsupported_args handle]
                set argArray(-port_handle) $port_handle
            }
            keylset ret handle "[keylget ret handle] [keylget reti handle]"
            ##modify vlan_id for next time
            if {[info exists argArray(-vlan_id)]} {
                catch {unset tempVlanValue}
                if {[info exists argArray(-vlan_id_step)]} {
                    set tempVlanValue [expr $argArray(-vlan_id) + $argArray(-vlan_id_step)]
                } elseif {[info exists argArray(-vlan_id_mode)]&& [string equal -nocase "increment" $argArray(-vlan_id_mode)]} {
                    set tempVlanValue [expr $argArray(-vlan_id) +1]
                }
                if {[info exist tempVlanValue]} {
                    set argArray(-vlan_id) $tempVlanValue
                }
            }
            ##config routerID again.
            if {[info exists argArray(-local_router_id)]} {
                set local_router_id $argArray(-local_router_id)
                ::sth::sthCore::invoke stc::config [keylget reti handle] -routerid $local_router_id
            }
            ###turn back local_ip_addr VS router_ID
            if {![info exists argArray(-remote_loopback_ip_addr)]&&[info exists argArray(-local_router_id)]&&[info exists argArray(-local_ip_addr)]} {
                #handle in qos, local_ip_addr and gw are not same domain
                    set local_router_id $argArray(-local_router_id)
                    set local_ip_addr $argArray(-local_ip_addr)
                    set unsupported_args [concat $unsupported_args "bgp_session_ip_addr"]
                    set argArray(-local_router_id) $local_ip_addr
                    set argArray(-local_ip_addr) $local_router_id
            }
            set args [wrapper::shield_args -total [array get argArray] -unsupported $unsupported_args]
            unset unsupported_args
            listToArray $args argArray            
        }
        keylset ret handles [keylget ret handle]
        foreach rtrhandle [keylget ret handles] {
            ::sth::sthCore::invoke stc::config $rtrhandle -EnablePingResponse TRUE
        }
	set return_list $ret
        return $ret
    } else {
        #all the same function whose name space is sth::
        #handle in qos, local_ip_addr and gw are not same domain
        if {![info exists argArray(-remote_loopback_ip_addr)]&&[info exists argArray(-next_hop_ip)]&&[info exists argArray(-local_ip_addr)]} {
            set next_hop_ip $argArray(-next_hop_ip)
            set local_ip_addr $argArray(-local_ip_addr)
            set gwList [split $next_hop_ip "."]
            set ipList [split $local_ip_addr "."]
            if {([lindex $gwList 0] ne [lindex $ipList 0]) || ([lindex $gwList 1] ne [lindex $ipList 1])} {
                if {![info exists argArray(-bgp_session_ip_addr)]} {
                    set argArray(-bgp_session_ip_addr) router_id
                }
                set argArray(-local_router_id) $local_ip_addr
                set local_ip_addr [::sth::sthCore::updateIpAddress 4  $next_hop_ip "0.0.0.1" 1]
                set argArray(-local_ip_addr) $local_ip_addr
            }           
        }

        foreach ip_addr_arg "-local_ip_addr -local_ipv6_addr" {
            #check if there is already one device created with the same ip, then use this mac address as mac_address_start
            if {[info exists argArray($ip_addr_arg)]&&[info exists argArray(-port_handle)]} {
                set intf_ip_addr $argArray($ip_addr_arg)
                set port_hdl $argArray(-port_handle)
                set device [::wrapper::get_device_with_ip_new $intf_ip_addr $port_hdl]

                catch {unset bgpRoute}
                catch {unset existedBgpVersion}
                catch {unset configBgpVersion}
                if {$device != ""} {
                    set bgpRoute [stc::get $device -children-bgprouterconfig]
                    if {"" != $bgpRoute} {
                        set existedBgpVersion [stc::get $bgpRoute -IpVersion]
                        if {[info exists argArray(-ip_version)] && ($argArray(-ip_version)==6)} {                                       
                            set configBgpVersion ipv6
                        } else {
                            set configBgpVersion ipv4
                        }
                    }
                    if {![info exist existedBgpVersion] || [string equal -nocase $existedBgpVersion $configBgpVersion]} {
                        set argArray(-handle) $device
                        set unsupportArgsList [concat $unsupportArgsList port_handle]
                        ##need modify hosts gw if exist next hop
                        if {[info exists argArray(-next_hop_ipv6)]} {
                            set next_hop_ipv6 $argArray(-next_hop_ipv6)
                            set ipv6if [lindex [::sth::sthCore::invoke stc::get $device -children-ipv6if] 0]
                            ::sth::sthCore::invoke stc::config $ipv6if -Gateway $next_hop_ipv6
                        }
                        if {[info exists argArray(-next_hop_ip)]} {
                            set next_hop_ip $argArray(-next_hop_ip)
                            set ipv4if [lindex [::sth::sthCore::invoke stc::get $device -children-ipv4if] 0]
                            ::sth::sthCore::invoke stc::config $ipv4if -Gateway $next_hop_ip
                        }
                    }
                }
            }
        }
        set processed_args [wrapper::shield_args -total [array get argArray] -unsupported $unsupportArgsList]
        unset unsupportArgsList
        listToArray $processed_args argArray
        set cmdName "sth::emulation_bgp_config $processed_args"
        set retKeyedList [::spirent::process_cmd $cmdName]
        ##when create BGP on an existed interface handle, -AddrStepMask can not be set correctly
        if {[info exists argArray(-handle)] && [info exists argArray(-netmask)]} {
            set value $argArray(-netmask)
            if {[info exists argArray(-local_ip_addr)]} {
                set ipVersion 4
                # allow user to specify netmask in IP notation (for backwards compatibility)
                if {[llength [split $value .]] == 4 && [::ip::is $ipVersion $value]} {
                    set ipMask $value
                    set prefixLength [::ip::maskToLength $ipMask]
                } else {
                    set ipMask [sth::sthCore::prefixLengthToIpMask $value $ipVersion]
                    set prefixLength $value
                }
                set tempHandle [::sth::sthCore::invoke stc::get [keylget retKeyedList handle] -children-ipv4if]
                ::sth::sthCore::invoke stc::config $tempHandle [list -PrefixLength $prefixLength -AddrStepMask $ipMask]
            }
            if {[info exists argArray(-local_ipv6_addr)]} {
                set ipVersion 6
                set ipMask [sth::sthCore::prefixLengthToIpMask $value $ipVersion]
                set prefixLength $value
                set tempHandle [lindex [::sth::sthCore::invoke stc::get [keylget retKeyedList handle] -children-ipv6if] 0]
                ::sth::sthCore::invoke stc::config $tempHandle [list -PrefixLength $prefixLength -AddrStepMask $ipMask]
            }
        }
        ##config routerID again.
        if {[info exists argArray(-local_router_id)]} {
             set local_router_id $argArray(-local_router_id)
             ::sth::sthCore::invoke stc::config [keylget retKeyedList handle] -routerid $local_router_id
        }
        if {[info exists argArray(-mode)]} {
            set modevalue $argArray(-mode)
            if {[regexp -nocase "modify" $modevalue]} {
                ###modify mode not return handle, so return here
                return $retKeyedList
            }
        }
    }
    if {[string match -nocase $mode enable]} {
        set rtrhandles [keylget retKeyedList handle]
        foreach rtrhandle $rtrhandles {
            ::sth::sthCore::invoke stc::config $rtrhandle -EnablePingResponse TRUE
        }
    }
    set return_list $retKeyedList
    if {[info exist argArray(-local_ip_addr)]} {
        set local_ip_addr $argArray(-local_ip_addr)
        set ::spirent::ip_device($local_ip_addr) [keylget return_list handle]
    }
    return $retKeyedList
}

proc ::spirent::emulation_bgp_route_config { args } {
    #import_target, import_target_assign, import_target_step, import_target_type and  target_assign_step will be enhanced in hltapi.

    #as_path_set_mode:                  Not supported, removed. for the external route,specify if the local as will be include, when include, in which type it will be included
    #enable_generate_unique_routes:     Not supported, removed. If not selected, every neighbor in the range generates exactly the same set of routes, starting from the first route.
    #enable_traditional_nlri:           Not supported, removed. If selected, Update messages uses the traditional NLRI information.

    #packing_from:                      Not supported, removed. for the STC, the packing_from and packing_to should be the same value, both mappped to packing_to
    #prefix_from:                       this is support is the STC when use the wizard mode to create the bgp route, but hltapi not use the wizard mode to create it, so we need to process here
    #prefix_to:                         this is support is the STC when use the wizard mode to create the bgp route, but hltapi not use the wizard mode to create it, so we need to process here

    #label_value:
    #next_hop_enable:                   Not supported, removed. STC can configure the next hop ip always, if no next_hop configured, it will configure the next_hop to same with the ip address.
    #next_hop_mode:                     Not supported, removed. if this arg is not in the config, means that the next_hop will be same for all the routes.
                                        # need to check if need to add the arg to config the next hop increment to be 0.0.0.0?
    #no_write:                          Not supported, removed. this arg is to decide whether to apply the configure now or later, no need to use this in spirent hltapi
    #num_sites:                         Maps to max_route_ranges.
    #origin_route_enable:                Not supported, removed. need to check when Originator ID is this router id, and origin_route_enable is not there, means to diactive this route?

	global return_list
	
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    ::spirent::listToArray $args argArray
	set parentnamespace ""
    set procedure [info level 1]
    regexp -nocase {:*([a-z]+)::} $procedure -> parentnamespace
	
    #remove the options which can't be supported in spirent hltapi
    if {[lsearch $args "-as_path"] > -1} {
        #set as_path_index [lsearch $args "-as_path"]
        #set as_path [lindex $args [expr $as_path_index + 1]]
        # Taking as_path from the array to handle multiple values like as_set and as_seq
        set as_path $argArray(-as_path)
        if {$as_path == {}} {
            set args [wrapper::shield_args -total $args -unsupported "as_path"]
            set router_indx [lsearch $args "-handle"]
            set router [lindex [lindex $args [expr $router_indx + 1]] 0]
            set bgp_router [::sth::sthCore::invoke stc::get $router -children-BgpRouterConfig]
            set router_as [::sth::sthCore::invoke stc::get $bgp_router -AsNum]
            set args "$args -as_path as_seq:$router_as"

        } else {
            set router_indx [lsearch $args "-handle"]
            set router [lindex [lindex $args [expr $router_indx + 1]] 0]
            set bgp_router [::sth::sthCore::invoke stc::get $router -children-BgpRouterConfig]
            set router_as [::sth::sthCore::invoke stc::get $bgp_router -AsNum]
            # Removing as_seq if both as_set and as_seq is given in Agilent
            if {[regexp "as_set" $as_path] && [regexp "as_seq" $as_path]} {
                regsub -nocase -- "as_seq:\\d+" $as_path "" as_path
                set argArray(-as_path) $as_path
                set args [array get argArray]
            } elseif {[regexp "as_seq" $as_path] && ![regexp "as_set" $as_path]} {
                regexp -nocase -- "as_seq:(\[\\d,]+)" $as_path _ asseqvalue
                if {$router_as != $asseqvalue} {
                    set args [wrapper::shield_args -total $args -unsupported "as_path"]
                    set args "$args -as_path as_seq:$router_as,$asseqvalue"
                }
            }
        }
    } else {
        #if there is no "as_path" ixia will use an default value:"as_set:<router as>"
        set router_indx [lsearch $args "-handle"]
        set router [lindex [lindex $args [expr $router_indx + 1]] 0]
        set bgp_router [::sth::sthCore::invoke stc::get $router -children-BgpRouterConfig]
        set router_as [::sth::sthCore::invoke stc::get $bgp_router -AsNum]
        set args "$args -as_path as_set:$router_as"
    }

    if {[lsearch $args "-communities"] > -1} {
        set communities_index [lsearch $args "-communities"]
        set communities [lindex $args [expr $communities_index + 1]]
    }

    if {[lsearch $args "-packing_to"] > -1} {
        set prefix_index [lsearch $args "-packing_to"]
        set prefix [lindex $args [expr $prefix_index + 1]]
        if {$prefix == 0} {
            set args [wrapper::shield_args -total $args -unsupported "packing_to"]
            set args "$args -packing_to 1"
        }
    }

    if {[lsearch $args "-originator_id"] > -1} {
        if {([lsearch $args "-originator_id_enable"] > -1)} {
            ::spirent::listToArray $$args argArray
	    if {[string equal $argArray(-originator_id_enable) "0"]} {
	        set argArray(-originator_id_enable) 1
	        set args [array get argArray]
	    }  
	} else {
            set args "$args -originator_id_enable 1"
        }
     }

    set ixia_only_args "as_path_set_mode enable_generate_unique_routes enable_traditional_nlri \
                        label_value label_step next_hop_enable no_write \
                        origin_route_enable packing_from prefix_to prefix_from communities_enable communities enable_as_path end_of_rib enable_local_pref"
    set processed_args [wrapper::shield_args -total $args -unsupported $ixia_only_args]

    #process prefix_from and prefix_to here, they are mapping to the netmask(ipv4 route) ipv6_prefix_length(ipv6 route)
    set ip_version 4
    set prefix_from 0
    set prefix_to 0
    if {[lsearch $args "-prefix"] > -1} {
        set prefix_index [lsearch $args "-prefix"]
        set prefix [lindex $args [expr $prefix_index + 1]]
        if {[regexp "\:" $prefix]} {
            set ip_version 6
        }
    }

    if {[lsearch $args "-prefix_to"] > -1} {
        set prefix_to_index [lsearch $args "-prefix_to"]
        set prefix_to [lindex $args [expr $prefix_to_index + 1]]

        if {[lsearch $args "-prefix_from"] > -1} {
            set prefix_from_index [lsearch $args "-prefix_from"]
            set prefix_from [lindex $args [expr $prefix_from_index + 1]]

        } else {
            set prefix_from $prefix_to
        }
    } elseif {[lsearch $args "-prefix_from"] > -1} {
        set prefix_from_index [lsearch $args "-prefix_from"]
        set prefix_from [lindex $args [expr $prefix_from_index + 1]]
        set prefix_to $prefix_from
    }

    if {$prefix_to != 0} {
        #insert the netmask or the ipv6_prefix_length
        if {$ip_version == 4} {
            set processed_args [concat $processed_args "-netmask $prefix_to"]
        } else {
            set processed_args [concat $processed_args "-ipv6_prefix_length $prefix_to"]
        }
    }

    #if -next_hop_ip is not input, check the way to set up bgp session,
    #if it ues "routerid" to set up the bgp session, set routerId as -next_hop instead of interfaceIp
    set bgp_router ""
    if {[lsearch $processed_args "-next_hop"] < 0} {
        set router_indx [lsearch $args "-handle"]
        set router [lindex [lindex $args [expr $router_indx + 1]] 0]
        set bgp_router [::sth::sthCore::invoke stc::get $router -children-BgpRouterConfig]
        set sessionType [::sth::sthCore::invoke stc::get $bgp_router -BgpSessionIpAddress]
        if {[regexp -nocase "router_id" $sessionType]} {
            set routerid [::sth::sthCore::invoke stc::get $router -RouterId]
            if {[::ip::is ipv4 $routerid]} {
                set ipversion 4
            } else {
                set ipversion 6
            }
            set processed_args [wrapper::shield_args -total $processed_args -unsupported next_hop_set_mode]
            set ip_version $ipversion
            if {[lsearch $processed_args "-ip_version"] > -1} {
                set ip_version [lindex $processed_args [expr [lsearch $processed_args "-ip_version"] + 1]]
            }
            if {$ip_version == $ipversion} {
                set processed_args "$processed_args -next_hop $routerid -next_hop_set_mode manual -next_hop_ip_version $ipversion"
            } else {
                set processed_args "$processed_args -next_hop ::ffff:[regsub -all {\.} $routerid {:}] -local_next_hop fe80::1 -next_hop_set_mode manual -next_hop_ip_version $ip_version"
            }
        }
    }

    #config -label_value in bgprouterconfig -MinLabel
    if {[lsearch $args "-label_value"] > -1} {
            set labelvalue [lindex $args [expr [lsearch $args "-label_value"] + 1]]
            if {$bgp_router == ""} {
                set router_indx [lsearch $args "-handle"]
                set router [lindex [lindex $args [expr $router_indx + 1]] 0]
                set bgp_router [::sth::sthCore::invoke stc::get $router -children-BgpRouterConfig]
            }
            ::sth::sthCore::invoke stc::config $bgp_router -MinLabel $labelvalue
    }

    array set ixia_spirent_arg_array "num_sites max_route_ranges"
    set processed_args [wrapper::convert_args -total $processed_args -unsupported ixia_spirent_arg_array]
    ::spirent::listToArray $processed_args argArray
    if {[info exist argArray(-next_hop_mode)] && ($argArray(-next_hop_mode) == "increment" || \
                            $argArray(-next_hop_mode) == "incrementPerPrefix") && \
                            [info exist argArray(-next_hop)] && ($argArray(-next_hop) != "0.0.0.0")} {
        if {[regexp -nocase "as_seq" $argArray(-as_path)]} {
            set aspathtype SEQUENCE
            regexp "as_seq:(.*)" $argArray(-as_path) _ aspath
            set aspath [split $aspath ,]
        } elseif {[regexp -nocase "as_set" $argArray(-as_path)]} {
            set aspathtype SET
            regexp "as_set:(.*)" $argArray(-as_path) _ aspath
            set aspath [split $aspath ,]
        }
        set route_handles ""
        if {[info exist argArray(-num_routes)] && $argArray(-num_routes) > 1} {
            for {set i 1} {$i <= $argArray(-num_routes)} {incr i} {
                set bgptrtcfg [::sth::sthCore::invoke stc::get $argArray(-handle) -children-BgpRouterConfig]
                set ipversion [::sth::sthCore::invoke stc::get $bgptrtcfg -IpVersion]
                if {[string equal -nocase "ipv4" $ipversion]} {
                    set bgproutecfg [::sth::sthCore::invoke stc::create BgpIpv4RouteConfig -under $bgptrtcfg \
                                -AsPathSegmentType $aspathtype -AsPath "$aspath" -NextHop $argArray(-next_hop) \
                                -Origin $argArray(-origin)]
                    lappend route_handles $bgproutecfg
                    set ipnetblk [::sth::sthCore::invoke stc::get $bgproutecfg -children-ipv4networkblock]
                    ::sth::sthCore::invoke stc::config $ipnetblk -PrefixLength 24 -NetworkCount 1 -StartIpList $argArray(-prefix)
                    ::sth::sthCore::invoke stc::apply
                    set argArray(-prefix) [::wrapper::ConvertIncrementIpAddress $argArray(-prefix) 256]
                    set argArray(-next_hop) [::wrapper::ConvertIncrementIpAddress $argArray(-next_hop) 1]
                }
            }
        }
        keylset retKeyedList handles $route_handles
        keylset retKeyedList status 1
    } else {
        ##still need shield next_hop_mode
        set processed_args [wrapper::shield_args -total $processed_args -unsupported "next_hop_mode"]
        #all the same function whose name space is sth::
	    if {$prefix_from == $prefix_to} {
	        set cmdName "sth::emulation_bgp_route_config $processed_args"
	        set retKeyedList [::spirent::process_cmd $cmdName]
	    } else {
	        #in the script which need to be converted, prefix_from == prefix_to, if they are not equal, need to process here, will create more than one bgp route.
	        # the num_route may will be updated. need to take care of.
	        set cmdName "sth::emulation_bgp_route_config $processed_args"
	        set retKeyedList [::spirent::process_cmd $cmdName]
	    }
	}

    #if -num_sites(max_route_ranges) is greater than one, then modify route target based on the target_assign_step,
    #Spirent hltapi has already used this arg to config RouteTargetStep, so we modify this in shim layer
    set num_sites [lindex $processed_args [expr [lsearch $processed_args "-max_route_ranges"] + 1]]
    if {$num_sites > 1} {
        set bgproutecfgList [keylget retKeyedList handles]
        if {[lsearch $processed_args "-target_assign_step"] > -1} {
            set assign_step [lindex $processed_args [expr [lsearch $processed_args "-target_assign_step"] + 1]]
        } else {
            set assign_step 1
        }

        set bgpvpnrouteconfig [::sth::sthCore::invoke stc::get [lindex $bgproutecfgList 0] -children-bgpvpnrouteconfig]
        if {$bgpvpnrouteconfig != ""} {
            set first_rt [::sth::sthCore::invoke stc::get $bgpvpnrouteconfig -RouteTarget]
            set first_target [lindex [split $first_rt :] 0]
            set first_assign [lindex [split $first_rt :] 1]
            for {set i 1} {$i < [llength $bgproutecfgList]} {incr i} {
                set rt [join [list $first_target [expr $first_assign + [expr $assign_step * $i]]] :]
                set bgpvpnrouteconfig [::sth::sthCore::invoke stc::get [lindex $bgproutecfgList $i] -children-bgpvpnrouteconfig]
                ::sth::sthCore::invoke stc::config $bgpvpnrouteconfig -RouteTarget $rt
            }
        }
    }
    if {[string match -nocase $argArray(-mode) add]} {
        set bgp_routes [keylget retKeyedList handles]
        keylset retKeyedList bgp_routes $bgp_routes
    } else {
        set bgp_routes $argArray(-route_handle)
    }
    if {[info exists communities]} {
        foreach bgp_route $bgp_routes {
            ::sth::sthCore::invoke stc::config $bgp_route -Community "0:$communities"
        }
    }
    if {[string match -nocase $parentnamespace "AgtTest"]} {
        keylset retKeyedList route_pool_handles [keylget retKeyedList bgp_routes]
        keyldel retKeyedList bgp_routes
        set return_list $retKeyedList
        return $retKeyedList
    }
    set return_list $retKeyedList
    return $retKeyedList
}

proc ::spirent::emulation_bgp_control {args} {
    set ixia_only_args ""
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
	
	###Converting handle for Agilent
	if {[lsearch $args "-handle"]> -1} {
        set hnd [lsearch $args "-handle"]
		set handle [lindex [lindex $args [expr $hnd + 1]] 0]
		if {[string is integer $handle]} {
			set args [wrapper::shield_args -total $args -unsupported "handle"]
			set handle host$handle
			set args "$args -handle $handle"
		}
    }

	
    array set ixia_spirent_arg_array "port_handle handle"
    set processed_args [wrapper::convert_args -total $args -unsupported ixia_spirent_arg_array]
    if {[lsearch $processed_args "-mode"] > -1} {
        set mode [lindex $processed_args [expr [lsearch $processed_args "-mode"] + 1]]
        if {$mode eq "restart"} {
            set handleList ""
            if {[lsearch $args "-port_handle"] > -1} {
                set port_handle [::wrapper::get_value_list $args "-port_handle"]
                foreach port $port_handle {
                    set port_host [::sth::sthCore::invoke stc::get $port -affiliationport-Sources]
                    foreach host $port_host {
                        if {[regexp -nocase "BgpRouterConfig" [::sth::sthCore::invoke stc::get $host -children]]} {
                            lappend handleList $host
                        }
                    }
                }
            }
            if {[lsearch $args "-handle"] > -1} {
                set handleList [::wrapper::get_value_list $args "-handle"]
            }
            ::sth::sthCore::invoke stc::perform DeviceStop -DeviceList $handleList
            ::sth::sthCore::invoke stc::perform DeviceStart -DeviceList $handleList
            keylset retVal seconds "N/A"
            keylset retVal status  1
            keylset retVal clicks "N/A"
            return $retVal
        }
    }
    set cmdName "sth::emulation_bgp_control $processed_args"

    set retVal [::spirent::process_cmd $cmdName]
    keylset retVal seconds "N/A"
    keylset retVal clicks "N/A"
    return $retVal
}

proc ::spirent::emulation_ospf_config {args} {
################################################################################
##
## -port_handle: should not be a list
##
## step 1: set variables
## step 2: if there is "-" in args value, replace it by "_"
## step 3: shield/convert
## step 4: convert args vlaues to STC style
## step 5: set "step" values
## step 6: set manual variables values
##
################################################################################

    global return_list
    variable ::spirent::MacList
    ##step 1
    array set argArray {}
    set tempArray(-areaIdStep) "0.0.0.0"
    ##_## we are seeting the count as 1 always. This is not the correct way.
    ##_## So Commenting the below line and passing the user input value if it is define.
    ##_## If it is not defined then setting it to 1.
    ##_##set tempArray(-count) 1
    set tempArray(-gwIpAddrStep4) "0.0.0.1"
    set tempArray(-gwIpAddrStep6) "0000::1"
    set tempArray(-intfIpAddr) "192.85.1.3"
    set tempArray(-intfIpAddrStep4) "0.0.0.1"
    set tempArray(-intfIpAddrStep6) "0000::1"
    set tempArray(-macAddr) ""
    set tempArray(-macAddrStep) ""
    set tempArray(-routerIdStep) "0.0.0.1"
    set handleInArgs ""
    set result ""
    set tempResult ""
    keylset result status 1
    keylset result handle ""
    keylset result handles ""
    keylset result session_router ""

    ##step 2
    regsub -nocase -- "external-capable" $args "external_capable" args

    ##format port_handle value to STC style
    #if here is "-" in args values, DO NOT execute proc ::spirent::port_converter
    set args [eval ::spirent::port_converter $args]

    ::spirent::listToArray $args argArray

	##_## te_admin_group
	if {[info exist argArray(-te_admin_group)]} {
		set records [split $argArray(-te_admin_group) "."]
		set argArray(-te_admin_group) [join $records ""]
		if {$argArray(-te_admin_group) < 1} {
			unset argArray(-te_admin_group)
		}
	}

	##_## count
	if {[info exist argArray(-count)] && $argArray(-count) <= 100} {
		set tempArray(-count) $argArray(-count)
	} else {
		set tempArray(-count) 1
	}

    ## default network_type should be broadcast and hello interval is 10
    if {[info exist argArray(-network_type)]} {
        if {$argArray(-network_type) eq "broadcast"} {
            if {![info exist argArray(-hello_interval)]} {
                set argArray(-hello_interval) 10
            }
        }
    } else {
        set argArray(-network_type) "broadcast"
        if {![info exist argArray(-hello_interval)]} {
            set argArray(-hello_interval) 10
        }
    }
	
    if {(([info exist argArray(-mode)] && ("create" == $argArray(-mode))) && (([info exist argArray(-reset)]) && ("1" == $argArray(-reset))))} {
        set port_handle $argArray(-port_handle)
        set devices [::sth::sthCore::invoke stc::get $port_handle -AffiliationPort-Sources]
        set ospf_devices ""
        foreach device $devices {
            set ospf_session [::sth::sthCore::invoke stc::get $device -children-Ospfv2RouterConfig]
            if {$ospf_session != ""} {
                #this is a OSPF router
                set ospf_devices [concat $ospf_devices $device]
                ::sth::sthCore::invoke stc::delete $ospf_session
            }
        }
        unset argArray(-reset)
    }
    
    ##step 3
    array unset argArray -lsa_discard_mode
    array unset argArray -mtu
    array unset argArray -reset
    array unset argArray -validate_received_mtu
    array unset argArray -neighbor_router_id
    
    array unset argArray -graceful_restart_helper_mode_enable
    array unset argArray -strict_lsa_checking
    array unset argArray -support_reason_sw_reload_or_upgrade
    array unset argArray -support_reason_sw_restart
    array unset argArray -support_reason_switch_to_redundant_processor_control
    array unset argArray -support_reason_unknown
    array unset argArray -ignore_db_desc_mtu
    array unset argArray -poll_interval
    
    if {[info exist argArray(-vlan)]} {
        if {0 == $argArray(-vlan)} {
            array unset argArray -vlan_id
            array unset argArray -vlan_id_mode
            array unset argArray -vlan_id_step
            array unset argArray -vlan_user_priority
        }
        array unset argArray -vlan
    }
    
    if {[info exist argArray(-option_bits)]} {
        if {![regexp -nocase "0x" $argArray(-option_bits)]} {
                set argArray(-option_bits) "0x$argArray(-option_bits)"
        }
    }
    
    if {[info exist argArray(-session_type)]} {
        if {[regexp -nocase "ospfv3" $argArray(-session_type)]} {
            set ::sth::ospfTopology::currentOSPFVersion $::sth::ospfTopology::OSPFV3_STR 
        } else {
            set ::sth::ospfTopology::currentOSPFVersion $::sth::ospfTopology::OSPFV2_STR
        }
    } else {
        set argArray(-session_type) ospfv2
        set ::sth::ospfTopology::currentOSPFVersion $::sth::ospfTopology::OSPFV2_STR
    }
    if {[info exist argArray(-interface_handle)]} {
        set argArray(-handle) $argArray(-interface_handle)
        unset argArray(-interface_handle)
    }
    if {[info exist argArray(-mac_address_init)]} {
        set argArray(-mac_address_start) $argArray(-mac_address_init)
        unset argArray(-mac_address_init)
    }
    if {[info exist argArray(-neighbor_intf_ip_addr)]} {
        set argArray(-gateway_ip_addr) $argArray(-neighbor_intf_ip_addr)
        unset argArray(-neighbor_intf_ip_addr)
    }
    if {[info exist argArray(-router_id)]} {
        array unset argArray -loopback_ip_addr
        array unset argArray -loopback_ip_addr_step
    } else {
        if {[info exist argArray(-loopback_ip_addr)]} {
            set argArray(-router_id) $argArray(-loopback_ip_addr)
            unset argArray(-loopback_ip_addr)
        }
        if {[info exist argArray(-loopback_ip_addr_step)]} {
            set argArray(-router_id_step) $argArray(-loopback_ip_addr_step)
            unset argArray(-loopback_ip_addr_step)
        }
    }

    ##step 4
    if {[info exist argArray(-authentication_mode)] && [string equal -nocase "null" $argArray(-authentication_mode)]} {
        set argArray(-authentication_mode) "none"
    }

    ##step5
    if {[info exist argArray(-intf_ip_addr_step)]} {
        if {[regexp -- {:} $argArray(-intf_ip_addr_step)]} {
            set tempArray(-intfIpAddrStep6) $argArray(-intf_ip_addr_step)
        } else {
            set tempArray(-intfIpAddrStep4) $argArray(-intf_ip_addr_step)
        }
        unset argArray(-intf_ip_addr_step)
    } elseif {[info exist argArray(-neighbor_intf_ip_addr_step)]} {
        if {[regexp -- {:} $argArray(-neighbor_intf_ip_addr_step)]} {
            set tempArray(-intfIpAddrStep6) $argArray(-neighbor_intf_ip_addr_step)
        } else {
            set tempArray(-intfIpAddrStep4) $argArray(-neighbor_intf_ip_addr_step)
        }
    }
    
    if {[info exist argArray(-neighbor_intf_ip_addr_step)]} {
        set argArray(-gateway_ip_addr_step) $argArray(-neighbor_intf_ip_addr_step)
        unset argArray(-neighbor_intf_ip_addr_step)
    }
    
    if {[info exist argArray(-router_id_step)]} {
        set tempArray(-routerIdStep) $argArray(-router_id_step)
        unset argArray(-router_id_step)
    }
    if {[info exist argArray(-area_id_step)]} {
        set tempArray(-areaIdStep) $argArray(-area_id_step)
        unset argArray(-area_id_step)
    }
    if {[info exist argArray(-gateway_ip_addr_step)]} {
        if {[regexp -- {:} $argArray(-gateway_ip_addr_step)]} {
            set tempArray(-gwIpAddrStep6) $argArray(-gateway_ip_addr_step)
        } else {
            set tempArray(-gwIpAddrStep4) $argArray(-gateway_ip_addr_step)
        }
        unset argArray(-gateway_ip_addr_step)
    }
    if {[info exist argArray(-mac_address_start)] && [info exist argArray(-mac_address_step)]} {
        set tempArray(-macAddrStep) $argArray(-mac_address_step)
    }

    ##step 6
    set devicelist ""
    if {[string equal -nocase "create" $argArray(-mode)] && ![info exist argArray(-handle)] && ![info exist argArray(-intf_ip_addr)]} {
        if {[info exist argArray(-port_handle)]} {
	    set devicelist [::sth::sthCore::invoke stc::get $argArray(-port_handle) -affiliationport-Sources]
	        if {$devicelist != ""} {
                array unset argArray -port_handle
                set argArray(-handle) [lindex $devicelist 0]
            }
        } else {
             set argArray(-intf_ip_addr) $tempArray(-intfIpAddr)
        }
    }
    if {[string equal -nocase "create" $argArray(-mode)] || [string equal -nocase "enable" $argArray(-mode)]} {
        if {[info exist argArray(-handle)]} {
                set handleInArgs $argArray(-handle)
                set tempArray(-count) [llength $handleInArgs]
                set argArray(-count) 1
        } elseif {[info exist argArray(-count)]} {
            set tempArray(-count) $argArray(-count)
            set argArray(-count) 1
        }
    }
    if {[info exist argArray(-port_handle)] && [info exist argArray(-handle)]} {
        unset argArray(-port_handle)
    }

    ##enter loop
    for {set i 0} {$i<$tempArray(-count)} {incr i} {
        ##_## Adding code for incrementing vlanid - 2015-03-27
        if {$i > 0} {
            if {[info exist argArray(-vlan_id)] && [info exist argArray(-vlan_id_mode)] && [string equal -nocase "increment" $argArray(-vlan_id_mode)]} {
                if {[info exist argArray(-vlan_id_step)]} {
                    set argArray(-vlan_id) [expr $argArray(-vlan_id) + $argArray(-vlan_id_step)]	
                } else {
                    set argArray(-vlan_id) [expr $argArray(-vlan_id) + 1]
                }
            }
        }
        ##get correct mac_address

        if {![info exist argArray(-mac_address_start)]} {
            if {[info exist argArray(-intf_ip_addr)]} {
                set tempArray(-intfIpAddr) $argArray(-intf_ip_addr)
            }
            if {"" != [info procs ::ip_to_mac]} {
                set tempArray(-macAddr) [::ip_to_mac $tempArray(-intfIpAddr)]
            } else {
                set tempArray(-macAddr) [::wrapper::ip_to_mac $tempArray(-intfIpAddr) "."]
            }
            if {[regexp -nocase $tempArray(-macAddr) $::spirent::MacList]} {
                set tempArray(-macAddr) [::sth::sthCore::macStep $tempArray(-macAddr) "00:00:00:00:00:01" [expr $i + 1]]
            }
            lappend ::spirent::MacList $tempArray(-macAddr)
            
            set argArray(-mac_address_start) $tempArray(-macAddr)

        }
        set ospfExist 0
        if {"" != $handleInArgs} {
            #array unset argArray -mac_address_start
            set argArray(-handle) [lindex $handleInArgs $i]

            if {$::sth::ospfTopology::currentOSPFVersion == $::sth::ospfTopology::OSPFV3_STR} {
                if {"" != [set ospfH [stc::get $argArray(-handle) -children-ospfv3routerconfig]]} {
                    set ospfExist 1
                    if {[string equal -nocase "create" $argArray(-mode)]} {
                        ::sth::sthCore::invoke stc::delete $ospfH
                    }
                }
                ##ospf_config HLTAPI gets wrong -gateway_ip_addr, so set it manually here
                set argArray(-gateway_ip_addr) [::sth::sthCore::invoke \
                            stc::get [lindex [::sth::sthCore::invoke \
                            stc::get $argArray(-handle) -children-ipv6if] 0] -Gateway]
                ##from out of loop
            } else {
                if {"" != [set ospfH [stc::get $argArray(-handle) -children-ospfv2routerconfig]]} {
                    set ospfExist 1
                    if {[string equal -nocase "create" $argArray(-mode)]} {
                        ::sth::sthCore::invoke stc::delete $ospfH
                    }
                }
                ##ospf_config HLTAPI gets wrong -gateway_ip_addr, so set it manually here
                set argArray(-gateway_ip_addr) [::sth::sthCore::invoke \
                            stc::get [lindex [::sth::sthCore::invoke \
                            stc::get $argArray(-handle) -children-ipv4if] 0] -Gateway]
                ##from out of loop
            }
            if {[string equal -nocase "enable" $argArray(-mode)] && !$ospfExist} {
                set argArray(-mode) "create"
            }
        } else {
            ##entrance condition: there is no -handle in args
            if {[info exist argArray(-port_handle)] && [info exist argArray(-intf_ip_addr)]} {
                set device [::wrapper::get_device_with_ip_new $argArray(-intf_ip_addr) $argArray(-port_handle)]
                if {"" != $device} {
                    set argArray(-handle) $device
                    set tempArray(-portHandle) $argArray(-port_handle)
                    unset argArray(-port_handle)
                    #array unset argArray -mac_address_start
                    if {$::sth::ospfTopology::currentOSPFVersion == $::sth::ospfTopology::OSPFV3_STR} {
                        if {"" != [set ospfH [stc::get $argArray(-handle) -children-ospfv3routerconfig]]} {
                            ::sth::sthCore::invoke stc::delete $ospfH
                        }                    
                    } else {
                        if {"" != [set ospfH [stc::get $argArray(-handle) -children-ospfv2routerconfig]]} {
                            ::sth::sthCore::invoke stc::delete $ospfH
                        }
                    }
                }
            }
        } ;#interface handle over

        ##execute sth::ospf_config
        if {[string equal -nocase "create" $argArray(-mode)]} {
            set args [array get argArray]
            set cmdName "sth::emulation_ospf_config $args"
            set tempResult [::spirent::process_cmd $cmdName]
            if {0 == [keylget tempResult status]} {
                keylset result log [keylget tempResult log]
                return $result
            }
            if {[info exist argArray(-intf_ip_addr)]} {
                set intf_ip_addr $argArray(-intf_ip_addr)
                if {[::ip::is ipv6 $intf_ip_addr]} {
                    set intf_ip_addr [::sth::sthCore::normalizeIPv6Addr $intf_ip_addr]
                }              
                set ::spirent::ip_device($intf_ip_addr) [keylget tempResult handle]
            } elseif {[info exist argArray(-local_ipv6_addr)]} {
                set local_ipv6_addr [::sth::sthCore::normalizeIPv6Addr $argArray(-local_ipv6_addr)]
                set ::spirent::ip_device($local_ipv6_addr) [keylget tempResult handle]
            }
            keylset result handle [concat [keylget result handle] [keylget tempResult handle]]
            keylset result session_router [concat [keylget result session_router] [keylget tempResult session_router]]
        }
        if {[string equal -nocase "enable" $argArray(-mode)] && $ospfExist} {
  
            keylset result handle [concat [keylget result handle] $argArray(-handle)]
            keylset result session_router [concat [keylget result session_router] $ospfH]
        }
        
        if {![string equal -nocase "delete" $argArray(-mode)] && ![string equal -nocase "enable" $argArray(-mode)]} {
            set ospfHandle [lindex [keylget tempResult session_router] 0]
            if {[info exist argArray(-router_id)]} {
                ::sth::sthCore::invoke stc::config [::sth::sthCore::invoke stc::get $ospfHandle -parent] -routerid $argArray(-router_id)
            }
            ##advertise route for router_id, only for OSPFv2
            ::sth::ospfTopology::CreateDefaultLSA $ospfHandle
            ##-port_handle was cut when interface handle which would be created by ospf_config was the same as one of them which created by interface_config
            ##here add -port_handle to argArray
            if {[info exist tempArray(-portHandle)]} {
                set argArray(-port_handle) $tempArray(-portHandle)
                unset argArray(-handle)
                unset tempArray(-portHandle)
            }
    
            ##set values for next time
            if {[info exist argArray(-intf_ip_addr)]} {
                if {[regexp -- {:} $argArray(-intf_ip_addr)]} {
                    set argArray(-intf_ip_addr) [::sth::sthCore::updateIpAddress 6 $argArray(-intf_ip_addr) $tempArray(-intfIpAddrStep6) 1]
                } else {
                    set argArray(-intf_ip_addr) [::sth::sthCore::updateIpAddress 4 $argArray(-intf_ip_addr) $tempArray(-intfIpAddrStep4) 1]
                }
            }
            if {[info exist argArray(-router_id)]} {
                set argArray(-router_id) [::sth::sthCore::updateIpAddress 4 $argArray(-router_id) $tempArray(-routerIdStep) 1]
            }
            if {[info exist argArray(-area_id)]} {
                set argArray(-area_id) [::sth::sthCore::updateIpAddress 4 $argArray(-area_id) $tempArray(-areaIdStep) 1]
            }
            if {[info exist argArray(-gateway_ip_addr)]} {
                if {[regexp -- {:} $argArray(-gateway_ip_addr)]} {
                    set argArray(-gateway_ip_addr) [::sth::sthCore::updateIpAddress 6 $argArray(-gateway_ip_addr) $tempArray(-gwIpAddrStep6) 1]
                } else {
                    set argArray(-gateway_ip_addr) [::sth::sthCore::updateIpAddress 4 $argArray(-gateway_ip_addr) $tempArray(-gwIpAddrStep4) 1]
                }
            }
            if {"" != $tempArray(-macAddrStep)} {
                set argArray(-mac_address_start) [::wrapper::incrMacAddress \
                        [::wrapper::macAddressToStcFormat $argArray(-mac_address_start)] \
                        [::wrapper::macAddressToStcFormat $tempArray(-macAddrStep)]]
            } else {
                array unset argArray -mac_address_start
            }
        } else {
                array unset argArray -mac_address_start
        }
        
    } ;#loop over
    keylset result handles [keylget result handle]
    set return_list $result
    return $result
}

proc ::spirent::emulation_ospf_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set cmdName "sth::emulation_ospf_control $args"
    set retVal [::spirent::process_cmd $cmdName]
    keylset retVal seconds "N/A"
    keylset retVal clicks "N/A"
    return $retVal
}

proc ::spirent::emulation_ospf_topology_route_config {args} {
################################################################################
##
## step 1: set variables
## step 2: if there is "-" in args value, replace it by "_"
## step 3: shield/convert
## step 4: convert args vlaues to STC style
## step 5: set "step" values
## step 6: set manual variables values
##
################################################################################
    ######convert physical port
    global return_list
    array set argArray {}
    set args [eval ::spirent::port_converter $args]
    ::spirent::listToArray $args argArray
	if {[info exist argArray(-summary_prefix_metric)]} {
		if {$argArray(-summary_prefix_metric) < 1} {
			unset argArray(-summary_prefix_metric)
		}
	}
    if {[info exist argArray(-summary_prefix_step)] && [regexp {\.} $argArray(-summary_prefix_step)]} {
        set tmplst [split $argArray(-summary_prefix_step) .]
        if {[llength $tmplst] == 4} {
            set argArray(-summary_prefix_step) [expr (256*[lindex $tmplst 2]) + [lindex $tmplst 3]]
            if {$argArray(-summary_prefix_step) > 66535} {unset argArray(-summary_prefix_step)}
        }
    }
    if {[info exist argArray(-external_prefix_step)] && $argArray(-external_prefix_step) ==  "0:0:0:0:0:0:0:1"} {
        set argArray(-external_prefix_step) 1
    }
    set args [array get argArray]
    set args [wrapper::shield_args -total $args -unsupported "grid_te interface_ip_address interface_ip_mask enable_advertise count"]
    set cmdName "sth::emulation_ospf_topology_route_config $args"
    set result [::spirent::process_cmd $cmdName]

    ::spirent::listToArray $args argArray
    if {[string equal -nocase "create" $argArray(-mode)]} {
        set routerId [stc::get $argArray(-handle) -RouterId]
        ##TODO: only for OSPFV2
        catch {
            set tempList {}
            set routerConfig [stc::get $argArray(-handle) -children-ospfv2routerconfig]
            foreach eachHandle [stc::get $routerConfig -children-routerlsa] {
                set routeAdvertised [::sth::sthCore::invoke stc::get $eachHandle -AdvertisingRouterId]
                if {[string equal -nocase $routerId $routeAdvertised]} {
                    lappend tempList $eachHandle
                }
            }
            if {2 == [llength $tempList]} {
                set elemHandle [lindex $tempList 0]
                set cmdName "sth::emulation_ospf_topology_route_config -handle $argArray(-handle) -mode delete -type router -elem_handle $elemHandle"
                ::spirent::process_cmd $cmdName
            }
        }
    }
    set return_list $result
    return $result
}

proc ::spirent::traffic_control {args} {
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    #set processed_args $args
    #disable calculate ElapsedTime to speed up script
#    set ::sth::Traffic::processElapsedTime 0
    variable enable_debug_database
    variable qos_statistics             ;# Added by MGJ.
    set ixia_only_args "traffic_generator max_wait_timer packet_loss_duration_enable cpdp_convergence_enable delay_variation_enable latency_control"
    set processed_args [wrapper::shield_args -total $args -unsupported $ixia_only_args]
    array set argArray {}
    ::spirent::listToArray $processed_args argArray
    if {[info exist argArray(-profile_handle)]} {
        set argArray(-stream_handle) $argArray(-profile_handle)
        unset argArray(-profile_handle)
    }
    set processed_args [array get argArray]

    #check the DurationMode of the generator, if it is seconds, config the -duration in run action, or else, the DurationMode will be changed to bursts
    if {[lsearch $processed_args "-port_handle"] > -1} {
      
        set  port_hdl_list $argArray(-port_handle)
        set port_hdl_list [lsort -unique $port_hdl_list]
        foreach port_hdl $port_hdl_list {
            set gene [::sth::sthCore::invoke stc::get $port_hdl -children-generator]
            set gene_cfg [::sth::sthCore::invoke stc::get $gene -children-generatorconfig]
            set duration_mode [::sth::sthCore::invoke stc::get $gene_cfg -DurationMode]
            if {[regexp -nocase "seconds" $duration_mode]} {
                set duration_value [::sth::sthCore::invoke stc::get $gene_cfg -duration]
                break
            }
#           if {[regexp -nocase "burst" $duration_mode]} {
#               set duration_indx [lsearch $processed_args "-duration"]
#               if {$duration_indx > -1} {
#                   set processed_args [lreplace $processed_args $duration_indx [expr $duration_indx + 1]]
#               }
#               break
#           }
        }
    } else {
        set processed_args "$processed_args -port_handle all"
    }

    if {[lsearch $processed_args "-elapsed_time"] < 0} {
        set ::sth::Traffic::processElapsedTime 0
    }

    if {[lsearch $processed_args "-action"] > -1} {
        
        set  action_value_list $argArray(-action)
        set action_length [llength $action_value_list]
        if ($action_length==1) {
            set value $action_value_list
            if {"clear_stats" eq $value} {
                if {([lsearch $processed_args "-port_handle"] > -1) && ([lsearch $processed_args "-stream_handle"] == -1)} {
                    set processed_args [wrapper::shield_args -total $processed_args -unsupported "port_handle"]
                    set processed_args "$processed_args -port_handle all"
                }
                if {([lsearch $processed_args "-port_handle"] == -1) && ([lsearch $processed_args "-stream_handle"] == -1)} {
                    set processed_args "$processed_args -port_handle all"
                }
                set processed_args [wrapper::shield_args -total $processed_args -unsupported latency_bins]
                set cmdName "::sth::traffic_control $processed_args"
                set retVal [::spirent::process_cmd $cmdName]
            }
            if {"run" eq $value} {
                set ::spirent::call_stop 1
                set porthdl_index [expr [lsearch $processed_args "-port_handle"] + 1]
                set porthdl [lindex $processed_args $porthdl_index]
                set cmdName "::sth::traffic_control -port_handle $porthdl -action clear_stats"
                ::spirent::process_cmd $cmdName
                # MGJ: Add a filter for QoS statistics.
                if { $qos_statistics } {
                    lappend processed_args "-get"  "tos"
                }
                # End MGJ mod.
                ::sth::sthCore::invoke stc::config system1.project.trafficoptions -TrafficStartMode "ASYNCHRONOUS"
                set cmdName "::sth::traffic_control $processed_args"
                set retVal [::spirent::process_cmd $cmdName]
            }
            if {"stop" eq $value} {
                if {[info exists duration_value]} {
                   set ::spirent::call_stop 0
                } elseif {[lsearch $processed_args "-db_file"]<0} {
                    if {$enable_debug_database} {
                        set db_file 1
                    } else {
                        set db_file 0
                    }
                     lappend processed_args "-db_file"  $db_file
                }
                set cmdName "::sth::traffic_control $processed_args"
                set retVal [::spirent::process_cmd $cmdName]
            }
            if {"sync_run" eq $value} {
                #call clear_stats at first
                if {[lsearch $processed_args "-port_handle"] > -1} {
                    set cmdName "::sth::traffic_control -port_handle $port_hdl_list -action clear_stats"
                    ::spirent::process_cmd $cmdName
                }
                regsub -all sync_run  $processed_args run processed_args
                
                # Set all ports to start sending at the same time.
                ::sth::sthCore::invoke stc::config system1.project.trafficoptions -TrafficStartMode "SYNCHRONOUS"
                set cmdName "::sth::traffic_control $processed_args"
                set retVal [::spirent::process_cmd $cmdName]
            }
            if {"reset" eq $value} {
                if {[lsearch $args "-port_handle"] > -1} {
                    set port_handle_index [expr [lsearch $args "-port_handle"] + 1]
                    set port_handle [lindex $args $port_handle_index]
                    foreach port_hdl $port_handle {
                        set generator [::sth::sthCore::invoke stc::get $port_hdl -children-generator]
                        set generatorcfg [::sth::sthCore::invoke stc::get $generator -children-generatorconfig]
                        ::sth::sthCore::invoke stc::config $generatorcfg -duration 1 -SchedulingMode rate_based
                    }
                }
                set cmdName "::sth::traffic_control $processed_args"
                set retVal [::spirent::process_cmd $cmdName]
            }
        } else {
            if {[lsearch $processed_args "-port_handle"] > -1} {
                set  port_hdl_list $argArray(-port_handle)
            }
            set index 0
            foreach value $action_value_list {
                if {"clear_stats" eq $value} {
                    set processed_args [wrapper::shield_args -total $processed_args -unsupported latency_bins]
                    set port_handle [lindex $port_hdl_list $index]
                    set argArray(-port_handle) $port_handle
                    set action [lindex $action_value_list $index]
                    set argArray(-action) $action
                    set processed_args [array get argArray]
                    set cmdName "::sth::traffic_control $processed_args"
                    set retVal [::spirent::process_cmd $cmdName]
                }
                if {"run" eq $value} {
                    set ::spirent::call_stop 1
                    set porthdl [lindex $port_hdl_list $index]
                    set cmdName "::sth::traffic_control -port_handle $porthdl -action clear_stats"
                    ::spirent::process_cmd $cmdName
                    # MGJ: Add a filter for QoS statistics.
                    if { $qos_statistics } {
                       lappend processed_args "-get"  "tos"
                    }
                    # End MGJ mod.
                    ::sth::sthCore::invoke stc::config system1.project.trafficoptions -TrafficStartMode "ASYNCHRONOUS"
                    set port_handle [lindex $port_hdl_list $index]
                    set argArray(-port_handle) $port_handle
                    set action [lindex $action_value_list $index]
                    set argArray(-action) $action
                    set processed_args [array get argArray]
                    set cmdName "::sth::traffic_control $processed_args"
                    set retVal [::spirent::process_cmd $cmdName]
                }
                if {"stop" eq $value} {
                    if {[info exists duration_value]} {
                       set ::spirent::call_stop 0
                    } elseif {[lsearch $processed_args "-db_file"]<0} {
                        if {$enable_debug_database} {
                            set db_file 1
                        } else {
                            set db_file 0
                        }
                        lappend processed_args "-db_file"  $db_file
                    }
                    set port_handle [lindex $port_hdl_list $index]
                    set argArray(-port_handle) $port_handle
                    set action [lindex $action_value_list $index]
                    set argArray(-action) $action
                    set processed_args [array get argArray]
                    set cmdName "::sth::traffic_control $processed_args"
                    set retVal [::spirent::process_cmd $cmdName]
                }
                if {"sync_run" eq $value} {
                    #call clear_stats at first
                    if {[lsearch $processed_args "-port_handle"] > -1} {
                        set porthdl [lindex $port_hdl_list $index]
                        set cmdName "::sth::traffic_control -port_handle $porthdl -action clear_stats"
                        ::spirent::process_cmd $cmdName
                    }
                    #regsub -all sync_run  $processed_args run processed_args
                    # Set all ports to start sending at the same time.
                    ::sth::sthCore::invoke stc::config system1.project.trafficoptions -TrafficStartMode "SYNCHRONOUS"
                    set port_handle [lindex $port_hdl_list $index]
                    set argArray(-port_handle) $port_handle
                    set action_value_list [lreplace $action_value_list $index $index "run"]
                    set action [lindex $action_value_list $index]
                    set argArray(-action) $action
                    set processed_args [array get argArray]
                    set cmdName "::sth::traffic_control $processed_args"
                    set retVal [::spirent::process_cmd $cmdName]
                }
                if {"reset" eq $value} {
                    if {[lsearch $args "-port_handle"] > -1} {
                        set port_hdl [lindex $port_hdl_list $index]
                        set generator [::sth::sthCore::invoke stc::get $port_hdl -children-generator]
                        set generatorcfg [::sth::sthCore::invoke stc::get $generator -children-generatorconfig]
                        ::sth::sthCore::invoke stc::config $generatorcfg -duration 1 -SchedulingMode rate_based
                    }
                    set cmdName "::sth::traffic_control $processed_args"
                    set retVal [::spirent::process_cmd $cmdName]
                }
                incr index
            }
            
        }
    }

    #set cmdName "::sth::traffic_control $processed_args"
    #set retVal [::spirent::process_cmd $cmdName]
    keylset retVal seconds "N/A"
    keylset retVal clicks "N/A"

    if {[lsearch $processed_args "-action"] > -1} {
        set index [expr [lsearch $processed_args "-action"] + 1]
        set value [lindex $processed_args $index]
        if {"run" eq $value} {
            keylset retVal stopped 0
        }
        if {"stop" eq $value} {
            keylset retVal stopped 1
        }
        if {"poll" eq $value} {
            keylset retVal stopped 1
	    keylset retVal status 1
            if [regexp RUNNING $retVal] {
                keylset retVal stopped 0
		keylset retVal status 0
            }
        }
    }

    return $retVal

}

proc ::ixia::traffic_stats {args} {
    return [::spirent::traffic_stats_common $args ixia]
}
proc ::AgtTest::traffic_stats {args} {
    return [::spirent::traffic_stats_common $args AgtTest]
}
proc ::spirent::traffic_stats_common {args calledBy} {
    #disable calculate ElapsedTime to speed up script
    set ::sth::Traffic::processElapsedTime 0
    # Determine the parent namespace. This will help us decide which format to return the results in.
    set parentnamespace ""
    set procedure       [info level 1]
    regexp -nocase {:*([a-z]+)::} $procedure -> parentnamespace
    #need replace -stream by -streams
    #need replace -mode stream by -mode streams
    set ixia_only_args "field_type packet_group_id traffic_generator"
    set streamlist_update ""
    ######convert physical port
    set args_ori $args
    set args [wrapper::shield_args -total $args -unsupported "display_mode"]
    set args [eval ::spirent::port_converter $args]
    set packet_group_id ""
    if {[lsearch $args "-packet_group_id"] > -1} {
        set index [expr [lsearch $args "-packet_group_id"] + 1]
        set packet_group_id [lindex $args $index]
        if {[lsearch $args "-mode"] <0} {
            lappend  args "-mode"  "aggregate"
        }
    }
    if {[lsearch $args "-port_handle"] > -1} {
        set port_handle [::wrapper::get_value_list $args "-port_handle"]
    }

    #check if the stop action needs to call before getting results
    if {$::spirent::call_stop == 1} {
        #check if the generator stops

        #if only stream handles are input, get the porthandle from stream handle
        if {![info exists port_handle] && [lsearch $args "-stream"] > -1} {
            set port_handle ""
            set stream_update ""
            set streamlist [::wrapper::get_value_list $args "-stream"]
            foreach streamhdl $streamlist {
                if {[string is integer $streamhdl]} {
                    lappend stream_update streamblock$streamhdl
                } else {
                    lappend stream_update $streamhdl
                }
            }
            foreach stream $stream_update {
                set curr_port [::sth::sthCore::invoke stc::get $stream -parent]
                if {[lsearch $port_handle $curr_port] < 0} {
                    set port_handle [concat $port_handle $curr_port]
                }
            }
        }
        if {[info exists port_handle]} {
        set stop_flag 1
            set port_handle_all [::sth::sthCore::invoke stc::get project1 -children-port]
            foreach port $port_handle_all {
                set generator [::sth::sthCore::invoke stc::get $port -children-generator]
                set generator_state [::sth::sthCore::invoke stc::get $generator -State]
                if {![regexp -nocase "STOPPED" $generator_state]} {
                    set stop_flag 0
                    break
                }
            }
            if {$stop_flag == 1} {
                set controlCmd "::sth::traffic_control -action stop -port_handle all"
                ::spirent::process_cmd $controlCmd
                set ::spirent::call_stop 0
            }
        }
    }


    array set spirent_mandatory_arg_array "mode all"
    set processed_args [wrapper::shield_args -total $args -unsupported $ixia_only_args]

    array set ixia_spirent_arg_array "stream streams"
    set processed_args [wrapper::convert_args -total $processed_args -unsupported ixia_spirent_arg_array]
    set processed_args [wrapper::add_mandatory_args -total $processed_args -mandatory spirent_mandatory_arg_array]
    set aggregate_tag 0
    set traffic_item_flag 0
    set igmp_stream_flag 0
    if {[lsearch $processed_args "-mode"] > -1} {
        set index [expr [lsearch $processed_args "-mode"] + 1]
        set value [lindex $processed_args $index]
        if {"stream" eq $value} {
            set processed_args [lreplace $processed_args $index $index "streams"]
        }
        if {"traffic_item" eq $value  && $streamblk_count > 1 } {
            set processed_args [lreplace $processed_args $index $index "streams"]
            set traffic_item_flag 1
            set igmp_stream_flag 1
        }
        if {[regexp "aggregate|all" $value]} {
            set aggregate_tag 1
        }
    }
    ########################################################
    #if customer dose not give the rx_port_handle, then give it here,
    #to make sure the rx stream result not inlcude result on the port_handle of this stream.
    ##########################################################

    if {[lsearch $processed_args "-rx_port_handle"] < 0} {
       set processed_args [concat $processed_args "-rx_port_handle all"]
    }

    #set detailed_rx_stats 1 to get the rx stream stats per port
    set mode [lindex $processed_args [expr [lsearch $processed_args "-mode"] + 1]]
    if {[lsearch $processed_args "-detailed_rx_stats"] < 0 && $mode != "all"} {
       set processed_args [concat $processed_args "-detailed_rx_stats 1"]
    }


    if {[lsearch $processed_args "-mode"] > -1} {
        set mode_value [lindex $processed_args [expr [lsearch $processed_args "-mode"] +1]]
        if {[string match -nocase $mode_value "streams"]||[string match -nocase $mode_value "all"]} {
            if {[lsearch $processed_args "-streams"]<0} {
                set port_handle_all [::sth::sthCore::invoke stc::get project1 -children-port]
                foreach hPort $port_handle_all {
                    foreach myStreamblock [::sth::sthCore::invoke stc::get $hPort -children-streamblock] {
                        if [::sth::sthCore::invoke stc::get $myStreamblock -Active] {
                            lappend streamlist_update  $myStreamblock
                        }
                    }
                }
                set streamlist_update [lsort -unique $streamlist_update]
		if {$streamlist_update ne ""} {
		    set processed_args [concat $processed_args "-streams" $streamlist_update]
		}
            } else {
                #set next_index 0
                set streamlist [::wrapper::get_value_list $processed_args "-streams"]
                foreach streamhdl $streamlist {
                    if {[string is integer $streamhdl]} {
                        #add the streamblock before the integer
                        lappend streamlist_update streamblock$streamhdl
                    }
                }
                if {$streamlist_update != ""} {
                    #set stream_end   [expr $next_index - 1]
                    set stream_index  [lsearch $processed_args "-streams"]
                    set stream_length [llength $streamlist_update]
                    set processed_args [lreplace $processed_args [expr $stream_index + 1] [expr $stream_index + $stream_length] $streamlist_update]
                }
            }
        }
    }
    set cmdName "::wrapper::traffic_stats $processed_args"
    set stats_ret [::spirent::process_cmd $cmdName]
    
    ##for drv stats, if all streamblock are not active , like bound DHCP/PPPoE, will be NONE
    ##Here record sth::traffic_stats, will not happen for 99% case
    if {[llength [keylkeys stats_ret]] <= 1} {
        puts "Warning: There is no avaiable streamblock with ready endpoints!"
        set cmdName "::sth::traffic_stats $processed_args"
        set stats_ret [::spirent::process_cmd $cmdName]
    }
    
    if {($packet_group_id ne "")} {
        set frame_rate ""
        set max_latency ""
        set bit_rate ""
        set min_latency ""
        set avg_latency ""
        set pkt_count ""
        set last_timestamp ""
        set first_timestamp ""
        set RxTrafficGroupResultsData [::sth::sthCore::invoke stc::subscribe -parent project1 -configType TrafficGroup -resultType RxTrafficGroupResults]
        set group_collection_all [::sth::sthCore::invoke stc::get project1 -children-GroupCollection]
        foreach group_collection $group_collection_all {
            set group_name  [::sth::sthCore::invoke stc::get $group_collection -GroupName]
            if {$group_name<=$packet_group_id} {
                set traffic_group_all [::sth::sthCore::invoke stc::get $group_collection -children-TrafficGroup]
                foreach traffic_group $traffic_group_all {
                    set traffic_name  [::sth::sthCore::invoke stc::get $traffic_group -GroupName]
                    if {$traffic_name<=$packet_group_id} {
                        set rxTrafficGroupResults [::sth::sthCore::invoke stc::get $traffic_group -children-RxTrafficGroupResults]
                        set RxTrafficGroupResults [lindex $rxTrafficGroupResults end]
                        lappend frame_rate       $traffic_name  [::sth::sthCore::invoke stc::get $RxTrafficGroupResults -FrameRate]
                        lappend max_latency      $traffic_name  [::sth::sthCore::invoke stc::get $RxTrafficGroupResults -MaxLatency]
                        lappend bit_rate         $traffic_name  [::sth::sthCore::invoke stc::get $RxTrafficGroupResults -BitRate]
                        lappend min_latency      $traffic_name  [::sth::sthCore::invoke stc::get $RxTrafficGroupResults -MinLatency]
                        lappend avg_latency      $traffic_name  [::sth::sthCore::invoke stc::get $RxTrafficGroupResults -AvgLatency]
                        lappend pkt_count        $traffic_name  [::sth::sthCore::invoke stc::get $RxTrafficGroupResults -SigFrameCount]
                        lappend last_timestamp   $traffic_name  [::sth::sthCore::invoke stc::get $RxTrafficGroupResults -LastArrivalTime]
                        lappend first_timestamp  $traffic_name  [::sth::sthCore::invoke stc::get $RxTrafficGroupResults -FirstArrivalTime]
                        
                    } else {
                        continue
                    }
                }
            } else {
                continue
            }
        }
        ::sth::sthCore::invoke stc::unsubscribe $RxTrafficGroupResultsData
        array set Frame_rate $frame_rate 
        array set Max_latency $max_latency 
        array set Bit_rate $bit_rate
        array set Min_latency  $min_latency 
        array set Avg_latency $avg_latency 
        array set Pkt_count  $pkt_count 
        array set Last_timestamp   $last_timestamp 
        array set First_timestamp  $first_timestamp
        
        set port_ret [keylkeys stats_ret]
        foreach port $port_ret {
            if {[regexp -nocase "port" $port]} {
                set frame_name [array names Frame_rate]
                set pgid_1 ""
                foreach  id  $frame_name {
                    keylset stats_ret $port.pgid.rx.frame_rate   [lappend pgid_1 "$id $Frame_rate($id)"]
                }
                set pgid_2 ""
                set max_name [array names Max_latency]
                foreach  id  $max_name {
                    keylset stats_ret $port.pgid.rx.max_latency   [lappend pgid_2 "$id $Max_latency($id)"]
                }
                set pgid_3 ""
                set bit_name [array names Bit_rate]
                foreach  id  $bit_name {
                    keylset stats_ret $port.pgid.rx.bit_rate   [lappend pgid_3 "$id $Bit_rate($id)"]
                }
                set pgid_4 ""
                set min_name [array names Min_latency]
                foreach  id  $bit_name {
                    keylset stats_ret $port.pgid.rx.min_latency   [lappend pgid_4 "$id $Min_latency($id)"]
                }
                set pgid_5 ""
                set avg_name [array names Avg_latency]
                foreach  id  $avg_name {
                    keylset stats_ret $port.pgid.rx.avg_latency   [lappend pgid_5 "$id $Avg_latency($id)"]
                }
                set pgid_6 ""
                set pkt_name [array names Pkt_count]
                foreach  id  $pkt_name {
                   keylset stats_ret $port.pgid.rx.pkt_count   [lappend pgid_6 "$id $Pkt_count($id)"]
                }
                set i 7
                set pgid_$i ""
                set last_name [array names Last_timestamp]
                foreach  id  $last_name {
                    keylset stats_ret $port.$id   [lappend pgid_$i "last_timestamp $Last_timestamp($id)" "first_timestamp $First_timestamp($id)"]
                    incr i
                }
                    
            }
        }
    }
    
    #if the mode is aggregate, add oversize_count (oversize means the packet is greater than 1518bytes) in returned keyedlist,
    #stc doesn't provide this, and analysed from gre_l3vpn_6vpe.tcl, this count can be mapped to pkts_count
    if {[regexp -nocase "aggregate" $stats_ret] > 0} {
        set port_ret [keylkeys stats_ret]
        foreach port $port_ret {
            if {[regexp -nocase "port" $port]} {
                if {![catch {keylget stats_ret $port.aggregate.rx.pkt_count} errMsg]} {
                    set pkt_count [keylget stats_ret $port.aggregate.rx.pkt_count]
                    keylset stats_ret $port.aggregate.rx.oversize_count [keylget stats_ret $port.aggregate.rx.pkt_count]
                    keylset stats_ret $port.aggregate.rx.test_pkts [keylget stats_ret $port.aggregate.rx.pkt_count]
                    keylset stats_ret $port.aggregate.rx.data_int_frames_count [keylget stats_ret $port.aggregate.rx.pkt_count]
                }
                if {![catch {keylget stats_ret $port.aggregate.rx.total_pkts} errMsg]} {
                    set total_pkts [keylget stats_ret $port.aggregate.rx.total_pkts]
                    keylset stats_ret $port.aggregate.rx.non_test_pkts        [expr $total_pkts - $pkt_count]
                }
                if {![catch {keylget stats_ret $port.aggregate.rx.total_pkt_bytes} errMsg]} {
                    set total_pkt_bytes [keylget stats_ret $port.aggregate.rx.total_pkt_bytes]
                    keylset stats_ret $port.aggregate.rx.total_bytes          $total_pkt_bytes
                    if {![catch {keylget stats_ret $port.aggregate.rx.pkt_byte_count} errMsg]} {
                        set pkt_byte_count [keylget stats_ret $port.aggregate.rx.pkt_byte_count]
                        keylset stats_ret $port.aggregate.rx.non_test_bytes  [expr $total_pkt_bytes - $pkt_byte_count]
                        keylset stats_ret $port.aggregate.rx.test_bytes           $pkt_byte_count
                    }
                }
                if {![catch {keylget stats_ret $port.aggregate.rx.total_pkt_rate} errMsg]} {
                    set total_pkt_rate [keylget stats_ret $port.aggregate.rx.total_pkt_rate]
                    if {![catch {keylget stats_ret $port.aggregate.rx.pkt_rate} errMsg]} {
                        set pkt_rate [keylget stats_ret $port.aggregate.rx.pkt_rate]
                        keylset stats_ret $port.aggregate.rx.non_test_rate  [expr $total_pkt_rate - $pkt_rate]
                        keylset stats_ret $port.aggregate.rx.test_rate            $pkt_rate
                        keylset stats_ret $port.aggregate.rx.raw_pkt_rate           $total_pkt_rate
                    }
                }


                if {![catch {keylget stats_ret $port.aggregate.rx.pkt_bit_rate} errMsg]} {
                    set pkt_bit_rate [keylget stats_ret $port.aggregate.rx.pkt_bit_rate]
                    keylset stats_ret $port.aggregate.rx.test_bit_rate        $pkt_bit_rate
                }
                if {![catch {keylget stats_ret $port.aggregate.rx.pkt_bit_rate} errMsg]} {
                    set pkt_bit_rate [keylget stats_ret $port.aggregate.rx.pkt_bit_rate]
                    set pkt_mbit_rate [expr $pkt_bit_rate/1000000]
                    keylset stats_ret $port.aggregate.rx.pkt_mbit_rate        $pkt_mbit_rate
                }
                keylset stats_ret $port.aggregate.rx.pkt_error_rate        "null"
                keylset stats_ret $port.aggregate.rx.non_test_bit_rate     "null"
                keylset stats_ret $port.aggregate.rx.total_bit_rate        "null"
                keylset stats_ret $port.aggregate.rx.min_delay             "null"
                keylset stats_ret $port.aggregate.rx.integrity_errors      "null"
                keylset stats_ret $port.aggregate.rx.max_delay             "null"
                keylset stats_ret $port.aggregate.rx.avg_delay             "null"
                keylset stats_ret $port.aggregate.rx.ip_checksum_errors    "null"
                keylset stats_ret $port.aggregate.rx.ip_fragment_detected  "null"
                keylset stats_ret $port.aggregate.rx.misdirected_pkts      "null"
                keylset stats_ret $port.aggregate.rx.collisions_count      "null" 
                keylset stats_ret $port.aggregate.rx.dribble_errors_count  "null" 
                # Number of under sized frames received. Used in the end of test result database.You cannot subscribe to this object to get results.
                # The meaning is opposite of oversize_count. Temporarily set it to null
                keylset stats_ret $port.aggregate.rx.undersize_count       "null"
                # the GeneratorPortResults exist the attribute (GeneratorCrcErrorFrameCount),but the hlatapi set GeneratorPortResults is tx not rx. just set null.
                keylset stats_ret $port.aggregate.rx.crc_errors_count      "null"
                
                keylset stats_ret $port.aggregate.rx.sequence_errors_count  0   
                keylset stats_ret $port.aggregate.rx.duplicate_pkts         0   
                keylset stats_ret $port.aggregate.rx.dropped_pkts           0     
                keylset stats_ret $port.aggregate.rx.late_pkts              0   
                foreach myStreamblock [::sth::sthCore::invoke stc::get $port -children-streamblock] {
                    if [::sth::sthCore::invoke stc::get $myStreamblock -Active] {
                            lappend streamlist_update  $myStreamblock
                    }
                }
                
                if {![catch {keylget stats_ret $port.aggregate.tx.pkt_bit_rate} errMsg]} {
                    set pkt_bit_rate [keylget stats_ret $port.aggregate.tx.pkt_bit_rate]
                    set pkt_mbit_rate [expr $pkt_bit_rate/1000000]
                    keylset stats_ret $port.aggregate.tx.pkt_mbit_rate        $pkt_mbit_rate
                }

                if {![catch {keylget stats_ret $port.aggregate.tx.pkt_count} errMsg]} {
                    set  pkt_count [keylget stats_ret $port.aggregate.tx.pkt_count]
                    keylset stats_ret $port.aggregate.tx.test_pkts $pkt_count
                }
                if {![catch {keylget stats_ret $port.aggregate.tx.total_pkts} errMsg]} {
                    set total_pkts [keylget stats_ret $port.aggregate.tx.total_pkts]
                    keylset stats_ret $port.aggregate.tx.non_test_pkts  [expr $total_pkts - $pkt_count]
                }
                if {![catch {keylget stats_ret $port.aggregate.tx.total_pkt_bytes} errMsg]} {
                    set total_pkt_bytes [keylget stats_ret $port.aggregate.tx.total_pkt_bytes]
                    if {![catch {keylget stats_ret $port.aggregate.tx.pkt_byte_count} errMsg]} {
                        set pkt_byte_count [keylget stats_ret $port.aggregate.tx.pkt_byte_count]
                        keylset stats_ret $port.aggregate.tx.non_test_bytes  [expr $total_pkt_bytes - $pkt_byte_count]
                        keylset stats_ret $port.aggregate.tx.test_bytes   $pkt_byte_count
                    }
                }

                if {![catch {keylget stats_ret $port.aggregate.tx.total_pkt_rate} errMsg]} {
                    set  total_pkt_rate [keylget stats_ret $port.aggregate.tx.total_pkt_rate]
                    if {![catch {keylget stats_ret $port.aggregate.tx.pkt_rate} errMsg]} {
                        set pkt_rate [keylget stats_ret $port.aggregate.tx.pkt_rate]
                        keylset stats_ret $port.aggregate.tx.non_test_rate  [expr $total_pkt_rate - $pkt_rate]
                        keylset stats_ret $port.aggregate.tx.test_rate  $pkt_rate
                        keylset stats_ret $port.aggregate.tx.raw_pkt_rate           $total_pkt_rate
                    }
                    
                }

                if {![catch {keylget stats_ret $port.aggregate.tx.pkt_bit_rate} errMsg]} {
                    set pkt_bit_rate [keylget stats_ret $port.aggregate.tx.pkt_bit_rate]
                    keylset stats_ret $port.aggregate.tx.test_bit_rate  $pkt_bit_rate
                }
                keylset stats_ret $port.aggregate.tx.non_test_bit_rate  "null"
            }
        }
    }

    if {$aggregate_tag == 1} {
        if {[lsearch $args "-port_handle"] > -1} {
            set porthandlelist [::wrapper::get_value_list $args "-port_handle"]
        }
        foreach aggregate_key $porthandlelist {
            if {[regexp -nocase "port" $aggregate_key]} {
                set port_hdl $aggregate_key
                set pkt_rate [keylget stats_ret $port_hdl.aggregate.tx.pkt_rate]
                keylset stats_ret $port_hdl.aggregate.tx.raw_pkt_rate $pkt_rate
                set generator [::sth::sthCore::invoke stc::get $port_hdl -children-Generator]
                set generatorConfig [::sth::sthCore::invoke stc::get $generator -children-GeneratorConfig]
                set duration [::sth::sthCore::invoke stc::get $generatorConfig -DurationMode]

                if {$pkt_rate == 0 && ![regexp -nocase "BURSTS" $duration]} {
                    set current_streamlist [::sth::sthCore::invoke stc::get $port_hdl -children-streamblock]
                    set tx_rate [::wrapper::calculate_tx_rate $current_streamlist]
                    set sum_load [lindex $tx_rate 0]
                    set sum_bit [lindex $tx_rate 1]

                    set total_pkt_rate $sum_load
                    set pkt_rate $sum_load
                    set pkt_bit_rate $sum_bit
                    #keylset stats_ret $port_hdl.aggregate.rx.pkt_rate $pkt_rate
                    #keylset stats_ret $port_hdl.aggregate.rx.total_pkt_rate $total_pkt_rate
                    #keylset stats_ret $port_hdl.aggregate.rx.pkt_bit_rate $pkt_bit_rate
                    #keylset stats_ret $port_hdl.aggregate.rx.test_rate $pkt_rate
                    keylset stats_ret $port_hdl.aggregate.tx.pkt_rate $pkt_rate
                    keylset stats_ret $port_hdl.aggregate.tx.total_pkt_rate $total_pkt_rate
                    keylset stats_ret $port_hdl.aggregate.tx.pkt_bit_rate $pkt_bit_rate
                    keylset stats_ret $port_hdl.aggregate.tx.pkt_bit_rate $pkt_rate
                }
                
                set ana [::sth::sthCore::invoke stc::get $port_hdl -children-Analyzer]
                set anaconfig [::sth::sthCore::invoke stc::get $ana -children-Analyzer16BitFilter]
                if {$anaconfig != "" } {
                    #add analyzer filter result here
                    set FilterResultsData [::sth::sthCore::invoke stc::subscribe  -Parent $::sth::sthCore::GBLHNDMAP(project) \
                                    -ResultParent $port_hdl \
                                    -ConfigType analyzer \
                                    -resulttype filteredstreamresults \
                                    -viewAttributeList {SigFrameCount SigFrameRate Comp16_1 Comp16_2}]
    
                    ::sth::Traffic::delay "FilteredStreamResults"
                    foreach rxresult [::sth::sthCore::invoke stc::get $port_hdl.analyzer -children-filteredstreamresults] {
    
                        array set rxresultarray [::sth::sthCore::invoke stc::get $rxresult]
                        # Only use the first three bits of the 16-bit "Comp16_4" value.
                        set qoslevelword $rxresultarray(-Comp16_4)
    
                        # Right-shift the 16-bit word by 13 bits. That leaves us with a 3-bit QoS value.
                        set qoslevel [expr $qoslevelword >> 13]
    
                        if { ! [info exists qos($qoslevel.count)] } {
                            set qos($qoslevel.count) $rxresultarray(-SigFrameCount)
                        } else {
                            incr qos($qoslevel.count) $rxresultarray(-SigFrameCount)
                        }
    
                        if { ! [info exists qos($qoslevel.rate)] } {
                            set qos($qoslevel.rate)  $rxresultarray(-SigFrameRate)
                        } else {
                            incr qos($qoslevel.rate)  $rxresultarray(-SigFrameRate)
                        }
    
                    }
    
                    #unsubscriber
                    foreach ResultsData $FilterResultsData {
                        ::sth::sthCore::invoke stc::unsubscribe $ResultsData
                    }
                }

                keylset stats_ret $port_hdl.aggregate.rx.uds1_count 0
                keylset stats_ret $port_hdl.aggregate.rx.uds2_count 0
                # At this point, the "qos" array will have the 8 QoS counters and rates for each port.
                for { set qoslevel 0 } { $qoslevel < 8 } { incr qoslevel } {

                    if { ! [info exists qos($qoslevel.count)] } {
                        set qos($qoslevel.count) 0
                    }
                    if { ! [info exists qos($qoslevel.rate)] } {
                        set qos($qoslevel.rate) 0
                    }
                    keylset stats_ret $port_hdl.aggregate.rx.qos${qoslevel}_count $qos($qoslevel.count)
                    keylset stats_ret $port_hdl.aggregate.rx.qos${qoslevel}_rate  $qos($qoslevel.rate)
                    if {$qos($qoslevel.count) > 0} {
                        keylset stats_ret $port_hdl.aggregate.rx.uds1_count $qos($qoslevel.count)
                        keylset stats_ret $port_hdl.aggregate.rx.uds2_count $qos($qoslevel.count)
                    }
                    unset qos($qoslevel.count)
                    unset qos($qoslevel.rate)
                }
            }
        }
    }

    set stats_ret [regsub -nocase -all "streamblock"  $stats_ret ""]
    regsub -all out_of_sequence_pkts  $stats_ret integrity_errors stats_ret

    ###################################################################
    #for some script customer may use the physical port as the input port handle, and at this time they want to use the physical port
    #as the key value. so need to convert it.
    variable port_convert

    set args_ori [eval ::spirent::port_converter $args_ori]
    if {[lsearch $args_ori "-port_handle"] > -1} {
        set port_list [::wrapper::get_value_list $args_ori "-port_handle"]
        set port_logical_handle ""
        foreach port $port_list {
            if {[regexp "/" $port]} {
                set stats [keylget stats_ret $port_convert($port)]
                keylset stats_ret $port $stats
            }
        }
    }

    keylset stats_ret seconds "N/A"
    keylset stats_ret clicks "N/A"
    if {$aggregate_tag == 1} {
        if {[lsearch $args "-port_handle"] > -1} {
            set port_list [::wrapper::get_value_list $args "-port_handle"]
            foreach port $port_list {
                if {[regexp -nocase $port [keylkeys stats_ret]]} {
                    set capture [::sth::sthCore::invoke stc::get $port -children-capture]
                    set capturefilter [::sth::sthCore::invoke stc::get $capture -children-capturefilter]
                    set analyzerfilter [::sth::sthCore::invoke stc::get $capturefilter -children-CaptureAnalyzerFilter]
                    if {$analyzerfilter ne ""} {
                        set analyzerfilter [lindex $analyzerfilter 0]
                        set key_name [::sth::sthCore::invoke stc::get $analyzerfilter -FilterDescription]
                        if {$key_name ne ""} {
                            if {[keylget stats_ret $port.aggregate.rx.rx_combo_trigger_count] > 0} {
                                keylset stats_ret $port.aggregate.rx.$key_name [keylget stats_ret $port.aggregate.rx.rx_combo_trigger_count]
                            }
                        }
                    }
                }
            }
        }
    }

    # waiting_for_stats is used once in gre_mcast_lib.tcl
    keylset stats_ret waiting_for_stats 0
    return [::spirent::ret_port_converter [::wrapper::addStreamStats $stats_ret] $calledBy]
}

namespace eval ::wrapper:: {
}

##Add new implement with drv_stats
proc ::wrapper::traffic_stats {args} {
    set ret ""
    if {[catch {
        set port_list [stc::get project1 -children-port]
        array set port_stream ""
        foreach port $port_list {
            set port_stream($port) [stc::get $port -children-streamblock]
        }
        ##item0 {item0, item1,}, item1 (...
        ##port1 {sblk0, sblk1,}, port2 (...
        set drv_stats [::sth::Traffic::drv_stats_all    \
            -query_from         "$port_list"\
            -drv_name           "WrapperDrv"\
            -group_by           "Port.Name StreamBlock.Name"\
            -properties         "Port.Name Port.GeneratorSigFrameCount Port.RxSigFrameCount \
            Port.GeneratorFrameRate Port.GeneratorOctetCount Port.RxL1BitRate \
            Port.RxSigFrameRate Port.RxTotalFrameCount Port.RxTotalFrameRate \
            Port.RxTotalOctetCount Port.TxL1BitRate Port.TxTotalFrameCount \
            Port.TxTotalFrameRate Port.TxTotalOctetCount Port.TxPfcFrameCount \
            Port.RxFcoeFrameCount Port.RxUdpFrameCount Port.RxTcpFrameCount \
            Port.RxTcpChecksumErrorCount Port.RxPfcFrameCount Port.RxPfcFrameRate \
            Port.RxIpv4FrameCount Port.RxIpv6FrameCount Port.RxComboTriggerCount\
            Port.TxTotalIpv4FrameCount Port.TxTotalIpv6FrameCount \
            StreamBlock.Name StreamBlock.TxFrameCount StreamBlock.RxFrameCount \
            StreamBlock.RxBitRate StreamBlock.RxFrameRate StreamBlock.RxOctetCount \
            StreamBlock.RxOctetRate StreamBlock.TxBitRate StreamBlock.TxFrameRate \
            StreamBlock.TxOctetCount StreamBlock.TxOctetRate Port.RxFcoeFrameRate \
            StreamBlock.ReorderedFrameCount StreamBlock.PrbsBitErrorCount StreamBlock.AvgLatency \
            StreamBlock.MinLatency StreamBlock.MaxLatency StreamBlock.ReorderedFrameRate \
            StreamBlock.DuplicateFrameCount StreamBlock.DroppedFrameCount \
            StreamBlock.MaxFrameLength StreamBlock.MinFrameLength \
            StreamBlock.ActualRxPortName StreamBlock.PrbsBitErrorRate"\
        ]
        
        keylset ret status 1
        #convert drv_stats into traffic_stats results
        set port_num [keylget drv_stats result_count]
        for {set i 0} {$i < $port_num} {incr i} {
            set item "item$i"
            set portName [keylget drv_stats $item.PortName]
            foreach portblk $port_list {
                if {$portName == [stc::get $portblk -name]} {
                    set port $portblk
                    break
                }
            }
            set portRx ""
            set portTx ""
            foreach attr [array names ::spirent::port_rx_table] {
                if {[regexp "Port$::spirent::port_rx_table($attr)" [keylkeys drv_stats $item]]} {
                    keylset portRx $attr [keylget drv_stats $item.Port$::spirent::port_rx_table($attr)]
                }
            }
            keylset portRx rx_combo_trigger_count [keylget drv_stats $item.PortRxComboTriggerCount]
            keylset portRx pkt_byte_count [keylget drv_stats $item.PortRxTotalOctetCount]
            keylset portRx ip_pkts [expr [keylget drv_stats $item.PortRxIpv4FrameCount] + [keylget drv_stats $item.PortRxIpv6FrameCount]]
            
            keylset portRx sequence_errors_count 0
            keylset portRx duplicate_pkts 0
            keylset portRx dropped_pkts 0
            keylset portRx late_pkts 0
            
            foreach attr [array names ::spirent::port_tx_table] {
                if {[regexp "Port$::spirent::port_tx_table($attr)" [keylkeys drv_stats $item]]} {
                    keylset portTx $attr [keylget drv_stats $item.Port$::spirent::port_tx_table($attr)]
                }
            }
            keylset portTx elapsed_time 0
            if {$::sth::Traffic::processElapsedTime} {
                set frameCount [keylget drv_stats $item.PortTxTotalFrameCount]
                set frameRate [keylget drv_stats $item.PortTxTotalFrameRate]
                set stcValue [::sth::Traffic::processTrafficTxElapsedTime $port $frameCount $frameRate]
                keylset portTx elapsed_time $stcValue
            }
            keylset portTx ip_pkts [expr [keylget drv_stats $item.PortTxTotalIpv4FrameCount] + [keylget drv_stats $item.PortTxTotalIpv6FrameCount]]
            
            keylset ret $port.aggregate.rx $portRx
            keylset ret $port.aggregate.tx $portTx
            set strblk_num [keylget drv_stats $item.result_count]
            for {set j 0} {$j < $strblk_num} {incr j} {
                set item_strblk "item$j"
                set streamblockName [keylget drv_stats $item.$item_strblk.StreamBlockName]
                foreach strblk $port_stream($port) {
                    if {$streamblockName == [stc::get $strblk -name]} {
                        set streamblock $strblk
                        break
                    }
                }
                set strblkRx ""
                set strblkTx ""
                ##for unstart streamblock,avg_delay is none {}
                keylset strblkRx avg_delay 0
                foreach attr [array names ::spirent::stream_rx_table] {
                    if {[regexp "StreamBlock$::spirent::stream_rx_table($attr)" [keylkeys drv_stats $item.$item_strblk]]} {
                        keylset strblkRx $attr [keylget drv_stats $item.$item_strblk.StreamBlock$::spirent::stream_rx_table($attr)]
                    }
                }
                keylset strblkRx first_tstamp 0
                keylset strblkRx last_tstamp 0
                keylset strblkRx line_rate_percentage 0
                keylset strblkRx misinserted_pkt_rate [keylget drv_stats $item.$item_strblk.StreamBlockReorderedFrameRate]
                keylset strblkRx prbs_bit_error_rate [keylget drv_stats $item.$item_strblk.StreamBlockPrbsBitErrorRate]
                keylset strblkRx out_of_pkt_frame_rate [keylget drv_stats $item.$item_strblk.StreamBlockReorderedFrameRate]
                keylset strblkRx pkt_byte_rate [keylget drv_stats $item.$item_strblk.StreamBlockRxOctetRate]
                
                foreach attr [array names ::spirent::stream_tx_table] {
                    if {[regexp "StreamBlock$::spirent::stream_tx_table($attr)" [keylkeys drv_stats $item.$item_strblk]]} {
                        keylset strblkTx $attr [keylget drv_stats $item.$item_strblk.StreamBlock$::spirent::stream_tx_table($attr)]
                    }
                }
    
                if {$::sth::Traffic::processElapsedTime} {
                    set frameCount [keylget drv_stats $item.$item_strblk.StreamBlockTxOctetCount]
                    set frameRate [keylget drv_stats $item.$item_strblk.StreamBlockTxOctetRate]
                    set stcValue [::sth::Traffic::processTrafficTxElapsedTime $streamblock $frameCount $frameRate]
                    keylset strblkTx elapsed_time $stcValue
                }
                
                foreach attr "ipv4_outer_present udp_present ipv6_present ipv6_outer_present ipv4_present tcp_present" {
                    set stcValue [::sth::Traffic::processCheckHeaderPresent $streamblock $attr]
                    keylset strblkTx $attr $stcValue
                    keylset strblkRx $attr $stcValue
                }
                
                keylset strblkRx out_of_sequence_pkts [keylget drv_stats $item.$item_strblk.StreamBlockReorderedFrameCount]
                
                ##prepare loss_percent
                set tx_packets [keylget strblkTx total_pkts]
                set rx_packets [keylget strblkRx total_pkts]
                set loss_percent "0.0000"
                if {$tx_packets != 0} {
                    if {$rx_packets < $tx_packets} {
                        set loss_percent [expr {(1.0 - (1.0*$rx_packets / $tx_packets)) * 100}]
                        set loss_percent [format "%.4f" $loss_percent]
                    }
                }
                keylset strblkRx loss_percent $loss_percent
                            
                keylset ret $port.stream.$streamblock.rx $strblkRx
                keylset ret $port.stream.$streamblock.tx $strblkTx
            }
        }
    } ErrMsg]} {
        keylset ret status 0
        puts "Warning: wrapper::traffic_stats:$ErrMsg"
    }
    ##catch end
    
    catch {
        ##copy streamblock stats from Tx port into Rxport
        foreach port $port_list {
            foreach streamblock $port_stream($port) {
                ##calculate soem port level stats 
                keylset ret $port.aggregate.rx.sequence_errors_count    [expr {[keylget ret $port.aggregate.rx.sequence_errors_count] + [keylget ret $port.stream.$streamblock.rx.out_of_sequence_pkts] + [keylget ret $port.stream.$streamblock.rx.duplicate_pkts]}]
                keylset ret $port.aggregate.rx.duplicate_pkts           [expr {[keylget ret $port.aggregate.rx.duplicate_pkts] + [keylget ret $port.stream.$streamblock.rx.duplicate_pkts]}]
                keylset ret $port.aggregate.rx.dropped_pkts             [expr {[keylget ret $port.aggregate.rx.dropped_pkts] + [keylget ret $port.stream.$streamblock.rx.dropped_pkts]}]
                
                if {[regexp -nocase "rx_port" [keylkeys ret $port.stream.$streamblock.rx]]} {
                    set rxPortName [keylget ret $port.stream.$streamblock.rx.rx_port]
                    set rxPort ""
                    foreach portTemp $port_list {
                        if {$rxPortName == [stc::get $portTemp -name]} {
                            set rxPort $portTemp
                            break
                        }
                    }
                    ###Find the rxPort
                    if {$rxPort != ""} {
                        
                        if {[regexp "stream" [keylkeys ret $rxPort]]} {
                            keylset ret $rxPort.stream.$streamblock [keylget ret $port.stream.$streamblock]
                        } else {
                            set streamblockstats ""
                            keylset streamblockstats $streamblock [keylget ret $port.stream.$streamblock]
                            keylset ret $rxPort.stream $streamblockstats
                        }
                    }
                }
            }
        }
    }
    return $ret
}


proc ::spirent::cleanup_session {args} {
    set ixia_only_args ""
    set args [wrapper::shield_args -total $args -unsupported "handle"]
    regsub -all "port_list" $args "port_handle" args
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set processed_args $args
    set cmdName "sth::cleanup_session $processed_args"
    return [::spirent::process_cmd $cmdName]
}


proc ::spirent::emulation_ldp_config {args} {

    set ixia_only_args ""
    ######convert physical port
    set args [wrapper::shield_args -total $args -unsupported "reset"]

    set args [eval ::spirent::port_converter $args]

    array set argArray {}
    ::spirent::listToArray $args argArray
	
    array unset argArray -discard_self_adv_fecs
    array unset argArray -enable_explicit_include_ip_fec
    array unset argArray -enable_l2vpn_vc_fecs
    array unset argArray -enable_remote_connect
	
    if {(([info exist argArray(-label_adv)] && ("on_demand" == $argArray(-label_adv))) \
            &&([info exist argArray(-graceful_restart_enable)] && ( 1 == $argArray(-graceful_restart_enable))))} {
        set argArray(-graceful_restart_enable) 0 
    }
	
    set args [array get argArray]
    ##in case -vlan 0
    if {[lsearch $args "-vlan"] > -1} {
        set index [lsearch $args "-vlan"]
        set vlan [lindex $args [expr $index + 1]]
        set vlanArgList "vlan"
        if {$vlan == 0} {
            set vlanArgList "$vlanArgList vlan_id vlan_id_mode vlan_id_step vlan_user_priority"
        }
        set args [wrapper::shield_args -total $args -unsupported $vlanArgList]
    }

    set args_interval ""
    ##here need be aware that XXX_hold_time = 3* XXX_interval, ixia also follow this
    ## XXX is keepalive|hello
    if {[lsearch $args "-keepalive_holdtime"] > -1 } {
        set keepalive_holdtime [lindex $args [expr [lsearch $args "-keepalive_holdtime"] + 1]]
        set args_interval "$args_interval -keepalive_interval [expr $keepalive_holdtime / 3]"
    }

    if {[lsearch $args "-hello_hold_time"] > -1 } {
        set hello_hold_time [lindex $args [expr [lsearch $args "-hello_hold_time"] + 1]]
        set args_interval "$args_interval -hello_interval [expr $hello_hold_time / 3]"
    }
    if {[lsearch $args "-graceful_restart_enable"] > -1 } {
        if {[lsearch $args "-label_adv"] > -1 } {
            set label_advertisement [lindex $args [expr [lsearch $args "-label_adv"] + 1]]
            if {[string equal -nocase "on_demand" $label_advertisement]} {
                set graceful_restart 0
            } else {
                set graceful_restart [lindex $args [expr [lsearch $args "-graceful_restart_enable"] + 1]]
            }
        } else {
            set graceful_restart [lindex $args [expr [lsearch $args "-graceful_restart_enable"] + 1]]
        }
        set args_interval "$args_interval -graceful_restart $graceful_restart"
    }

    set ixia_only_args "hello_hold_time keepalive_holdtime targeted_hello_hold_time vlan label_space enable_l2vpn_vc_fecs reset keepalive_interval hello_interval graceful_restart_enable discard_self_adv_fecs enable_explicit_include_ip_fec enable_l2vpn_vc_fecs enable_remote_connect"
    set args [wrapper::shield_args -total $args -unsupported $ixia_only_args]

    set args "$args $args_interval"
    set processed_args $args
    if {[lsearch $args "-gateway_ip_addr"] == -1 } {
        array set ixia_spirent_arg_array "remote_ip_addr gateway_ip_addr remote_ip_addr_step gateway_ip_addr_step"
        set processed_args [wrapper::convert_args -total $args -unsupported ixia_spirent_arg_array]
    }
    if {([lsearch $processed_args "-count"] > -1) && ([lindex $processed_args [expr [lsearch $processed_args "-count"] + 1]] > 1) } {
        set count [lindex $processed_args [expr [lsearch $processed_args "-count"] + 1]]
        ###handle count > 1
        set ret ""
        keylset ret status 1
        keylset ret handle ""
        set processed_args [wrapper::shield_args -total $processed_args -unsupported "count"]
        set processed_args "$processed_args -count 1"

        if {[lsearch $args "-port_handle"] > -1 } {
            set port_handle [lindex $args [expr [lsearch $args "-port_handle"] + 1]]
        }
        set flag 0

        for {set counti 0} {$counti < $count } {incr counti} {
            ##intf_ip_addr
            if {[lsearch $processed_args "-intf_ip_addr"] > -1 } {
                set index1 [lsearch $processed_args "-intf_ip_addr"]
                set intf_ip_addr [lindex $processed_args [expr $index1 + 1]]
                set intf_ip_addr_step "0.0.0.1"
                if {[lsearch $processed_args "-intf_ip_addr_step"] > -1 } {
                    set intf_ip_addr_step [lindex $processed_args [expr [lsearch $processed_args "-intf_ip_addr_step"] + 1]]
                }
                if {$counti == 0} {
                    set intf_ip_addr_step "0.0.0.0"
                }
                set intf_ip_addr [::sth::sthCore::updateIpAddress 4  $intf_ip_addr $intf_ip_addr_step 1]
                set processed_args [lreplace $processed_args [expr $index1 + 1] [expr $index1 + 1] $intf_ip_addr]
            }
            ##lsr_id
            if {[lsearch $processed_args "-lsr_id"] > -1 } {
                set index1 [lsearch $processed_args "-lsr_id"]
                set lsr_id [lindex $processed_args [expr $index1 + 1]]
                set lsr_id_step "0.0.0.0"
                if {[lsearch $processed_args "-lsr_id_step"] > -1 } {
                    set lsr_id_step [lindex $processed_args [expr [lsearch $processed_args "-lsr_id_step"] + 1]]
                }
                if {$counti == 0} {
                    set lsr_id_step "0.0.0.0"
                }
                set lsr_id [::sth::sthCore::updateIpAddress 4  $lsr_id $lsr_id_step 1]
                set processed_args [lreplace $processed_args [expr $index1 + 1] [expr $index1 + 1] $lsr_id]
            }
            ##gateway_ip_addr
            if {[lsearch $processed_args "-gateway_ip_addr"] > -1 } {
                set index1 [lsearch $processed_args "-gateway_ip_addr"]
                set gateway_ip_addr [lindex $processed_args [expr $index1 + 1]]
                set gateway_ip_addr_step "0.0.0.1"
                if {[lsearch $processed_args "-gateway_ip_addr_step"] > -1 } {
                    set gateway_ip_addr_step [lindex $processed_args [expr [lsearch $processed_args "-gateway_ip_addr_step"] + 1]]
                }
                if {$counti == 0} {
                    set gateway_ip_addr_step "0.0.0.0"
                }
                set gateway_ip_addr [::sth::sthCore::updateIpAddress 4  $gateway_ip_addr $gateway_ip_addr_step 1]
                set processed_args [lreplace $processed_args [expr $index1 + 1] [expr $index1 + 1] $gateway_ip_addr]
            }

            #check if there is already one device created with the same ip, then use this mac address as mac_address_start
            if {[lsearch $processed_args "-intf_ip_addr"] > -1 && [lsearch $processed_args "-port_handle"] > -1} {
                set intf_ip_addr [lindex $processed_args [expr [lsearch $processed_args "-intf_ip_addr"] + 1]]
                set port_hdl_index [expr [lsearch $processed_args "-port_handle"] + 1]
                set port_hdl [lindex $processed_args $port_hdl_index]
                set device [::wrapper::get_device_with_ip_new $intf_ip_addr $port_hdl]
                if {$device != ""} {
                    set processed_args [lreplace $processed_args [expr $port_hdl_index - 1] $port_hdl_index -handle $device]
                    set flag 1
                }
            }
            set cmdName "sth::emulation_ldp_config $processed_args"
            #puts "use#####$processed_args#####"
            if {$flag} {
                set flag 0
                set processed_args [wrapper::shield_args -total $processed_args -unsupported "handle"]
                set processed_args "$processed_args -port_handle $port_handle"
            }
            set reti [::spirent::process_cmd $cmdName]
            if {[keylget reti status] == 0} {
                keylset ret status 1
                keylset ret log [keylget reti log]
                return $ret
            }
            if {[info exist argArray(-intf_ip_addr)]} {
                set intf_ip_addr $argArray(-intf_ip_addr)
                set ::spirent::ip_device($intf_ip_addr) [keylget reti handle]
            }
            
            if {[lsearch $processed_args "-intf_ip_addr"] > -1 } {
                set intf_ip_addr [lindex $processed_args [expr [lsearch $processed_args "-intf_ip_addr"] + 1]]
                set ::spirent::ip_device($intf_ip_addr) [keylget reti handle]
            }
            keylset ret handle "[keylget ret handle] [keylget reti handle]"
        }
        keylset ret handles [keylget ret handle]
        return $ret
    } else {
        #check if there is already one device created with the same ip, then use this mac address as mac_address_start
        if {[lsearch $processed_args "-intf_ip_addr"] > -1 && [lsearch $processed_args "-port_handle"] > -1} {
            set intf_ip_addr [lindex $processed_args [expr [lsearch $processed_args "-intf_ip_addr"] + 1]]
            set port_hdl_index [expr [lsearch $processed_args "-port_handle"] + 1]
            set port_hdl [lindex $processed_args $port_hdl_index]
            set device [::wrapper::get_device_with_ip_new $intf_ip_addr $port_hdl]
            if {$device != ""} {
                set processed_args [lreplace $processed_args [expr $port_hdl_index - 1] $port_hdl_index -handle $device]
            }
        }

        set cmdName "sth::emulation_ldp_config $processed_args"
        return [::spirent::process_cmd $cmdName]
    }
}

proc ::spirent::emulation_ldp_control {args} {
    #enhance hltapi to handle port_handle
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set ixia_only_args ""
    set processed_args $args
    set cmdName "sth::emulation_ldp_control $processed_args"
    set retVal [::spirent::process_cmd $cmdName]
    keylset retVal seconds "N/A"
    keylset retVal clicks "N/A"
    return $retVal
}

proc ::spirent::emulation_ldp_route_config {args} {
    #from ixia usrDoc, it says "egress_label_mode has any meaning only
    #when fec_type is host_addr", actually, csutomer scripts use ipv4_prefix
    #so here just shield this parameter.
    #############################################################################################################################
    ##add by chenling
    #egress_label_mode:                 in emulation_ldp_config
    #label_msg_type:                    this is support is the STC, but not supported in  hltapi,so removed.
    #fec_vc_intf_desc,fec_vc_intf_mtu_enable,hop_count_tlv_enable,hop_count_value,path_vector_tlv,path_vector_tlv_lsr,label_value_start,packing_enable,no_write Not supported, removed.
    #num_routes and num_lsps will be enhanced in hltapi.
    #############################################################################################################################
    ######convert physical port
    set args [eval ::spirent::port_converter $args]
    set ixia_only_args "egress_label_mode \
                        label_msg_type \
                        fec_vc_intf_desc \
                        fec_vc_intf_mtu_enable \
                        hop_count_tlv_enable \
                        hop_count_value \
                        path_vector_tlv \
                        path_vector_tlv_lsr \
                        label_value_start \
                        packing_enable \
                        no_write"
    set processed_args [wrapper::shield_args -total $args -unsupported $ixia_only_args]

    set fec_type "prefix"
    if {[lsearch $args "-fec_type"] > -1} {
    set index_type [lsearch $args "-fec_type"]
    set fec_type [lindex $args [expr $index_type + 1]]
    }

    if {[lsearch $args "-handle"] > -1} {
        set index_handle [lsearch $args "-handle"]
        set handle [lindex $args [expr $index_handle + 1]]
        set ldp_router [::sth::sthCore::invoke stc::get $handle -children-LdpRouterConfig]

        }
    #-num_lsps is supported from(inlcudes) HLTAPI 4.50 GA
    #if {[lsearch $args "-num_lsps"] > -1} {
    #    set index [lsearch $args "-num_lsps"]
    #    set num_lsps [lindex $args [expr $index + 1]]
    #    if { $num_lsps>1 }  {
    #        if {[lsearch $args "-fec_ip_prefix_step"] > -1} {
    #            if {[string equal $fec_type "ipv4_prefix"]==0} {
    #                #remove the -num_lsps from the $processed_args
    #                set processed_args [lreplace $processed_args $index  [expr $index + 1] ]
    #            }
    #        } else {
    #            set processed_args [lreplace $processed_args $index  [expr $index + 1] ]
    #        }
    #    }
    #}


    if {[string equal $fec_type "ipv4_prefix"]} {
        if {[lsearch $args "-fec_ip_prefix_start"]==-1} {
            set fec_ip_prefix_start "192.0.1.0"
            set processed_args [concat $processed_args -fec_ip_prefix_start $fec_ip_prefix_start]
        }
    } elseif {[string equal $fec_type "-fec_host_addr"]} {
        if {[lsearch $args "host_addr"]==-1} {
            set fec_host_addr "192.0.1.0"
            set processed_args [concat $processed_args  -fec_host_addr $fec_host_addr]
        }
    }


    ##spirent emulation_ldp_route_config hltapi dosen't support -egress_label_mode, but in emulation_ldp_config support


    if {[lsearch $args "-egress_label_mode"] > -1} {
        if {[string equal $fec_type "host_addr"]} {
        set index_egress [lsearch $args "-egress_label_mode"]
        set egress_label_mode [lindex $args [expr $index_egress + 1]]
        if {[string equal $egress_label_mode "exnull"]} {
        set egress_label_mode "LDP_EGRESS_EXPLICIT_NULL"
        } elseif {[string equal $egress_label_mode "imnull"]} {
        set egress_label_mode "LDP_EGRESS_IMPLICIT_NULL"
        } elseif {[string equal $egress_label_mode "nextlabel"]} {
        set egress_label_mode "LDP_EGRESS_NEXTAVAILABLE"
        }
        set  egress_label_mod  [::sth::sthCore::invoke stc::config $ldp_router -EgressLabel $egress_label_mode]
      }
    }

    if {[lsearch $args "-label_value_start"] > -1} {
        set index_lable [lsearch $args "-label_value_start"]
        set label_value_start [lindex $args [expr $index_lable + 1]]
        set label_start [::sth::sthCore::invoke stc::config $ldp_router  -LabelMin $label_value_start]
      }

    if {[lsearch $args "-fec_vc_label_value_start"] > -1} {
        set index_lablevc [lsearch $args "-fec_vc_label_value_start"]
        set fec_vc_label_value_start [lindex $args [expr $index_lablevc + 1]]
        set label_start  [::sth::sthCore::invoke stc::config $ldp_router  -LabelMin $fec_vc_label_value_start]
      }
    set cmdName "sth::emulation_ldp_route_config $processed_args"
    return [::spirent::process_cmd $cmdName]
}

proc ::spirent::AddSingleBurst { streamblock burstsize rate rateunit } {
    # This procedure attempts to emulate Ixia's "single burst" option for streams.
    # Calling this procedure will configure the Spirent TestCenter to send a single
    # burst of the specified streamblock. If the same streamblock is specified
    # multiple times, the previous burst will be overwritten.
    # Multiple streamblocks can be specified, and the frames will be interleaved.
    #
    # NOTE: While Ixia supports it, continuous traffic streams are not supported.
    # NOTE: Do not manually add entries to the Manual Scheduler before calling this
    #       procedure. It may mess the command up.
    #
    # eg:
    #    addSingleBurst streamblock1 10 100 "FRAMES_PER_SECOND"
    #    addSingleBurst streamblock2 20 200 "FRAMES_PER_SECOND"
    #    addSingleBurst streamblock3 30 300 "FRAMES_PER_SECOND"
    #
    #   This will result in the following entries in the manual scheduler:
    #       Entry StreamBlock   ReturnToEntry LoopCount
    #       1     streamblock1  -             -
    #       2     streamblock2  -             -
    #       3     streamblock3  1             9
    #       4     streamblock2  -             -
    #       5     streamblock3  4             9
    #       6     streamblock3  6             10


    # Make sure the manual scheduler object exists for this port.
    set port [::sth::sthCore::invoke stc::get $streamblock -parent]
    set gc [::sth::sthCore::invoke stc::get $port.generator -children-generatorconfig]
    set ms [::sth::sthCore::invoke stc::get $gc             -children-manualschedule]

    if { $ms eq "" } {
        set ms [::sth::sthCore::invoke stc::create ManualSchedule -under $gc]
    }

    # We need to use the Manual Scheduler to make this work.
    ::sth::sthCore::invoke stc::config $gc -schedulingmode "MANUAL_BASED"

    # We will be completely reconfiguring the manual scheduler. Examine
    # the existing entries and determine the frame counts, rate and rateunits
    # for all streamblocks that have existing entries. If there are entries here,
    # it means that the "addSingleBurst" command was called earlier.
    set streamblockarray(list) ""
    set blockarray(list)       ""
    set block                  1
    foreach entry [::sth::sthCore::invoke stc::get $ms -children-ManualScheduleEntry] {
        set sourcestreamblock [::sth::sthCore::invoke stc::get $entry -AffiliationManualScheduleEntryStreamBlock-Targets]
        set nextentry         [::sth::sthCore::invoke stc::get $entry -LoopBackToEntry-targets]

        set streamblockarray($sourcestreamblock.rate)     [::sth::sthCore::invoke stc::get $entry -InterEntryGap]
        set streamblockarray($sourcestreamblock.rateunit) [::sth::sthCore::invoke stc::get $entry -InterEntryGapUnit]

        if { $sourcestreamblock ne $streamblock } {
            lappend blockarray($block.streamblocklist) $sourcestreamblock
        }

        if { $nextentry ne "" && [info exists blockarray($block.streamblocklist)] } {
            # If $nextentry is not empty, this means that this entry is the last one in the block.
            if { $nextentry eq $entry } {
                # There is only one streamblock in the block.
                set framecount [::sth::sthCore::invoke stc::get $entry -LoopCount]
            } else {
                # The number of frames sent by this block is the "LoopCount" + 1.
                set framecount [expr [::sth::sthCore::invoke stc::get $entry -LoopCount] + 1]
            }

            # The total number of frames sent by this block is the framecount multiplied by the number of entries.
            set blockframecount [expr $framecount * [llength $blockarray($block.streamblocklist)]]

            # Keep track of the total number of frames sent by each streamblock.
            foreach sourcestreamblock $blockarray($block.streamblocklist) {
                if { ! [info exists streamblockarray($sourcestreamblock)] } {
                    lappend streamblockarray(list) $sourcestreamblock

                    set streamblockarray($sourcestreamblock) $framecount

                } else {
                    incr streamblockarray($sourcestreamblock) $framecount
                }
            }

            incr block
        }
    }

    # Delete all existing entries. We'll need to add them back later.
    foreach entry [::sth::sthCore::invoke stc::get $ms -children-ManualScheduleEntry] {
        ::sth::sthCore::invoke stc::delete $entry
    }

    array unset blockarray

    # Add the new streamblock. If the streamblock already has an entry, overwrite it with the info.
    set streamblockarray($streamblock)          $burstsize
    set streamblockarray($streamblock.rate)     $rate
    set streamblockarray($streamblock.rateunit) $rateunit
    lappend streamblockarray(list) $streamblock

    # Determine how many blocks of entries we need.
    set blockarray(list) ""
    foreach streamblockentry $streamblockarray(list) {
        set framecount $streamblockarray($streamblockentry)
        if { [lsearch -exact $blockarray(list) $framecount] == -1 } {
            lappend blockarray(list) $framecount
        }
    }
    # Sort the list.
    set blockarray(list) [lsort -integer $blockarray(list)]

    # Now determine the streamblocks per block, and the number of frames generated by each streamblock for that block.
    set totalframecount               0
    set totalframecountperstreamblock 0
    foreach framecount $blockarray(list) {

        foreach streamblockentry $streamblockarray(list) {
            set streamblockframecount $streamblockarray($streamblockentry)
            if { $streamblockframecount >= $framecount } {
                lappend blockarray($framecount.streamblocklist) $streamblockentry

                incr totalframecount [expr $framecount - $totalframecountperstreamblock]
            }
        }
        set blockarray($framecount.framecount) [expr $framecount - $totalframecountperstreamblock]

        set totalframecountperstreamblock $framecount
    }

    # Now add ManualScheduleEntry objects.
    foreach block $blockarray(list) {
        foreach streamblockentry $blockarray($block.streamblocklist) {
            set entry [::sth::sthCore::invoke stc::create ManualScheduleEntry -under             $ms                                           \
                                                       -InterEntryGap     $streamblockarray($streamblockentry.rate)     \
                                                       -InterEntryGapUnit $streamblockarray($streamblockentry.rateunit) \
                                                       -AffiliationManualScheduleEntryStreamBlock-Targets $streamblockentry]

            if { ! [info exists firstentry] } {
                set firstentry $entry
            }
        }

        if { $entry eq $firstentry } {
            ::sth::sthCore::invoke stc::config $entry -LoopCount               $blockarray($block.framecount)
            ::sth::sthCore::invoke stc::config $entry -LoopBackToEntry-targets $entry
        } else {
            ::sth::sthCore::invoke stc::config $entry -LoopCount               [expr $blockarray($block.framecount) - 1]
            ::sth::sthCore::invoke stc::config $entry -LoopBackToEntry-targets $firstentry
        }

        catch {unset firstentry}
    }

    # Configure the duration for the port to match the total number of frames generated by all of the bursts.
    ::sth::sthCore::invoke stc::config $port.generator.generatorconfig -duration     $totalframecount \
                                                -durationmode "BURSTS"

    return
}

proc ::spirent::convertIp2Integer { ip } {

    set result ""
    switch -- [::ip::version $ip] {
        4 {
            set result [::ip::toInteger $ip]
        }
        6 {
            # Since IPv6 cannot be converted to a 32-bit number, only
            # convert 4-bytes worth (the last 4 bytes).
            set normalized_ip [::ip::normalize $ip]

            regsub -all {:} $normalized_ip {} normalized_ip

            # Extract the last four bytes, which are in hex.
            set bytes "0x[string range $normalized_ip end-7 end]"

            # Convert to decimal.
            set result [format %u $bytes]

        }
        default {
            if { [string is integer -strict $ip] } {
                # $ip is actually just an integer already, so return it.
                set result $ip
            } else {
                error "The IP address '$ip' is not a valid IPv4 or IPv6 address."
            }
        }
    }

    return $result
}

proc ::spirent::get_next_link_local_intf_ip_addr {} {
    variable link_local_intf_ip_addr_default1
    variable link_local_intf_ip_addr_default2

    incr link_local_intf_ip_addr_default2

    return $link_local_intf_ip_addr_default1$link_local_intf_ip_addr_default2
}

proc ::wrapper::ConvertIpAddressAsInteger { ipAddr } {

    set result 0

    set parts   [split $ipAddr .]
    set factors {16777216.0 65536.0 256.0 1.0}
    foreach i { 3 2 1 0 } {
        set part   [lindex $parts $i]
        set factor [lindex $factors $i]
        set value  [expr $part * $factor]
        set result [expr $result + $value]
    }
    return [lindex [split $result .] 0]
}

proc ::wrapper::ConvertIntegerAsIpAddress { value } {

    set parts ""
    set result 0
    set factors {16777216.0 65536.0 256.0 1.0}
    # Ensure input parameter is treated as a floating point number
    # as it may be too big for Tcl's 32-bit signed-integer representation
    if {[string index $value end] != "."} {
        set value "$value."
    }
    foreach i {0 1 2 3} {
        set factor [lindex $factors $i]
        set v      [expr $value/$factor]
        if { $v < 1 } { set v 0 }
        set part   [lindex [split $v .] 0]
        lappend parts $part
        set value [expr $value - ($part * $factor)]
        set result [join $parts .]
    }

    return $result
}

proc ::wrapper::ConvertIncrementIpAddress { ipAddr numAddr } {

    set result 0
    set startValue [::wrapper::ConvertIpAddressAsInteger $ipAddr]
    set finalValue [expr $startValue. + $numAddr]
    set result     [::wrapper::ConvertIntegerAsIpAddress [lindex [split $finalValue .] 0]]
    return $result
}

proc ::wrapper::add_mandatory_args {args} {
    set total_args ""
    set unsupported_array_name ""
    if {[lsearch $args "-total"] > -1} {
        set total_args [lindex $args [expr {[lsearch $args "-total"] + 1}]]
    }
    if {[lsearch $args "-mandatory"] > -1} {
        set mandatory_array_name [lindex $args [expr {[lsearch $args "-mandatory"] + 1}]]
        upvar $mandatory_array_name mandatory_args_array
        foreach arg [array names mandatory_args_array] {
            if {[lsearch $total_args "-$arg"] < 0} {
                set total_args [concat $total_args "-$arg $mandatory_args_array($arg)"]
            }

        }
        return $total_args
    }
}

proc ::wrapper::convert_args {args} {
    set total_args ""
    set unsupported_array_name ""
    if {[lsearch $args "-total"] > -1} {
        set total_args [lindex $args [expr {[lsearch $args "-total"] + 1}]]
    }
    if {[lsearch $args "-unsupported"] > -1} {
        set unsupported_array_name [lindex $args [expr {[lsearch $args "-unsupported"] + 1}]]
        upvar $unsupported_array_name ixia_spirent_arg_array
        foreach arg [array names ixia_spirent_arg_array] {
            if {[lsearch $total_args "-$arg"] > -1} {
                set index [lsearch $total_args "-$arg"]
                set total_args [lreplace $total_args $index $index "-$ixia_spirent_arg_array($arg)"]
            }

        }
        return $total_args
    }
}
proc ::wrapper::shield_args {args} {
    #-total
    #-unsupported
    set total_args ""
    set unsupported_args ""
    if {[lsearch $args "-total"] > -1} {
        set total_args [lindex $args [expr {[lsearch $args "-total"] + 1}]]
    }

     if {[lsearch $args "-unsupported"] > -1} {
        set unsupported_args [lindex $args [expr {[lsearch $args "-unsupported"] + 1}]]
    }
    foreach arg $unsupported_args {
        if {[lsearch $total_args "-$arg"] > -1} {
            set index [lsearch $total_args "-$arg"]
            if {[regexp {\-} [lindex $total_args [expr {$index + 1}]]]} {
                #the value of this option is a flag and here no vlaue is input
                set total_args [lreplace $total_args $index $index]
            } else {
                for {set i [expr {$index + 1}]} {$i < [llength $total_args]} {incr i} {
                    set arg_next [lindex $total_args $i]
                    if {$arg_next == "" || [regexp ^- $arg_next]} {
                        incr i -1
                        break
                    }
                }
                set total_args [lreplace $total_args $index $i]
            }
        }
    }

    # process the options which is flag, most of these options in hltapi support only CHOICE type
    set processed_args ""
    foreach arg $total_args {
        set processed_args [concat $processed_args $arg]
        if {[regexp {^\-} $arg]} {
            set index [lsearch $total_args "$arg"]
            if {[regexp {^\-} [lindex $total_args [expr {$index + 1}]]] || [expr {$index + 1}] == [llength $total_args]} {
                set processed_args [concat $processed_args 1]
            }
        }
    }
    return $processed_args
}

########################################
#change the frame data from
#55555555555555D50000010000010000C001
#into
#55 55 55 55 55 55 55 D5 00 00 01 00
#00 01 00 00 C0 01
#maybe can be used in wrapper
proc ::wrapper::add_space {data} {
    set ret ""
    set len [string length $data]
    for {set i 0} {$i < $len} {incr i 2} {
        set j [expr $i + 1]
        set ret [concat $ret [string range $data $i $j]]
    }
    return $ret
}


#calculate the tx rate based on the configuration
proc ::wrapper::calculate_tx_rate {strblk_list} {
    set tx_rate ""
    set sum_pkt_rate 0
    set sum_bit_rate 0
    foreach current_stream $strblk_list {
        set active [::sth::sthCore::invoke stc::get $current_stream -active]
        if {[regexp -nocase "false" $active]} {
            continue
        }
        set load [::sth::sthCore::invoke stc::get $current_stream -load]
        set load_unit [::sth::sthCore::invoke stc::get $current_stream -LoadUnit]
        if {[regexp -nocase "FRAMES_PER_SECOND" $load_unit]} {
            set fixed_framelength [::sth::sthCore::invoke stc::get $current_stream -FixedFrameLength]
            set pkt_rate $load
            set sum_pkt_rate [expr $sum_pkt_rate + $pkt_rate]
            set stream_bit [expr [expr $fixed_framelength * $load] * 8]
            set sum_bit_rate [expr $sum_bit_rate + $stream_bit]
        } elseif {[regexp -nocase "PERCENT_LINE_RATE" $load_unit]} {
            set fixed_framelength [::sth::sthCore::invoke stc::get $current_stream -FixedFrameLength]
            #the fixed_framelength will be added extra 20 bytes based on trying on GUI
            set framelength [expr $fixed_framelength + 20]
            #get the line_speed of test module
            set port_hdl [::sth::sthCore::invoke stc::get $current_stream -parent]
            set active_phy [::sth::sthCore::invoke stc::get $port_hdl -ActivePhy-targets]
            if {$active_phy == ""} {
                #set the default line speed for offline testing
                set line_speed "speed_1g"
            } else {
                set line_speed [::sth::sthCore::invoke stc::get $active_phy -linespeedstatus]
            }

            switch -regexp [string tolower $line_speed] {
                "speed_10m" {
                    set speed 10000000
                }
                "speed_100m" {
                    set speed 100000000
                }
                "speed_1g" {
                    set speed 1000000000
                }
                "speed_10g" {
                    set speed 10000000000
                }
                "speed_40g" {
                    set speed 40000000000
                }
                "speed_100g" {
                    set speed 100000000000
                }
            }
            set bit_rate [expr $speed * [expr $load.0/100]]
            set byte_rate [expr $bit_rate/8]
            set pkt_rate [expr $byte_rate/$framelength]
            set sum_pkt_rate [expr $sum_pkt_rate + $pkt_rate]
            set sum_bit_rate [expr $sum_bit_rate + $bit_rate]
        }

    }

    set tx_rate "$sum_pkt_rate $sum_bit_rate"
    return $tx_rate
}

#calculate the inter frame gap for different rate_pps values, different test modules.
# the IFG is calculated for each streamblock as below:
# IFG (bytes) = [line_speed - (frame_size + 8 (preamble)) * 8 *rate_pps]/rate_pps/8
# for multiple streamblocks, need to calculate the bandwidth for each streamblock
# IFG = [line_speed - total_used_bandwidth]/total_rate_pps/8
proc ::wrapper::calculate_gap {processed_args} {
    set gap_args ""

    #1. get the speed of the test module used

    #check if the mode is create
    set mode_index [expr [lsearch $processed_args "-mode"] + 1]
    set mode [lindex $processed_args $mode_index]
    if {[regexp -nocase "modify" $mode]} {
        set strblk_index [expr [lsearch $processed_args "-stream_id"] + 1]
        set modify_strblk_hdl [lindex $processed_args $strblk_index]
        if {[string is integer $modify_strblk_hdl]} {
            set modify_strblk_hdl streamblock$modify_strblk_hdl
        }
        set port_hdl [::sth::sthCore::invoke stc::get $modify_strblk_hdl -parent]
        set fixed_frame_length [::sth::sthCore::invoke stc::get $modify_strblk_hdl -FixedFrameLength]
        set loadUnit [::sth::sthCore::invoke stc::get $modify_strblk_hdl -LoadUnit]
        if {[string equal -nocase "FRAMES_PER_SECOND" $loadUnit]} {
            set load_value [::sth::sthCore::invoke stc::get $modify_strblk_hdl -FpsLoad]
        } elseif {[string equal -nocase "BITS_PER_SECOND" $loadUnit]} {
            set load_value [::sth::sthCore::invoke stc::get $modify_strblk_hdl -BpsLoad]
            set load_value [expr $load_value/($fixed_frame_length+20)/8]
        } else {
            set load_value [::sth::sthCore::invoke stc::get $modify_strblk_hdl -L2Rate]
            set load_value [expr $load_value/$fixed_frame_length/8]
        }
        catch {unset loadUnit}
    } else {
        set port_index [expr [lsearch $processed_args "-port_handle"] + 1]
        set port_hdl [lindex $processed_args $port_index]
        #check if it is bidirectional
        if {[lsearch $processed_args "-bidirectional"] > -1} {
            set bidi_index [expr [lsearch $processed_args "-bidirectional"] + 1]
            set bidi_value [lindex $processed_args $bidi_index]
            if {$bidi_value == 1} {
                set port_hdl2_index [expr [lsearch $processed_args "-port_handle2"] + 1]
                set port_hdl2 [lindex $processed_args $port_hdl2_index]
            }
        }
    }
    set active_phy [::sth::sthCore::invoke stc::get $port_hdl -ActivePhy-targets]
    if {$active_phy == ""} {
        #set the default line speed for offline testing
        set line_speed "speed_1g"
    } else {
        set line_speed [::sth::sthCore::invoke stc::get $active_phy -linespeedstatus]
    }
    switch -regexp [string tolower $line_speed] {
        "speed_10m" {
            set speed 10000000
        }
        "speed_100m" {
            set speed 100000000
        }
        "speed_1g" {
            set speed 1000000000
        }
        "speed_10g" {
            set speed 10000000000
        }
        "speed_40g" {
            set speed 40000000000
        }
        "speed_100g" {
            set speed 100000000000
        }
    }

    #2. get the pkt_size
    if {[lsearch $processed_args "-frame_size"] > -1} {
        set frame_size_index [expr [lsearch $processed_args "-frame_size"] + 1]
        set frame_size [lindex $processed_args $frame_size_index]
    } elseif {[lsearch $processed_args "-l3_length"] > -1} {
        set l3_length_index [expr [lsearch $processed_args "-l3_length"] + 1]
        set l3_length [lindex $processed_args $l3_length_index]
        #check if the vlan exists
        if {[regexp -nocase "vlan_outer_" $processed_args]} {
            set frame_size [expr $l3_length + 18 + 8]
        } elseif {[regexp -nocase "vlan_" $processed_args]} {
            set frame_size [expr $l3_length + 18 + 4]
        } else {
            set frame_size [expr $l3_length + 18]
        }
        if {[regexp -nocase "mpls_labels" $processed_args]} {
            set frame_size [expr $frame_size + 4]
        }
    } elseif {[info exists fixed_frame_length]} {
        set frame_size $fixed_frame_length
    } else {
        if {[regexp -nocase "vlan_outer_" $processed_args]} {
            set frame_size [expr 128 + 8]
        } elseif {[regexp -nocase "vlan_" $processed_args]} {
            set frame_size [expr 128 + 4]
        } else {
            set frame_size 128
        }
    }
    #add preamble
    set frame_size_bk $frame_size
    set frame_size [expr [expr $frame_size + 8] * 8]

    #3. get the frame/second
    if {[lsearch $processed_args "-rate_pps"] > -1} {
        set rate_pps_index [expr [lsearch $processed_args "-rate_pps"] + 1]
        set rate_pps [lindex $processed_args $rate_pps_index]
    } elseif {[info exists load_value]} {
        set rate_pps $load_value
    } elseif {[lsearch $processed_args "-rate_bps"] > -1} {
        set rate_bps_index [expr [lsearch $processed_args "-rate_bps"] + 1]
        set rate_bps [lindex $processed_args $rate_bps_index]
        incr frame_size_bk 20
        set frame_size_bk [expr  $frame_size_bk  * 8]
        set rate_pps [expr $rate_bps / (0 + $frame_size_bk)]
    }

    if {[info exists port_hdl2]} {
        set port_hdl_list "$port_hdl $port_hdl2"
    } else {
        set port_hdl_list $port_hdl
    }

    #handle large value calculation by adding ".0"
    set frame_size $frame_size.0
    if {![regexp {\.} $rate_pps]} {
        set rate_pps $rate_pps.0
    }
    #check if there is other streamblocks under this port_handle
    foreach port_hdl $port_hdl_list {
        set used_bandwidth 0
        set unused_bandwidth $speed
        set rate_pps_total 0
        set strblk_hdl_list [::sth::sthCore::invoke stc::get $port_hdl -children-streamblock]
        #if it is modify mode, remove the strblk_hdl
        if {[info exists modify_strblk_hdl]} {
            regsub "$modify_strblk_hdl" $strblk_hdl_list "" strblk_hdl_list
        }
        #if it is priority based scheduling mode, then need to calculate IFG of each streamblock
        set generator [::sth::sthCore::invoke stc::get $port_hdl -children-generator]
        set generator_cfg [::sth::sthCore::invoke stc::get $generator -children-generatorconfig]
        set schedul_mode [::sth::sthCore::invoke stc::get $generator_cfg -SchedulingMode]
        if {![regexp -nocase "PRIORITY_BASED" $schedul_mode]} {
            foreach strblk_handle $strblk_hdl_list {
                #need to check if the streamblock is active
                set stream_status [::sth::sthCore::invoke stc::get $strblk_handle -active]
                if {[regexp -nocase "false" $stream_status]} {
                    continue
                }
                set fixed_frame_length [::sth::sthCore::invoke stc::get $strblk_handle -FixedFrameLength]
                set fixed_frame_size_bits [expr [expr $fixed_frame_length + 8] * 8]
                set loadUnit [::sth::sthCore::invoke stc::get $strblk_handle -LoadUnit]
                if {[string equal -nocase "FRAMES_PER_SECOND" $loadUnit]} {
                    set load_value [::sth::sthCore::invoke stc::get $strblk_handle -FpsLoad]
                } elseif {[string equal -nocase "BITS_PER_SECOND" $loadUnit]} {
                    set load_value [::sth::sthCore::invoke stc::get $strblk_handle -BpsLoad]
                    set load_value [expr $load_value/($fixed_frame_length+20)/8]
                } else {
                    set load_value [::sth::sthCore::invoke stc::get $strblk_handle -L2Rate]
                    set load_value [expr $load_value/$fixed_frame_length/8]
                }
                set bandwidth [expr $fixed_frame_size_bits * $load_value]
                set unused_bandwidth [expr $unused_bandwidth - $bandwidth]
                set rate_pps_total [expr $rate_pps_total + $load_value]
            }
        }
        set rate_pps_total [expr $rate_pps_total + $rate_pps]
        set unused_bandwidth [expr $unused_bandwidth - [expr $frame_size * $rate_pps]]

        #check if the used bandwidth is larger than available bandwidth
        if {$unused_bandwidth < 0} {
            puts "ERROR: the available bandwidth is not enough, the line speed can't afford current configuration!"
            return ""
        }
        set gap_bits [expr $unused_bandwidth/$rate_pps_total]
        set gap [expr $gap_bits/8]
        #check if it is bidirectional
        if {[info exists port_hdl2]} {
            set gene [::sth::sthCore::invoke stc::get $port_hdl -children-generator]
            set gene_cfg [::sth::sthCore::invoke stc::get $gene -children-generatorconfig]
            ::sth::sthCore::invoke stc::config $gene_cfg -InterFrameGap $gap -InterFrameGapUnit BYTES
        } else {
            #set InterFrameGap 12 as default value, incase sometimes the InterFrameGap value is not proper before configing
            #(in l2vpn_loadbalance script, it throws warning msg if InterFrameGap is not provided one proper value before the traffic_config is called)
            set gene [::sth::sthCore::invoke stc::get $port_hdl -children-generator]
            set gene_cfg [::sth::sthCore::invoke stc::get $gene -children-generatorconfig]
            ::sth::sthCore::invoke stc::config $gene_cfg -InterFrameGap 12 -InterFrameGapUnit BYTES
            set gap_args "-inter_stream_gap $gap -inter_stream_gap_unit bytes"
        }
    }

    return $gap_args
}

#this function is used to get the list value for some args, eg: stream_id
proc ::wrapper::get_value_list {processed_args arg} {
    upvar next_index next_index_local
    set arg_index [expr [lsearch $processed_args $arg] + 1]
    set arg_value [lindex $processed_args $arg_index]
    set ret_value $arg_value
    #check if the value is a list value
    set arg_next_index [expr $arg_index + 1]
    for {set i $arg_next_index} {$i < [llength $processed_args]} {incr i} {
        set arg_next [lindex $processed_args $i]
        if {$arg_next!= "" && ![regexp ^- $arg_next]} {
            lappend ret_value $arg_next
        } else {
            break
        }
    }

    set next_index_local $i
    return $ret_value
}

#this function includes the common handle of ixia::traffic_config and AgtTest::traffic_config
proc ::wrapper::traffic_config_common { args } {

    array set argArray {}
    array set tempArray {}
    set streamlist_update ""
    set ::sth::sthCore::optimization 1
    set tempArray(-STCSignatureLength) 20
    set tempArray(-FCSLength) 4
    set tempArray(-ETHLength) 14
    set tempArray(-frameLengthMin) 0

    regsub mld-report $args mld_report args   ;#gre
    ::spirent::listToArray $args argArray

##version 1.01: shield
    array unset argArray -adjust_rate
    array unset argArray -data_integrity
    ##in L2L3 scripts this argument is in use. this argument is supported after HLTAPI 4.30, on which Mulcast Wrapper based
    array unset argArray -enable_auto_detect_instrumentation
    array unset argArray -enable_data_integrity
    array unset argArray -field_modifier_relation
    array unset argArray -frame_sequencing
    array unset argArray -hosts_per_net
    array unset argArray -ip_dst_mask
    array unset argArray -ip_src_mask
    array unset argArray -linked_fields
    array unset argArray -pgid_offset
    array unset argArray -sequence_num_offset
    array unset argArray -signature
    array unset argArray -signature_offset
    array unset argArray -track_by
##version 1.01: convert
    ##TODO: vlaue ranges are different!!
    if {[info exist argArray(-circuit_endpoint_type)]} {
        set argArray(-l3_protocol) $argArray(-circuit_endpoint_type)
        unset argArray(-circuit_endpoint_type)
    }
    if {[info exists argArray(-l3_protocol)] && [string equal -nocase "ipv6" $argArray(-l3_protocol)]} {
        if {[info exists argArray(-ip_src_addr)]} {
            set argArray(-ipv6_src_addr) $argArray(-ip_src_addr)
            unset argArray(-ip_src_addr)
        }
        if {[info exists argArray(-ip_dst_addr)]} {
            set argArray(-ipv6_dst_addr) $argArray(-ip_dst_addr)
            unset argArray(-ip_dst_addr)
        }
    }
    if {[info exist argArray(-global_stream_control)]} {
        set argArray(-transmit_mode) $argArray(-global_stream_control)
        unset argArray(-global_stream_control)
    }
    if {![info exists argArray(-enable_stream_only_gen)]} {
        # HLTAPI sets this to true, but it is not desirable.
        set argArray(-enable_stream_only_gen) 0
    }
    
    if {[info exist argArray(-stream_id)]} {
        if {![regexp -nocase "streamblock" $argArray(-stream_id)]} {
            set stream_id ""
            if {[regexp "(\\d+)\-(\\d+)" $argArray(-stream_id) temp start end]} {
                for {set i $start} {$i <= $end} {incr i} {
                    lappend stream_id streamblock$i
                }
            } else {
                foreach stream $argArray(-stream_id) {
                    if {[string is integer $stream]} {
                        lappend stream_id streamblock$stream
                    }
                }
            }
            set argArray(-stream_id) $stream_id
        }
    }

    if {[info exist argArray(-vlan_id)] && [string compare -nocase "modify" $argArray(-mode)]} {
        if {[info exist argArray(-vlan_id2)]} {
            set argArray(-vlan_id_outer) $argArray(-vlan_id)
            set argArray(-vlan_id) $argArray(-vlan_id2)
            unset argArray(-vlan_id2)
            if {[info exist argArray(-vlan_id_count)]} {
                set argArray(-vlan_id_outer_count) $argArray(-vlan_id_count)
                unset argArray(-vlan_id_count)
            }
            if {[info exist argArray(-vlan_id_mode)]} {
                set argArray(-vlan_id_outer_mode) $argArray(-vlan_id_mode)
                unset argArray(-vlan_id_mode)
            }
            if {[info exist argArray(-vlan_id_mode2)]} {
                set argArray(-vlan_id_mode) $argArray(-vlan_id_mode2)
                unset argArray(-vlan_id_mode2)
            }
            if {[info exist argArray(-vlan_protocol_id)]} {
                set argArray(-vlan_outer_tpid) [expr $argArray(-vlan_protocol_id)]
                unset argArray(-vlan_protocol_id)
            }
            if {[info exists argArray(-vlan_protocol_id2)]} {
                set argArray(-vlan_tpid) [expr $argArray(-vlan_protocol_id2)]
                unset argArray(-vlan_protocol_id2)
            }
        } else {
            if {[info exist argArray(-vlan_protocol_id)]} {
                set argArray(-vlan_tpid) [expr $argArray(-vlan_protocol_id)]
                unset argArray(-vlan_protocol_id)
            }
        }
    }
    if {[string equal -nocase "modify" $argArray(-mode)]} {
        if {[string is integer $argArray(-stream_id)]} {
            set streamValue streamblock$argArray(-stream_id)
        } else {
            set streamValue $argArray(-stream_id)
        }
        set temp1 [stc::get $streamValue -children-ethernet:ethernetii]
        set temp2 [stc::get $temp1 -children-vlans]
        set vlanLength [llength [stc::get $temp2 -children]]
        if {2 == $vlanLength} {
            if {[info exist argArray(-vlan_protocol_id)]} {
                set argArray(-vlan_outer_tpid) [expr $argArray(-vlan_protocol_id)]
                unset argArray(-vlan_protocol_id)
            }
            if {[info exist argArray(-vlan_protocol_id2)]} {
                set argArray(-vlan_tpid) [expr $argArray(-vlan_protocol_id2)]
                unset argArray(-vlan_protocol_id2)
            }
            if {[info exist argArray(-vlan_id_mode)]} {
                set argArray(-vlan_id_outer_mode) $argArray(-vlan_id_mode)
                unset argArray(-vlan_id_mode)
            }
            if {[info exist argArray(-vlan_id_mode2)]} {
                set argArray(-vlan_id_mode) $argArray(-vlan_id_mode2)
                unset argArray(-vlan_id_mode2)
            }
            if {[info exist argArray(-vlan_id_count)]} {
                set argArray(-vlan_id_outer_count) $argArray(-vlan_id_count)
                unset argArray(-vlan_id_count)
            }
            if {[info exist argArray(-vlan_id)]} {
                set argArray(-vlan_id_outer) $argArray(-vlan_id)
                unset argArray(-vlan_id)
            }
            if {[info exist argArray(-vlan_id2)]} {
                set argArray(-vlan_id) $argArray(-vlan_id2)
                unset argArray(-vlan_id2)
            }
        } elseif {1 == $vlanLength} {
            if {[info exist argArray(-vlan_protocol_id)]} {
                set argArray(-vlan_tpid) $argArray(-vlan_protocol_id)
                unset argArray(-vlan_protocol_id)
            }
        }
        catch {unset temp1}
        catch {unset temp2}
        catch {unset vlanLength}
        catch {unset streamValue}
    }
    set enable_pgid ""
    if {[info exist argArray(-enable_pgid)]} {
        set enable_pgid $argArray(-enable_pgid)
        unset argArray(-enable_pgid)
    }
    set pgid_value ""
    if {[info exist argArray(-pgid_value)]} {
        set pgid_value $argArray(-pgid_value)
        unset argArray(-pgid_value)
    }
    #array unset argArray -pgid_value
    ##GRE: Need to handle float number -rate_bps 200000.0
    if {[info exists argArray(-rate_bps)]} {
        regsub {\..*} $argArray(-rate_bps) {} argArray(-rate_bps)
    }
    if {[info exists argArray(-emulation_dst_handle)]} {
        #unset argArray(-emulation_dst_handle)
        # Added MJ's new code for handling a list of -emulation_dst_handle
        set ipv4grouplist ""
        foreach eachDst $argArray(-emulation_dst_handle) {
            # if pimv4config else igmphostconfig
            if [regexp pimv4groupblk $eachDst] {
                catch {
                    lappend ipv4grouplist [::sth::sthCore::invoke stc::get $eachDst -joinedgroup-Targets]
                }
            } else {
                catch {
                    if [regexp -nocase igmphostconfig [::sth::sthCore::invoke stc::get $eachDst -children]] {
                        if [regexp -nocase igmpgroupmembership [::sth::sthCore::invoke stc::get $eachDst.igmphostconfig -children]] {
                            lappend ipv4grouplist [::sth::sthCore::invoke stc::get $eachDst.igmphostconfig.igmpgroupmembership -subscribedgroups-Targets]
                        }
                    }
                }
                # Added for pim: gre test case L3VPN_Leave_Group
                catch {
                    if [regexp -nocase pimrouterconfig [::sth::sthCore::invoke stc::get $eachDst -children]] {
                        if [regexp -nocase pimv4groupblk [::sth::sthCore::invoke stc::get $eachDst.pimrouterconfig -children]] {
                            lappend ipv4grouplist [::sth::sthCore::invoke stc::get $eachDst.pimrouterconfig.pimv4groupblk -joinedgroup-Targets]
                            #::sth::sthCore::invoke stc::get router25.pimrouterconfig.pimv4groupblk -joinedgroup-Targets
                        }
                    }
                }
            }
        }
        if { $ipv4grouplist ne "" } {
            set argArray(-emulation_dst_handle) $ipv4grouplist
        }
    }
##GRE: # MGJ: ip_src_mode and ip_dst_mode are both "fixed" by default for Ixia,
       #       but "increment" for Spirent TestCenter.
    if {[info exist argArray(-l3_protocol)] && [string equal -nocase "ipv4" $argArray(-l3_protocol)] \
                    && ![info exist argArray(-ip_src_mode)] \
                    && [string equal -nocase "create" $argArray(-mode)]} {
        set argArray(-ip_src_mode) "fixed"
    }
    if {[info exist argArray(-l3_protocol)] && [string equal -nocase "ipv4" $argArray(-l3_protocol)] \
                    && ![info exist argArray(-ip_dst_mode)] \
                    && [string equal -nocase "create" $argArray(-mode)]} {
        set argArray(-ip_dst_mode) "fixed"
    }
    if {[info exists argArray(-l4_protocol)] && [info exists argArray(-l3_length)] && ($argArray(-l3_length) < 58)} {
        #set argArray(-l3_length) 70
        set argArray(-l3_length) 58
    }
    if {[info exists argArray(-vlan_id)] && [info exists argArray(-l4_protocol)] \
                    && [info exists argArray(-l3_length)] && ($argArray(-l3_length) < 75)} {
        set argArray(-l3_length) 75
    }
    if {[info exists argArray(-igmp_type)] && [string equal -nocase "membership_report" $argArray(-igmp_type)]} {
        if {[info exists argArray(-igmp_version)] && (2 == $argArray(-igmp_version))} {
            set argArray(-igmp_type) 16
        }
    }
    if {[info exists argArray(-igmp_type)]} {
        regsub {0x} $argArray(-igmp_type) {} argArray(-igmp_type)
        # argArray(-igmp_type) == 11, when query
        if {![info exists argArray(-igmp_group_addr)] && $argArray(-igmp_type) == 11} {
            set argArray(-igmp_group_addr) 0.0.0.0
        }
    }
    if {[info exists argArray(-igmp_version)] && (1 != $argArray(-igmp_version)) && [info exists argArray(-igmp_type)]} {
        if {![info exists argArray(-igmp_msg_type)] && $argArray(-igmp_type) == 11} {
            set argArray(-igmp_msg_type) query
        } else {
            if {![info exists argArray(-igmp_msg_type)]} {
                set argArray(-igmp_msg_type) report
            }
        }
    }
    if {[info exists argArray(-igmp_version)] && $argArray(-igmp_version) == 3 && [info exists argArray(-igmp_group_addr)]} {
        # when argArray(-igmp_type) != 11, not a query
        if {[info exists argArray(-igmp_type)] && $argArray(-igmp_type) != 11} {
            set argArray(-igmp_multicast_addr) $argArray(-igmp_group_addr)
            unset argArray(-igmp_group_addr)
        }
    }
    if {[info exists argArray(-l4_protocol)] && $argArray(-l4_protocol) == "udp_v6"} {
        set argArray(-l4_protocol) udp
    }
    if {[info exists argArray(-l4_protocol)] && $argArray(-l4_protocol) == "tcp_v6"} {
        set argArray(-l4_protocol) tcp
    }
    if {[info exists argArray(-l4_protocol)] && $argArray(-l4_protocol) == "icmp_v6"} {
        set argArray(-l4_protocol) icmpv6
    }
    if {[info exists argArray(-ip_router_alert)] && $argArray(-ip_router_alert) == 1} {
        set ip_router_alert $argArray(-ip_router_alert)
        set argArray(-ip_router_alert) 1
        set argArray(-ipv4_header_options) "router_alert"
        set argArray(-ipv4_router_alert) "length:4 routeralertvalue:$ip_router_alert optiontype:router_alert"
    }
    if { [info exists argArray(-ip_opt_timestamp)] } {
        # Add the timestamp IPv4 header option.
        set ip_opt_timestamp $argArray(-ip_opt_timestamp)
        unset argArray(-ip_opt_timestamp)
    } else {
        set ip_opt_timestamp 0
    }
    # added auto configue -ip_src_addr if it is not in parameter config list
    if {![info exists argArray(-emulation_src_handle)] && ![info exists argArray(-ip_src_addr)] \
                    && [string equal -nocase "create" $argArray(-mode)] && [info exists argArray(-port_handle)] \
                    && [info exist argArray(-l3_protocol)] && [string equal -nocase "ipv4" $argArray(-l3_protocol)]} {
        catch {set argArray(-ip_src_addr) [keylget ::spirent::intf_ip_addr_from_port $argArray(-port_handle)]}
    }
##all above is from version 1.01
    ##MainLine
    #disable the useStream of modifier: set enable_stream: 0
    if {[string equal -nocase "create" $argArray(-mode)] && ![info exist argArray(-l3_protocol)]} {
        ###Add default L3_protocol Per emulation_src_handle
        if {[info exist argArray(-emulation_src_handle)]} {
            # The user wants to use a bound streamblock.
            foreach emulation_src_handle $argArray(-emulation_src_handle) {
                array set resultarray [::sth::sthCore::invoke stc::perform GetObjectInfo -Object $emulation_src_handle]
                switch -- [string tolower $resultarray(-ObjectType)] {

                    ipv4prefixlsp -
                    rsvpegresstunnelparams -
                    rsvpingresstunnelparams -
                    bgpipv4routeconfig -
                    dhcpv4blockconfig -
                    ipv4networkblock -
                    ipv4routeparams -
                    routerlsa -
                    summarylsablock -
                    externallsablock -
                    asbrsummarylsa -
                    pimv4groupblk -
                    ripv4routeparams -
                    ipv4group -
                    ipv4if { set l3_protocol_val "ipv4" }

                    ipv6networkblock -
                    bgpipv6routeconfig -
                    ipv6routeparams -
                    ospfv3interareaprefixlsablk -
                    ospfv3intraareaprefixlsablk -
                    ospfv3asexternallsablock -
                    ospfv3nssalsablock -
                    ospfv3linklsablk -
                    pimv6groupblk -
                    ripngrouteparams -
                    ipv6group -
                    ipv6if { set l3_protocol_val "ipv6" }

                    host -
                    router -
                    emulateddevice {
                        # This device could be ipv4, ipv6, both or neither.
                        foreach interface [::sth::Traffic::GetTopLevelIfHandle $emulation_src_handle] {
                            array set interfacetypearray [::sth::sthCore::invoke stc::perform GetObjectInfo -Object $interface]
                            switch -- $interfacetypearray(-ObjectType) {
                                Ipv4If { set l3_protocol_val "ipv4" }
                                Ipv6If { set l3_protocol_val "ipv6" }
                            }
                        }
                    }
                    isislspconfig {
                        # We SHOULD be able to tell if it's IPv4 or IPv6 by looking at the "RoutesConfig" object.
                        set children [::sth::sthCore::invoke stc::get $emulation_src_handle -children]
                        if { [regexp -nocase {Ipv4IsisRoutesConfig} $children] } {
                            set l3_protocol_val "ipv4"
                        } elseif { [regexp -nocase {Ipv6IsisRoutesConfig} $children] } {
                            set l3_protocol_val "ipv6"
                        }
                    }
                } ;# End switch
            }
        } elseif {[info exist argArray(-ip_dst_addr)] || [info exist argArray(-ip_src_addr)]} {
            set l3_protocol_val "ipv4"
        } elseif {[info exist argArray(-ipv6_dst_addr)] || [info exist argArray(-ipv6_src_addr)]} {
            set l3_protocol_val "ipv6"
        }
        if {[info exists l3_protocol_val]} {
            set argArray(-l3_protocol) $l3_protocol_val
        }
    }
    #process the "l3_length", if there is l3_length and no length_mode is set, need to set the length_mode to be fixed,
    if {![info exist argArray(-length_mode)] \
                && ([info exist argArray(-l3_length)] || [info exist argArray(-frame_size)])} {
        set argArray(-length_mode) "fixed"
    }
    if {[info exist argArray(-l3_protocol)] && [string equal -nocase "ipv4" $argArray(-l3_protocol)]} {
        set tempArray(-IPv4Length) 20
    } elseif {[info exist argArray(-emulation_src_handle)]} {
        set tempIf [::sth::Traffic::GetTopLevelIfHandle $argArray(-emulation_src_handle)]
        if {[regexp -nocase "ipv4if" $tempIf]} {
            set tempArray(-IPv4Length) 20
        }
        unset tempIf
    }
    if {[regexp -nocase "vlan_outer_" [array names argArray]]} {
        set tempArray(-VlanLength) 8
    } elseif {[regexp -nocase "vlan_" [array names argArray]]} {
        set tempArray(-VlanLength) 4
    }
    if {[info exist argArray(-l4_protocol)]} {
        if {[string equal -nocase "tcp" $argArray(-l4_protocol)]} {
            set tempArray(-l4Length) 20
        } elseif {[string equal -nocase "udp" $argArray(-l4_protocol)]} {
            set tempArray(-l4Length) 8
        }
    }
    if {[info exist argArray(-emulation_src_handle)]} {
        foreach emulation_src_handle $argArray(-emulation_src_handle) {
            set tempIf [::sth::sthCore::invoke stc::get $emulation_src_handle -children]
            if {[regexp -nocase "greif" $tempIf]} {
                set tempArray(-greLength) 24
            }
            unset tempIf
        }
    }
    if {[info exist argArray(-frame_size_min)]} {
        incr tempArray(-frameLengthMin) [expr $tempArray(-ETHLength) + $tempArray(-STCSignatureLength) + $tempArray(-FCSLength)]
        if {[info exist tempArray(-VlanLength)]} {
            incr tempArray(-frameLengthMin) $tempArray(-VlanLength)
        }
        if {[info exist tempArray(-IPv4Length)]} {
            incr tempArray(-frameLengthMin) $tempArray(-IPv4Length)
        }
        if {[info exist tempArray(-l4Length)]} {
            incr tempArray(-frameLengthMin) $tempArray(-l4Length)
        }
        if {[info exist tempArray(-greLength)]} {
            incr tempArray(-frameLengthMin) $tempArray(-greLength)
        }
        if {$argArray(-frame_size_min) < $tempArray(-frameLengthMin)} {
            puts "\n\niWarning: Input -frame_size_min is not large enough, at least $tempArray(-frameLengthMin) is needed.\n\n"
            set argArray(-frame_size_min) $tempArray(-frameLengthMin)
        }
        if {[info exist argArray(-frame_size_max)] && ($argArray(-frame_size_max) < $tempArray(-frameLengthMin))} {
            set argArray(-frame_size_max) [expr $tempArray(-frameLengthMin) + $argArray(-frame_size_max) - $argArray(-frame_size_min)]
        }
    }

##version 1.01: for AGT
    if {[info exists argArray(-type)]} {
        if {[string equal -nocase "profile" $argArray(-type)] \
                        && [info exist argArray(-mode)] && [string equal -nocase "create" $argArray(-mode)] \
                        && [info exists argArray(-port_handle)]} {
            set result ""
            if {[info exists argArray(-single_shot_traffic)] && [info exists argArray(-rate_pps)] && [info exists argArray(-transmit_mode)]} {
                foreach my_port $argArray(-port_handle) {
                    set my_generatorconfig [::sth::sthCore::invoke stc::get [::sth::sthCore::invoke stc::get $my_port -children-generator] -children-generatorconfig]
                    ::sth::sthCore::invoke stc::config $my_generatorconfig -DurationMode $argArray(-transmit_mode)
                    ::sth::sthCore::invoke stc::config $my_generatorconfig -SchedulingMode PORT_BASED
                    ::sth::sthCore::invoke stc::config $my_generatorconfig -LoadUnit FRAMES_PER_SECOND
                    ::sth::sthCore::invoke stc::config $my_generatorconfig -FixedLoad $argArray(-rate_pps)
                    ::sth::sthCore::invoke stc::config $my_generatorconfig -BurstSize $argArray(-single_shot_traffic)
                }
                keylset result status 1
                return $result
            } else {
                set retProfile [::spirent::create_traffic_profile $argArray(-port_handle)]
                keylset result profile_handle $retProfile
                keylset result status 1
                return $result
            }
        }
        unset argArray(-type)
    }
    if {[info exists argArray(-emulation_src_handle)]} {
        set emulation_src_handle_list $argArray(-emulation_src_handle)
        
    }
    if {[info exists argArray(-emulation_dst_handle)]} {
        set emulation_dst_handle_list $argArray(-emulation_dst_handle)
    }
    set port_count 0
    if {[info exists argArray(-port_handle)]} {
        set port_handle $argArray(-port_handle)
        set port_count [llength $port_handle]
    }
    if {[info exists argArray(-profile_handle)] && [info exists argArray(-mode)] && $argArray(-mode) == "create"} {
        set argArray(-port_handle) [::spirent::get_port_from_profile $argArray(-profile_handle)]
        set a_profile $argArray(-profile_handle)
        unset argArray(-profile_handle)
        set args [array get argArray]
        set stream_id_handle ""
        set log_handle ""
        set streamblock_status 1
        if {[info exists argArray(-port_handle)] && $port_count >1} {
            set i 0
            foreach prthndl $argArray(-port_handle) {
                if {[info exists argArray(-traffic_pattern)] && [string equal -nocase $argArray(-traffic_pattern) "pair"]} {
                    set args [wrapper::shield_args -total $args -unsupported "port_handle emulation_src_handle emulation_dst_handle"]
                    set emulation_src_handle [lindex $emulation_src_handle_list $i]
                    set emulation_dst_handle [lindex $emulation_dst_handle_list $i]
                    incr i
                    set args "$args -port_handle $prthndl -emulation_src_handle $emulation_src_handle -emulation_dst_handle $emulation_dst_handle"
                } elseif {[info exists argArray(-traffic_pattern)] && [string equal -nocase $argArray(-traffic_pattern) "backbone"]} {
                    set args [wrapper::shield_args -total $args -unsupported "port_handle emulation_src_handle"]
                    set emulation_src_handle [lindex $emulation_src_handle_list $i]
                    incr i
                    set args "$args -port_handle $prthndl -emulation_src_handle $emulation_src_handle"
                } else {
                    set args "$args -port_handle $prthndl"
                }
                set cmdName "::spirent::handle_traffic_config_modifier $args"
                set args [eval $cmdName]
                set cmdName "::sth::traffic_config $args"
                set result1 [::spirent::process_cmd $cmdName]
                set status  [keylget result1 status]
                if {$status==0} {
                    set streamblock_status 0
                }
                lappend stream_id_handle  [keylget result1 stream_id]
                lappend log_handle  [keylget result1 log]
                
            }
            keylset result  stream_id $stream_id_handle
            keylset result  log       $log_handle
            keylset result  status    $streamblock_status
        } else {
            set cmdName "::spirent::handle_traffic_config_modifier $args"
            set args [eval $cmdName]
            set cmdName "::sth::traffic_config $args"
            set result [::spirent::process_cmd $cmdName]
        }
    
        
        if [keylget result status] {
            ::spirent::add_streamblock $a_profile [keylget result stream_id]
        }
        return $result
    }
    if {[info exists argArray(-profile_handle)] && [info exists argArray(-mode)] && $argArray(-mode) == "modify" && [info exists argArray(-rate_pps)]} {
        set result {}
        keylset result status 0
        set streamblocks [::spirent::get_streamblock_from_profile $argArray(-profile_handle)]
        set number_of_streamblocks [llength $streamblocks]
        if {$number_of_streamblocks > 0} {
            set rate [expr $argArray(-rate_pps)/$number_of_streamblocks]
            foreach a_streamblock $streamblocks {
                set cmdName "::sth::traffic_config -mode modify -stream_id $a_streamblock -rate_pps $rate"
                ::spirent::process_cmd $cmdName
            }
            keylset result status 1
        }
        return $result
    }
    if {[info exists argArray(-l4_protocol)] && $argArray(-l4_protocol) == "pim"} {
        unset argArray(-l4_protocol)
        set args [array get argArray]
        set stream_id_handle ""
        set log_handle ""
        set streamblock_status 1
        if {[info exists argArray(-port_handle)] && $port_count >1} {
            set i 0
            foreach prthndl $argArray(-port_handle) {
                if {[info exists argArray(-traffic_pattern)] && [string equal -nocase $argArray(-traffic_pattern) "pair"]} {
                    set args [wrapper::shield_args -total $args -unsupported "port_handle emulation_src_handle emulation_dst_handle"]
                    set emulation_src_handle [lindex $emulation_src_handle_list $i]
                    set emulation_dst_handle [lindex $emulation_dst_handle_list $i]
                    incr i
                    set args "$args -port_handle $prthndl -emulation_src_handle $emulation_src_handle -emulation_dst_handle $emulation_dst_handle"
                } elseif {[info exists argArray(-traffic_pattern)] && [string equal -nocase $argArray(-traffic_pattern) "backbone"]} {
                    set args [wrapper::shield_args -total $args -unsupported "port_handle emulation_src_handle"]
                    set emulation_src_handle [lindex $emulation_src_handle_list $i]
                    incr i
                    set args "$args -port_handle $prthndl -emulation_src_handle $emulation_src_handle"
                } else {
                    set args "$args -port_handle $prthndl"
                }
                set cmdName "::spirent::handle_traffic_config_modifier $args"
                set args [eval $cmdName]
                set cmdName "::sth::traffic_config $args"
                set result1 [::spirent::process_cmd $cmdName]
                set status  [keylget result1 status]
                if {$status==0} {
                    set streamblock_status 0
                }
                lappend stream_id_handle  [keylget result1 stream_id]
                lappend log_handle  [keylget result1 log]
                
            }
            keylset result  stream_id $stream_id_handle
            keylset result  log       $log_handle
            keylset result  status    $streamblock_status
        } else {
            set cmdName "::spirent::handle_traffic_config_modifier $args"
            set args [eval $cmdName]
            set cmdName "::sth::traffic_config $args"
            set result [::spirent::process_cmd $cmdName]
        }
        
        if {![keylget result status]} {
            return $result
        }
        set my_stream_id [keylget result stream_id]
        ::spirent::add_l4_protocol_pim_hello -stream_id $my_stream_id
        return [list [list stream_id $my_stream_id] [list status 1]]
    }
    if {[info exists argArray(-icmp_v6_multicast_address_record_count)]} {
        set numberOfGroupRecords $argArray(-icmp_v6_multicast_address_record_count)
        unset argArray(-icmp_v6_multicast_address_record_count)
    } else {
        set numberOfGroupRecords 0
    }
    if {[info exists argArray(-icmp_v6_multicast_src_list)]} {
        set icmp_v6_multicast_src_list $argArray(-icmp_v6_multicast_src_list)
        unset argArray(-icmp_v6_multicast_src_list)
        set multicastSrcCount [llength $icmp_v6_multicast_src_list]
    } else {
        set icmp_v6_multicast_src_list {}
        set multicastSrcCount 0
    }
    if {[info exists argArray(-icmp_v6_message_type)] && $argArray(-icmp_v6_message_type) == "mld_report"} {
        unset argArray(-icmp_v6_message_type)
        #set argArray(-icmp_type) 143
        set args [array get argArray]
        set stream_id_handle ""
        set log_handle ""
        set streamblock_status 1
        if {[info exists argArray(-port_handle)] && $port_count >1} {
            set i 0
            foreach prthndl $argArray(-port_handle) {
                if {[info exists argArray(-traffic_pattern)] && [string equal -nocase $argArray(-traffic_pattern) "pair"]} {
                    set args [wrapper::shield_args -total $args -unsupported "port_handle emulation_src_handle emulation_dst_handle"]
                    set emulation_src_handle [lindex $emulation_src_handle_list $i]
                    set emulation_dst_handle [lindex $emulation_dst_handle_list $i]
                    incr i
                    set args "$args -port_handle $prthndl -emulation_src_handle $emulation_src_handle -emulation_dst_handle $emulation_dst_handle"
                } elseif {[info exists argArray(-traffic_pattern)] && [string equal -nocase $argArray(-traffic_pattern) "backbone"]} {
                    set args [wrapper::shield_args -total $args -unsupported "port_handle emulation_src_handle"]
                    set emulation_src_handle [lindex $emulation_src_handle_list $i]
                    incr i
                    set args "$args -port_handle $prthndl -emulation_src_handle $emulation_src_handle"
                } else {
                    set args "$args -port_handle $prthndl"
                }
                set cmdName "::spirent::handle_traffic_config_modifier $args"
                set args [eval $cmdName]
                set cmdName "::sth::traffic_config $args"
                set result1 [::spirent::process_cmd $cmdName]
                set status  [keylget result1 status]
                if {$status==0} {
                    set streamblock_status 0
                }
                lappend stream_id_handle  [keylget result1 stream_id]
                lappend log_handle  [keylget result1 log]
                
            }
            keylset result  stream_id $stream_id_handle
            keylset result  log       $log_handle
            keylset result  status    $streamblock_status
        } else {
            set cmdName "::spirent::handle_traffic_config_modifier $args"
            set args [eval $cmdName]
            set cmdName "::sth::traffic_config $args"
            set result [::spirent::process_cmd $cmdName]
        }
        if {![keylget result status]} {
            return $result
        }
        set my_stream_id [keylget result stream_id]
        set mldv2reportObj [::sth::sthCore::invoke stc::create icmpv6:MLDv2Report -under $my_stream_id]
        if {$numberOfGroupRecords != 0} {
            ::sth::sthCore::invoke stc::config $mldv2reportObj -numGrpRecords $numberOfGroupRecords
        }
        for {set j 0} {$j < $numberOfGroupRecords} {incr j} {
            set grprecordsObj($j) [::sth::sthCore::invoke stc::create grprecords -under $mldv2reportObj]
            set mldv2grouprecordObj($j) [::sth::sthCore::invoke stc::create mldv2grouprecord -under $grprecordsObj($j)]
            if {[info exists argArray(-ipv6_dst_addr)]} {
                ::sth::sthCore::invoke stc::config $mldv2grouprecordObj($j) -mcastAddr $argArray(-ipv6_dst_addr)
            }
            ::sth::sthCore::invoke stc::config $mldv2grouprecordObj($j) -numSource $multicastSrcCount
            set addrlistObj($j) [::sth::sthCore::invoke stc::create addrlist -under $mldv2grouprecordObj($j)]
            foreach ipv6SrcAddress $icmp_v6_multicast_src_list {
                set ipv6addrObj($j) [::sth::sthCore::invoke stc::create ipv6addr -under $addrlistObj($j)]
                ::sth::sthCore::invoke stc::config $ipv6addrObj($j) -value $ipv6SrcAddress
            }
        }
        return [list [list stream_id $my_stream_id] [list status 1]]
    }
##version 1.01 end

    if {[string equal -nocase "create" $argArray(-mode)] || [string equal -nocase "modify" $argArray(-mode)]} {
        ##need to check if the ip step value is greater than 0:0:0:0:ffff:ffff:ffff:ffff, becasue the step value's maximum size is 4 #bytes if enable_stream = 0
        foreach eachStep {-ipv6_dst_step -ipv6_src_step} {
            if {[info exist argArray($eachStep)]} {
                set normaized_step_value [::sth::sthCore::normalizeIPv6Addr $argArray($eachStep)]
                set normaized_step_value_list [split $normaized_step_value :]
                for {set i 7} {$i >= 0} {incr i -1} {
                    set step [lindex $normaized_step_value_list $i]
                    if {![regexp $step "0000"]} {
                        if {$i == 0} {
                            set mask [lreplace $normaized_step_value_list $i $i ffff]
                        } else {
                            set mask [lreplace $normaized_step_value_list [expr $i -1] $i ffff ffff]
                        }
                    }
                }
                set mask [join $mask :]
                set tempValue [regsub {_step} $eachStep {prefix}]
                set argArray($tempValue) $mask
            }
        }
        catch {unset tempValue}
        ##stream_id default value is 1 in HLTAPI, but there 32768 limitation when it is set to 1, GUI default value is 0
        ##so, change it to 0 is possible and better
        ##here is another limitation, when it is set to 0, all step attribute should be a power of 2
        if {![info exist argArray(-enable_stream)]} {
            set argArray(-enable_stream) 0
            set total_bytes 0
            foreach argName "-ipv6_dst_step -ipv6_src_step -mac_src_step -mac_dst_step \
                            -ip_dst_step -ip_src_step" {
                set tempValue 0
                if {(0 == $argArray(-enable_stream)) && [info exist argArray($argName)]} {
                    if {[regexp {[.|\-|:]} $argArray($argName)]} {
                        set tempval $argArray($argName)
                        set tempval [regsub -all "::" $tempval ":"]
                        set splitdata [split $tempval ".|\-|:"]
                        set splitdatalen [expr [llength $splitdata] - 1]
                        for {set i $splitdatalen} {$i >= 0} {incr i -1} {
                            if {[lindex $splitdata $i] != 0} {
                                set tempValue [lindex $splitdata $i]
                                break
                            }
                        }
                        if {$argName == "-ip_dst_step" || $argName == "-ip_src_step"} {
                            set tempValue [format %x $tempValue]
                        }
                    } else {
                        set tempValue [format %x $argArray($argName)]
                    }
                    if {0 != [expr 0x$tempValue & 0x$tempValue - 1]} {
                        set argArray(-enable_stream) 1
                    }
                    catch {unset tempValue}
                }
            }
            if {(0 == $argArray(-enable_stream)) && [info exist argArray(-vlan_id_step)] \
                        && (0 != [expr $argArray(-vlan_id_step) & $argArray(-vlan_id_step)-1])} {
                set argArray(-enable_stream) 1
            }
        }
    }

    #process the "-stream_id" in create mode, ixia supports the config an integer as -stream_id in create mode, no need to support it in hltapi
    if {[info exist argArray(-stream_id)]} {
        #if it is create mode, unset -stream_id
        if {[string equal -nocase "create" $argArray(-mode)]} {
            unset argArray(-stream_id)
        } else {
            foreach eachStream $argArray(-stream_id) {
                if {[string is integer $eachStream]} {
                    lappend tempList streamblock$eachStream
                } else {
                    lappend tempList $eachStream
                }
            }
            set argArray(-stream_id) $tempList
        }
    }

    #if mac_src doesn't exist, set mac_src value based on src_ip, and also set mac_dst_mode as discovery to update the mac dest address
    if {![info exist argArray(-mac_src)] && ![info exist argArray(-mac_dst)] && [string equal -nocase "create" $argArray(-mode)]} {
        if {[info exist argArray(-ip_src_addr)]} {
            set argArray(-mac_src) [::wrapper::get_mac_with_ip $argArray(-ip_src_addr) $argArray(-port_handle)]
        }
        if {[info exist argArray(-ipv6_src_addr)]} {
            set argArray(-mac_src) [::wrapper::get_mac_with_ip $argArray(-ipv6_src_addr) $argArray(-port_handle)]
        }
        if {[info exist argArray(-bidirectional)] && (1 == $argArray(-bidirectional)) \
                        && ![info exist argArray(-mac_src2)] && ![info exist argArray(-mac_dst2)]} {
            if {[info exist argArray(-ip_dst_addr)]} {
                set argArray(-mac_src2) [::wrapper::get_mac_with_ip $argArray(-ip_dst_addr) $argArray(-port_handle2)]
            }
            if {[info exist argArray(-ipv6_dst_addr)]} {
                set argArray(-mac_src2) [::wrapper::get_mac_with_ip $argArray(-ipv6_dst_addr) $argArray(-port_handle2)]
            }
        }
    }

    #process the "discovery" of mac_dst_mode =>EnableResolveDestMacAddress: true and do the ARP for the streamblock
    #EnableResolveDestMacAddress has the default value TRUE, so we need to do the ARP for the streamblock to make it have the correct mad_dst_addr
    if {[info exist argArray(-mac_dst_mode)] && [string equal -nocase "discovery" $argArray(-mac_dst_mode)]} {
        array unset argArray -mac_dst_count
    }

    #*******************solve the packets count is one more: pre handle: use to get the existing streamblock before creating streamblock**********************
    if {[info exist argArray(-port_handle)]} {
        foreach  port_handle $argArray(-port_handle) {
            lappend exited_streamblklist [::sth::sthCore::invoke stc::get $port_handle -children-streamblock]
        }
        #set exited_streamblklist [::sth::sthCore::invoke stc::get $argArray(-port_handle) -children-streamblock]
    
    }

    #if the l4_protocol is specified to tcp, if there are udp_src_port and udp_dst_port, need to remove them
    if {[info exist argArray(-l4_protocol)] && [string equal -nocase "tcp" $argArray(-l4_protocol)]} {
        array unset argArray -udp_src_port
        array unset argArray -udp_dst_port
    }
    set processed_args [wrapper::shield_args -total $args]
    #process the ipv6_hop_by_hop_options, it should be a keyedlist.
    if {[info exist argArray(-ipv6_hop_by_hop_options)]} {
        set ipv6_hop_by_hop_options_value [::wrapper::get_value_list $processed_args "-ipv6_hop_by_hop_options"]
        set ipv6_hop_by_hop_options_list ""
        foreach arg {type length value payload alert_type} {
            if {[lsearch $ipv6_hop_by_hop_options_value $arg] > -1} {
                set arg_value [lindex $ipv6_hop_by_hop_options_value [expr [lsearch $ipv6_hop_by_hop_options_value $arg] + 1]]
                if {$arg == "value"} {
                    #change the value from bit to hex
                    regsub -all {:|\.} $arg_value "" arg_value
                    set arg_value [::sth::sthCore::binToHex $arg_value]
                }
                set ipv6_hop_by_hop_options_list [concat $ipv6_hop_by_hop_options_list "$arg: $arg_value"]
            }
        }
        set argArray(-ipv6_hop_by_hop_options) $ipv6_hop_by_hop_options_list
    }

    ##################add legacy args for ipv4 modify
    if {[info exist argArray(-l3_protocol)] && [string equal -nocase "ipv4" $argArray(-l3_protocol)] \
                    && [string equal -nocase "modify" $argArray(-mode)] \
                    && [info exist argArray(-stream_id)]} {
        set stream_id $argArray(-stream_id)
        regsub -all "streamblock" $stream_id "" stream_id
        if {[info exists ::spirent::stream_ipv4_config($stream_id)]} {
            set argList $::spirent::stream_ipv4_config($stream_id)
            foreach eachValue $::spirent::StreamArgList {
                if {[info exist argArray(-$eachValue)]} {
                    set argList [wrapper::shield_args -total $argList -unsupported "$eachValue"]
                }
            }
            catch {unset eachValue}
            set tempArgs [array get argArray]
            lappend tempArgs $argList
            ::spirent::listToArray $tempArgs argArray
        }
    }

        if {[info exist argArray(-ip_dst_mode)] && [string equal -nocase "ipv6" $argArray(-l3_protocol)] \
                    && [info exist argArray(-ip_src_mode)]} {
	    set argArray(-ipv6_dst_mode) $argArray(-ip_dst_mode)
	    array unset argArray -ip_dst_mode
	    set argArray(-ipv6_src_mode) $argArray(-ip_src_mode)
	    array unset argArray -ip_src_mode
        }

    #all the same function whose name space is sth::
    set tempArgs [array get argArray]
    set stream_id_handle ""
    set log_handle ""
    set streamblock_status 1
    if {[info exists argArray(-port_handle)] && $port_count >1} {
        set i 0
        foreach prthndl $argArray(-port_handle) {
            if {[info exists argArray(-traffic_pattern)] && [string equal -nocase $argArray(-traffic_pattern) "pair"]} {
                set tempArgs [wrapper::shield_args -total $tempArgs -unsupported "port_handle emulation_src_handle emulation_dst_handle"]
                set emulation_src_handle [lindex $emulation_src_handle_list $i]
                set emulation_dst_handle [lindex $emulation_dst_handle_list $i]
                incr i
                set tempArgs "$tempArgs -port_handle $prthndl -emulation_src_handle $emulation_src_handle -emulation_dst_handle $emulation_dst_handle"
            } elseif {[info exists argArray(-traffic_pattern)] && [string equal -nocase $argArray(-traffic_pattern) "backbone"]} {
                set tempArgs [wrapper::shield_args -total $tempArgs -unsupported "port_handle emulation_src_handle"]
                set emulation_src_handle [lindex $emulation_src_handle_list $i]
                incr i
                set tempArgs "$tempArgs -port_handle $prthndl -emulation_src_handle $emulation_src_handle"
            } else {
                set tempArgs "$tempArgs -port_handle $prthndl"
            }
            set cmdName "::spirent::handle_traffic_config_modifier $tempArgs"
            set tempArgs [eval $cmdName]
            set cmdName "::sth::traffic_config $tempArgs"
            set ret1 [::spirent::process_cmd $cmdName]
            set status  [keylget ret1 status]
            if {$status==0} {
                set streamblock_status 0
            }
            lappend stream_id_handle [keylget ret1 stream_id]
            lappend log_handle  [keylget ret1 log]
            
        }
        keylset ret  stream_id $stream_id_handle
        keylset ret  log       $log_handle
        keylset ret  status    $streamblock_status
    } else {
        set cmdName "::spirent::handle_traffic_config_modifier $tempArgs"
        set tempArgs [eval $cmdName]
        set cmdName "::sth::traffic_config $tempArgs"
        set ret [::spirent::process_cmd $cmdName]
    }
    
    if {($enable_pgid ne "")&& $enable_pgid } {
        set stremblock [keylget ret stream_id]
        set group $pgid_value
        # check to see if collection exists and add it otherwise
        set  coll_found 0
        set  h_grp "" 
        set  pl [::sth::sthCore::invoke stc::get project1 -children-groupcollection]
        if {$pl ne ""} {
            foreach  h_coll $pl {
                set collname [::sth::sthCore::invoke stc::get $h_coll -groupname]
                if {$collname eq $group} {
                    set coll_found 1
                    # now check for the group
                    set grp_found 0
                    set  gl [::sth::sthCore::invoke stc::get $h_coll -children-trafficgroup]
                    if {$gl ne ""} {
                        foreach  grp $gl {
                            set grpname [::sth::sthCore::invoke stc::get $grp -groupname]
                            if {$grpname eq $group} {
                                set grp_found 1
                                set h_grp $grp
                                break
                            }
                        }
                        if {!$grp_found} {
                            set h_grp [::sth::sthCore::invoke stc::create trafficgroup -under $h_coll -groupname $group]
                            break
                        }
                    }
                }
            }
        }

        # if the collection isn't there add it and the group
        if {!$coll_found} {
            set h_coll2 [::sth::sthCore::invoke stc::create groupcollection -under project1 -groupname $group]
            set h_grp [::sth::sthCore::invoke stc::create trafficgroup -under $h_coll2 -groupname $group]
        }

        set sb_found 0
        set sbl [::sth::sthCore::invoke stc::get $h_grp -AffiliationTrafficGroup-targets]
        if {$sbl ne ""} {
            foreach  sb $sbl {
                if {$sb eq $stremblock} {
                   set sb_found 1
                   break
                }
            }
            if {!$sb_found} {
                set sbarr [split(/ +/, $sbl]
                lappend $sbarr $stremblock
                ::sth::sthCore::invoke stc::config $h_grp -affiliationtrafficgroup-targets $sbarr
            }
        } else {
            ::sth::sthCore::invoke stc::config $h_grp -affiliationtrafficgroup-targets $stremblock 
        }
    }

    #if the mac_dst_mode is discovery, the Destination MAC will match the MAC address received from the ARP request.
    #although in stc gui, we can't see the mac_dst_addr changes, the captured packets will have the resolved mac_dst_addr
    #Do ARP here and set the variable ::sth::Session::PORTLEVELARPDONE($porthnd) as 1
    #To do ARP successfully, still need to config the -mac_discovery_gw using the gateway of the device created in interface_config
    if {![info exist argArray(-l3_protocol)]} {
        set argArray(-l3_protocol) "ipv4"
    }

    if {[string equal -nocase "create" $argArray(-mode)] && [info exist argArray(-port_handle)]} {
        set device1 [::sth::sthCore::invoke stc::get $argArray(-port_handle) -AffiliationPort-sources]
        set devicelist ""
        #if there is more than one device under the streamblock, it's better to use the streamblock's src ip to filter which device is the bound one
        #currently, only check the route ip of bgp, maybe some enhancements are needed in the furture
        if {[llength $device1] > 0 && [info exist argArray(-ip_src_addr)]} {
            foreach device $device1 {
                foreach route_ip [::wrapper::get_bgp_route_ip $device] {
                    if {$route_ip == $argArray(-ip_src_addr)} {
                        lappend devicelist $device
                        break
                    }
                }
            }
        }
        if {"" == $devicelist} {
            set devicelist $device1
        }
        set gw_flag 0
        foreach device $devicelist {
            set ipif1 [lindex [::sth::sthCore::invoke stc::get $device -children-$argArray(-l3_protocol)\if] 0]
            if {"" != $ipif1} {
                set gateway1 [::sth::sthCore::invoke stc::get $ipif1 -Gateway]
                if {![regexp {192\.85\.1\.1} $gateway1]} {
                    if {[info exist argArray(-port_handle2)]} {
                        #if the -bidirectional = 0, then port_handle2 will be removed from $processed_args
                        set strblk_hdl [keylget ret stream_id.$argArray(-port_handle)]
                    } else {
                        set strblk_hdl [keylget ret stream_id]
                    }
                    set ipheader [::sth::sthCore::invoke stc::get $strblk_hdl -children-$argArray(-l3_protocol):$argArray(-l3_protocol)]
                    if {"" != $ipheader} {
                        set sbipadd1 [::sth::sthCore::invoke stc::get [lindex $ipheader 0] -sourceAddr]
                        set deviceipadd1 [::sth::sthCore::invoke stc::get $ipif1 -Address]
                        if {$sbipadd1 eq $deviceipadd1} {
                            ::sth::sthCore::invoke stc::config [lindex $ipheader 0] -gateway $gateway1
                            set gw_flag 1
                            break
                        }
                    }
                }
            }
        }
        if {$gw_flag == 0} {
            foreach device $devicelist {
                set ipif1 [lindex [::sth::sthCore::invoke stc::get $device -children-$argArray(-l3_protocol)\if] 0]
                if {"" != $ipif1} {
                    set gateway1 [::sth::sthCore::invoke stc::get $ipif1 -Gateway]
                    if {![regexp {192\.85\.1\.1} $gateway1]} {
                        if {[info exist argArray(-port_handle2)]} {
                            #if the -bidirectional = 0, then port_handle2 will be removed from $processed_args
                            set strblk_hdl [keylget ret stream_id.$argArray(-port_handle)]
                        } else {
                            set strblk_hdl [keylget ret stream_id]
                        }
                        set ipheader [::sth::sthCore::invoke stc::get $strblk_hdl -children-$argArray(-l3_protocol):$argArray(-l3_protocol)]
                        if {"" != $ipheader} {
                            ::sth::sthCore::invoke stc::config [lindex $ipheader 0] -gateway $gateway1
                        }
                        break
                    }
                }
            }
        }
    }
    if {[string equal -nocase "create" $argArray(-mode)] && [info exist argArray(-port_handle2)]} {
        set device2 [::sth::sthCore::invoke stc::get $argArray(-port_handle2) -AffiliationPort-sources]
        set devicelist ""
        #if there is more than one device under the streamblock, it's better to use the streamblock's src ip to filter which device is the bound one
        if {[llength $device2] > 0 && [info exist argArray(-ip_dst_addr)]} {
            foreach device $device2 {
                foreach route_ip [::wrapper::get_bgp_route_ip $device] {
                    if {$route_ip == $argArray(-ip_dst_addr)} {
                        lappend devicelist $device
                        break
                    }
                }
            }
        }
        if {"" == $devicelist} {
            set devicelist $device2
        }
        set gw_flag 0
        foreach device $devicelist {
            set ipif2 [lindex [::sth::sthCore::invoke stc::get $device -children-$argArray(-l3_protocol)\if] 0]
            if {"" != $ipif2} {
                set gateway2 [::sth::sthCore::invoke stc::get $ipif2 -Gateway]
                if {![regexp {192\.85\.1\.1} $gateway2]} {
                    set strblk_hdl [keylget ret stream_id.$argArray(-port_handle2)]
                    set ipheader [::sth::sthCore::invoke stc::get $strblk_hdl -children-$argArray(-l3_protocol):$argArray(-l3_protocol)]
                    if {"" != $ipheader} {
                        set sbipadd2 [::sth::sthCore::invoke stc::get [lindex $ipheader 0] -sourceAddr]
                        set deviceipadd2 [::sth::sthCore::invoke stc::get $ipif2 -Address]
                        if {$sbipadd2 eq $deviceipadd2} {
                            ::sth::sthCore::invoke stc::config [lindex $ipheader 0] -gateway $gateway2
                            set gw_flag 1
                            break
                        }
                    }
                }
            }
        }
        if {$gw_flag == 0} { 
            foreach device $devicelist {
	            set ipif2 [lindex [::sth::sthCore::invoke stc::get $device -children-$argArray(-l3_protocol)\if] 0]
	            if {"" != $ipif2} {
	                set gateway2 [::sth::sthCore::invoke stc::get $ipif2 -Gateway]
	                if {![regexp {192\.85\.1\.1} $gateway2]} {
	                    set strblk_hdl [keylget ret stream_id.$argArray(-port_handle2)]
	                    set ipheader [::sth::sthCore::invoke stc::get $strblk_hdl -children-$argArray(-l3_protocol):$argArray(-l3_protocol)]
	                    if {"" != $ipheader} {
	                    	::sth::sthCore::invoke stc::config [lindex $ipheader 0] -gateway $gateway2
	                    }
                        break
	                }
	            }
	        }
        }
    }


    #*******************solve the packets count is one more begin**********************

    if {[info exist argArray(-stream_id)]} {
        set port_hdl [::sth::sthCore::invoke stc::get $argArray(-stream_id) -parent]
        set new_created_strblk $argArray(-stream_id)
        set update_streamblklist [::sth::sthCore::invoke stc::get $port_hdl -children-streamblock]
    } elseif {[info exist exited_streamblklist]} {
        set update_streamblklist [::sth::sthCore::invoke stc::get $argArray(-port_handle) -children-streamblock]
        if {[regexp "\{" $exited_streamblklist] && [regexp "\}" $exited_streamblklist]} {
            regsub "\{" $exited_streamblklist "" exited_streamblklist
            regsub "\}" $exited_streamblklist "" exited_streamblklist
        }
        regsub "$exited_streamblklist" $update_streamblklist "" new_created_strblk
    }
    if {[info exist argArray(-port_handle)]} {
        set generator [::sth::sthCore::invoke stc::get $argArray(-port_handle) -children-generator]
        set generator_cfg [::sth::sthCore::invoke stc::get $generator -children-GeneratorConfig]
        set sche_mode [::sth::sthCore::invoke stc::get $generator_cfg -SchedulingMode]
        set pkts_per_burst [::sth::sthCore::invoke stc::get $generator_cfg -burstsize]
        if {[regexp -nocase "PRIORITY_BASED" $sche_mode]} {
            # if it is priority based, then it means more than one streamblocks under this port, then we can set the burstsize = rate  of each streamblock
            foreach stream $new_created_strblk {
                set strblkloadprofile [::sth::sthCore::invoke stc::get $stream -AffiliationStreamBlockLoadProfile-targets]
                set ifg [::sth::sthCore::invoke stc::get $generator_cfg -InterFrameGap]
                set rate [::sth::sthCore::invoke stc::get $strblkloadprofile -load]
                if {$rate > $pkts_per_burst} {
                    set burstsize $pkts_per_burst
                } else {
                    #remove the 0 at the end of the variable
                    set burstsize [regsub -all "0+$" $rate ""]
                }
                if {$burstsize > 65535} {
                    set burstsize 1
                }
                set arglist "-BurstSize $burstsize -InterFrameGap $ifg"
                ::sth::sthCore::invoke stc::config $strblkloadprofile $arglist
            }
        }
    }
    #*******************solve the packets count is one more end**********************

    #store the pkts_per_bursts for each stream
    if {$::spirent::pkts_per_burst > 0 } {
        set pkts_per_burst $::spirent::pkts_per_burst
        if {[string compare -nocase "modify" $argArray(-mode)] && [info exist argArray(-port_handle)]} {
            ##only for the situation that string_id is not a list
            if {[info exist argArray(-bidirectional)] && (1 == $argArray(-bidirectional))} {
                set stream_id [keylget ret stream_id.$argArray(-port_handle)]
            } else {
                set stream_id [keylget ret stream_id]
            }

            keylset ::spirent::pkts_per_burst_list $stream_id $::spirent::pkts_per_burst
        }
        if {[string equal -nocase "modify" $argArray(-mode)] && [info exist argArray(-stream_id)]} {
            if {[string is integer $argArray(-stream_id)]} {
                set stream_id streamblock$argArray(-stream_id)
            } else {
                set stream_id $argArray(-stream_id)
            }
            keylset ::spirent::pkts_per_burst_list $stream_id $::spirent::pkts_per_burst
        }
        if {[info exist argArray(-bidirectional)] && (1 == $argArray(-bidirectional)) && [info exist argArray(-port_handle2)]} {
            set stream_id [keylget ret stream_id.$argArray(-port_handle2)]
            keylset ::spirent::pkts_per_burst_list $stream_id $::spirent::pkts_per_burst
        }
    }
    #call ::sth::sthCore::invoke stc::apply here, because the optimaztion is set to 1 earlier
    ::sth::sthCore::invoke stc::apply

    if { $ip_opt_timestamp } {
        if { [info exists argArray(-mode)] && [string match -nocase $argArray(-mode) "create"] } {
            set streamblocklist [keylget ret stream_id]
        } else {
            set streamblocklist $argArray(-stream_id)
        }
        # This code adds the IPv4 timestamp header.
        foreach streamblock $streamblocklist {

            # Make sure an IPv4 header exists.
            set ipv4pdu [::sth::sthCore::invoke stc::get $streamblock -children-ipv4:IPv4]
            if { $ipv4pdu ne "" } {
                set options [::sth::sthCore::invoke stc::get $ipv4pdu -children-options]
                if { $options  eq "" } {
                    set options [::sth::sthCore::invoke stc::create options -under $ipv4pdu]
                }
                set ipv4options [::sth::sthCore::invoke stc::get $options -children-IPv4HeaderOption]
                if { $ipv4options eq "" } {
                    set ipv4options [::sth::sthCore::invoke stc::create IPv4HeaderOption -under $options]
                }

                set timestamp [::sth::sthCore::invoke stc::get $ipv4options -children-timestamp]
                if { $timestamp eq "" } {
                    ::sth::sthCore::invoke stc::create timestamp -under $ipv4options
                }
                ::sth::sthCore::invoke stc::apply
            }
        }
    } ;
##1.02 END
    set result [regsub -nocase -all "streamblock"  $ret ""]
    set ::sth::sthCore::optimization 0
    global return_list
    set return_list $result
    return $result
}

proc ::wrapper::get_mac_with_ip {ip port_handle} {
    set mac_addr "0010.9400.0002"
    #format the ip address
    if {[::ip::is ipv6 $ip]} {
        set ip [::sth::sthCore::normalizeIPv6Addr $ip]
    }
    set device_list [::sth::sthCore::invoke stc::get $port_handle -AffiliationPort-sources]
    foreach device $device_list {
        if {[::ip::is ipv4 $ip]} {
                set ipv4if [::sth::sthCore::invoke stc::get $device -children-ipv4if]
                if {$ipv4if == ""} {
                        #no ipv4 under this device
                        continue
                }
                #if there is ipv4, then check if the ipv4 is the same with the ip input
                set ipv4 [::sth::sthCore::invoke stc::get $ipv4if -Address]
                if {$ipv4 == $ip} {
                        set ethiiif [::sth::sthCore::invoke stc::get $device -children-EthIIIf]
                        set mac_addr [::sth::sthCore::invoke stc::get $ethiiif -SourceMac]
                        return $mac_addr
                }
        } else {
                set ipv6if [::sth::sthCore::invoke stc::get $device -children-ipv6if]
                if {$ipv6if == ""} {
                        #no ipv6 under this device
                        continue
                }
                #if there is ipv6, then check if the ipv6 is the same with the ip input
                set ipv6 [::sth::sthCore::invoke stc::get [lindex $ipv6if 0] -Address]
                #format the ipv6
                set ipv6 [::sth::sthCore::normalizeIPv6Addr $ipv6]
                if {$ipv6 == $ip} {
                        set ethiiif [::sth::sthCore::invoke stc::get $device -children-EthIIIf]
                        set mac_addr [::sth::sthCore::invoke stc::get $ethiiif -SourceMac]
                        return $mac_addr
                }
            }
    }
    return $mac_addr
}

##This is legacy function to find the device with same IP
##this function has been replaced by get_device_with_ip_new
proc ::wrapper::get_device_with_ip {ip port_handle} {
    set device_ret ""

    set device_list [::sth::sthCore::invoke stc::get $port_handle -AffiliationPort-sources]
    if {[::ip::is ipv6 $ip]} {
        set ip [::sth::sthCore::normalizeIPv6Addr $ip]
        foreach device $device_list {
            set ipv6if [::sth::sthCore::invoke stc::get $device -children-ipv6if]
            if {"" != $ipv6if} {
                set ipv6 [::sth::sthCore::invoke stc::get [lindex $ipv6if 0] -Address]
                set ipv6 [::sth::sthCore::normalizeIPv6Addr $ipv6]
                if {$ipv6 == $ip} {
                    set device_ret  $device
                    break
                }
            }
        }
    } elseif {[::ip::is ipv4 $ip]} {
        foreach device $device_list {
            set ipv4if [::sth::sthCore::invoke stc::get $device -children-ipv4if]
            if {"" != $ipv4if} {
                set ipv4 [::sth::sthCore::invoke stc::get $ipv4if -Address]
                if {$ipv4 == $ip} {
                    set device_ret  $device
                    break
                }
            }
        }
    } else {
        return -code error "input ip address is not an ipv4 address or an ipv6 address"
    }
    if {$device_ret ne ""} {
        ::sth::sthCore::invoke stc::config $device_ret -DeviceCount 1
    }
    return $device_ret
}

##This is new function to find the device with same IP
##address then reuse it with other protocols
##It use the global array ::spirent::ip_device
proc ::wrapper::get_device_with_ip_new {ip port} {
    set device_ret ""
    if {[::ip::is ipv6 $ip]} {
        set ip [::sth::sthCore::normalizeIPv6Addr $ip]
    }
    
    if {[catch {
        if {[info exists ::spirent::ip_device($ip)] && ($port == [::sth::sthCore::invoke stc::get $::spirent::ip_device($ip) -affiliationport-Targets])} {
            set device_ret $::spirent::ip_device($ip)
            ::sth::sthCore::invoke stc::config $device_ret -DeviceCount 1
        }
    }]} {
        set device_ret ""       
    }

    return $device_ret
}

########################################
#this funtion is used to get the startiplist of bgp route
proc ::wrapper::get_bgp_route_ip {device} {
    set ip_ret ""
    set bgpRouterCfg [::sth::sthCore::invoke stc::get $device -children-BgpRouterConfig]
    if {$bgpRouterCfg != ""} {
        #only support ipv4 currently
        set bgpRouteCfgList [::sth::sthCore::invoke stc::get $bgpRouterCfg -children-BgpIpv4RouteConfig]
        if {$bgpRouteCfgList != ""} {
            foreach bgpRouteCfg $bgpRouteCfgList {
                set ipv4NetworkBlock [::sth::sthCore::invoke stc::get $bgpRouteCfg -children-ipv4networkblock]
                set ip [::sth::sthCore::invoke stc::get $ipv4NetworkBlock -StartIpList]
                set ip_ret "$ip_ret $ip"
            }
        }
    }

    return $ip_ret
}


########################################
#this funtion will output info into both console and hltapi log
proc ::wrapper::log_ouput {data} {
    puts "$data"
    ::sth::sthCore::log debug "$data"
}

#####################################################
#used to configure the capture filter and the analyzer filter when the rx port is data_intergrity
proc ::wrapper::config_capture_ana_filter {args} {
    #use the following args to configure the filter
    #-data_integrity
    #-integrity_signature
    #-integrity_signature_offset
    eval set args $args
    set port_handle [lindex $args [expr [lsearch $args "-port_handle"] + 1]]

    #default value in the ixia hltapi
    set integrity_signature "08 71 18 05"
    set integrity_signature_offset 40

    if {[lsearch $args "-integrity_signature"] > -1} {
        set integrity_signature [lindex $args [expr [lsearch $args "-integrity_signature"] + 1]]
        set integrity_signature [::wrapper::get_value_list $args "-integrity_signature"]
        set siglen [string length $integrity_signature]
        if {[llength $integrity_signature] == 1 && $siglen > 2} {
            set new_integrity_signature ""
            for {set i 0} {$i < $siglen} {incr i 2} {
                set j [expr $i + 1]
                lappend new_integrity_signature [string range $integrity_signature $i $j]
            }
        set integrity_signature $new_integrity_signature
        }
    }

    if {[lsearch $args "-integrity_signature_offset"] > -1} {
        set integrity_signature_offset [lindex $args [expr [lsearch $args "-integrity_signature_offset"] + 1]]
    }

    #configure the analyzer filter
    set analyzer [::sth::sthCore::invoke stc::get $port_handle -children-Analyzer]
    ::sth::sthCore::invoke stc::config $analyzer -FilterOnStreamId false
    set ana32bitfltr [::sth::sthCore::invoke stc::get $analyzer -children-Analyzer32BitFilter]
    if {$ana32bitfltr == ""} {
        set analyzer32BitFilter [::sth::sthCore::invoke stc::create Analyzer32BitFilter -under $analyzer \
                                                        -LocationType START_OF_FRAME \
                                                        -Offset $integrity_signature_offset\
                                                        -StartOfRange 0x[join [split $integrity_signature " "] ""]\
                                                        -EndOfRange 0x[join [split $integrity_signature " "] ""]]
    }
    #configure the capture filter
    set capture [::sth::sthCore::invoke stc::get $port_handle -children-Capture]
    ::sth::sthCore::invoke stc::config $capture -CaptureFilterMode BYTEOFFSETANDRANGE -SrcMode RX_MODE

    set byteExpression ""
    set captureBytePattern ""
    set i 1
    set capturebytepatternname [::sth::sthCore::invoke stc::get $capture -children-CaptureBytePattern]
    if {$capturebytepatternname == ""} {
        foreach signature $integrity_signature {
            set captureBytePattern [::sth::sthCore::invoke stc::create CaptureBytePattern -under $capture \
                                                                                    -Offset $integrity_signature_offset\
                                                                                    -Value 0x$signature\
                                                                                    -Name B$i]

            if {$byteExpression == ""} {
                set byteExpression B$i
            } else {
                set byteExpression [concat $byteExpression "&& B$i"]
            }
            incr i
            incr integrity_signature_offset
        }
        set captureFilter [::sth::sthCore::invoke stc::get $capture -children-CaptureFilter]
        if {$captureFilter != ""} {
            set capturePatternExpression [::sth::sthCore::invoke stc::create CapturePatternExpression -under $captureFilter -ByteExpression $byteExpression]
        }
    }
}


#process the "udf1_mode counter", currently, only support to config mpls modifier, and need to enhance more here in the future for more test cases
proc ::wrapper::process_udf_tmp {args processed_args} {
    set ret_args $processed_args

    set udf1_mode [lindex $args [expr [lsearch $args "-udf1_mode"] + 1]]
    if {$udf1_mode == "counter"} {
        set counter_mode [lindex $args [expr [lsearch $args "-udf1_counter_up_down"] + 1]]
        if {$counter_mode == "up"} {
            set modifier_mode "increment"
        } else {
            set modifier_mode "decrement"
        }
        set ini_value [lindex $args [expr [lsearch $args "-udf1_counter_init_value"] + 1]]
        set count [lindex $args [expr [lsearch $args "-udf1_counter_repeat_count"] + 1]]
        set step [lindex $args [expr [lsearch $args "-udf1_counter_step"] + 1]]
        set offset [lindex $args [expr [lsearch $args "-udf1_offset"] + 1]]

        if {[regexp -nocase "0x" $ini_value]} {
            #need to check the udf1_counter_type
            if {[lsearch $args "-udf1_counter_type"] > -1} {
                set udf1_counter_type [lindex $args [expr [lsearch $args "-udf1_counter_type"] + 1]]
            }
            #this is only for mpls_lable, the number such as 0x040841 also includes exp and s field, so need to remove the last one number
            if {$udf1_counter_type == "24" && [string length $ini_value] == 8} {
                regsub {\d$} $ini_value "" ini_value
                set step [expr $step/16]
            }
            set ini_value [format "%d" $ini_value]
        }

        #currnetly only handle the condition for -udf1_offset is 14 and 18 for mpls modifier
        set l2_encap [lindex $processed_args [expr [lsearch $processed_args "-l2_encap"] + 1]]
        if {$offset == "14"} {
            if {$l2_encap == "ethernet_ii_vlan_mpls" && [lsearch $args "-mpls_labels_mode"] < 0} {
                array set argArray "-mpls_labels $ini_value -mpls_labels_mode $modifier_mode -mpls_labels_step $step -mpls_labels_count $count"
            }
        }
        if {$offset == "18"} {
            if {$l2_encap == "ethernet_ii_vlan_mpls" && [lsearch $args "-mpls_labels_mode"] < 0} {
                array set argArray "-mpls_labels $ini_value -mpls_labels_mode $modifier_mode -mpls_labels_step $step -mpls_labels_count $count"
            }
        }
        if {[info exists argArray]} {
            foreach arg "-mpls_labels -mpls_labels_mode -mpls_labels_step -mpls_labels_count" {
                if {[lsearch $ret_args $arg] > -1} {
                    set index [expr [lsearch $ret_args $arg] + 1]
                    set ret_args [lreplace $ret_args $index $index $argArray($arg)]
                } else {
                    set ret_args "$ret_args $arg $argArray($arg)"
                }
            }
        }
    }
    return $ret_args
}

proc ::wrapper::addL3Forwardinglink {handle port} {
    set dstDevice ""
    set ipv4if [::sth::sthCore::invoke stc::get $handle -children-ipv4if]
    set ipv6if [::sth::sthCore::invoke stc::get $handle -children-ipv6if]
    if {"" != $ipv4if} {
        set ipv4if [lindex $ipv4if 0]
        set ipv4addr [::sth::sthCore::invoke stc::get $ipv4if -gateway]
        set dstDevice [get_device_with_ip_new $ipv4addr $port]
    } elseif {"" != $ipv6if} {
        set ipv6if [lindex $ipv6if 0]
        set ipv6addr [::sth::sthCore::invoke stc::get $ipv6if -gateway]
        set dstDevice [get_device_with_ip_new $ipv6addr $port]
    }
    if {"" != $dstDevice} {
        set deviceName [::sth::sthCore::invoke stc::get $dstDevice -name]
        if {($deviceName == "port_address") && ($port == [::sth::sthCore::invoke stc::get $dstDevice -AffiliationPort-targets])} {
            ::sth::sthCore::invoke stc::perform LinkCreate -SrcDev $handle -DstDev $dstDevice -LinkType "L3 Forwarding Link"
        }
    }
}

proc ::ixia::debugTrace {args} {
    puts "ixia::debugTrace called"
}

##use this ro monitor whether protocol device use same Mac, incase the same linklocalAddress
set MacList ""

proc ::wrapper::ip_to_mac {ip delimiter} {

    array set ip_bytes {}
    if {[regexp {:} $ip]} {
        array set mac {0 00 1 00 2 00 3 00 4 00 5 00}
        set tempList [join [split $ip {:}]]
        set ipv6Length [llength $tempList]
        for {set i 0} {$i<$ipv6Length} {incr i} {
            set ip_bytes($i) [lindex $tempList $i]
        }
        switch -- $ipv6Length {
            1 {
                set mac(5) [format %.2x [expr 0x$ip_bytes(0) & 0xff]]
                set mac(4) [format %.2x [expr 0x$ip_bytes(0) >> 8]]
            }
            2 {
                set mac(5) [format %.2x [expr 0x$ip_bytes(1) & 0xff]]
                set mac(4) [format %.2x [expr 0x$ip_bytes(1) >> 8]]
                set mac(1) [format %.2x [expr 0x$ip_bytes(0) & 0xff]]
                set mac(0) [format %.2x [expr 0x$ip_bytes(0) >> 8]]
            }
            default {
                set tempIp $ip_bytes([expr $ipv6Length - 1])
                set mac(5) [format %.2x [expr 0x$tempIp & 0xff]]
                set mac(4) [format %.2x [expr 0x$tempIp >> 8]]
                set tempIp $ip_bytes([expr $ipv6Length - 2])
                set mac(3) [format %.2x [expr 0x$tempIp & 0xff]]
                set mac(2) [format %.2x [expr 0x$tempIp >> 8]]
                set tempIp $ip_bytes(0)
                set mac(1) [format %.2x [expr 0x$tempIp & 0xff]]
                set mac(0) [format %.2x [expr 0x$tempIp >> 8]]
            }
        }
        if {[string equal -nocase "ff" $mac(0)]} {
            set mac(0) 01
            set mac(1) 00
            set mac(2) 5e
        }
        set mac_list ""
        for {set i 0} {$i<6} {incr i} {
            lappend mac_list $mac($i)
        }
    } else {
        set decList [split $ip "."]
        set ip_bytes(0) [lindex $decList 0]
        set ip_bytes(1) [lindex $decList 1]
        set ip_bytes(2) [lindex $decList 2]
        set ip_bytes(3) [lindex $decList 3]
        set mac_list "00 00"
        # handle ipv4 multicast address
        if {($ip_bytes(0) >= 224) && ($ip_bytes(0) < 240)} {
            set mac_list "01 00 5e"
            unset ip_bytes(0)
            set ip_bytes(1) [expr 0x7f & $ip_bytes(1)]
        }
        foreach number [array names ip_bytes] {
            lappend mac_list [format %.2x $ip_bytes($number)]
        }
    }
    set mac_string [join $mac_list $delimiter]
    return $mac_string
}

###this function will add left tx/rx info in stream
proc ::wrapper::addStreamStats {ret} {
    set new_ret $ret
    ##prepare Rx stats
    keylset RxKeyList total_pkt_rate 0
    keylset RxKeyList total_pkts 0
    keylset RxKeyList min_delay 0
    keylset RxKeyList avg_delay 0
    keylset RxKeyList total_pkts_bytes 0
    keylset RxKeyList max_delay 0
    keylset RxKeyList line_rate_percentage 0
    keylset RxKeyList total_pkt_bytes 0
    keylset RxKeyList total_pkt_bit_rate 0
    ##prepare Tx stats
    keylset TxKeyList total_pkt_rate 0
    keylset TxKeyList total_pkts 0
    keylset TxKeyList elapsed_time 0
    #############
    set retList [keylkeys new_ret]
    set portList ""
    foreach retkey $retList {
        if {[regexp -nocase port $retkey]} {
            set portList "$portList $retkey"
        }
    }
    foreach port $portList {
        set portkeyedlist [keylget new_ret $port]
        foreach portKey [keylkeys portkeyedlist] {
            if {[regexp -nocase stream $portKey]} {
                set streamkeyedlist [keylget new_ret $port.stream]
                foreach streamkey [keylkeys streamkeyedlist] {
                    set streamIDkeyedlist [keylget new_ret $port.stream.$streamkey]
                    if {![regexp -nocase rx [keylkeys streamIDkeyedlist]]} {
                        keylset new_ret $port.stream.$streamkey.rx $RxKeyList
                    }
                    if {![regexp -nocase tx [keylkeys streamIDkeyedlist]]} {
                        keylset new_ret $port.stream.$streamkey.tx $TxKeyList
                    }
                    if {[info exists ::spirent::stream_pgid($streamkey)]} {
                        if {($::spirent::stream_pgid($streamkey) != $streamkey) && ![regexp -nocase $::spirent::stream_pgid($streamkey) [keylkeys streamkeyedlist]]} {
                            keylset new_ret $port.stream.$::spirent::stream_pgid($streamkey) [keylget new_ret $port.stream.$streamkey]
                        }
                    }
                }
            }
            if {[regexp -nocase aggregate $portKey]} {
                set aggregatekeyedlist [keylget new_ret $port.aggregate]
                foreach aggregatekey [keylkeys aggregatekeyedlist] {
                    if {($aggregatekey eq "rx") || ($aggregatekey eq "tx")} {
                        if {[keylget new_ret $port.aggregate.$aggregatekey.pkt_count] != 0} {

                            keylset new_ret $port.aggregate.$aggregatekey.total_pkts [keylget new_ret $port.aggregate.$aggregatekey.pkt_count]
                        }
                        set total_pkts [keylget new_ret $port.aggregate.$aggregatekey.total_pkts]
                        ##West 2016-02-15 ArpNdResults can't be integrated into DRV, since DRV can't support Arp counters
                        set arpdataset [::sth::sthCore::invoke stc::subscribe -parent project1 -resultparent $port -resulttype ArpNdResults  -configtype port]
                        set arpNdResults [::sth::sthCore::invoke stc::get $port -children-ArpNdResults]
                        set tx_na_count 0
                        set tx_ns_count 0
                        set tx_arp_request 0
                        set tx_arp_reply 0
                        if {$arpNdResults != ""} {
                            set tx_na_count [::sth::sthCore::invoke stc::get $arpNdResults -TxNeighborAdvertisementCount]
                            set tx_ns_count [::sth::sthCore::invoke stc::get $arpNdResults -TxNeighborSolicitationCount]
                            set tx_arp_request [::sth::sthCore::invoke stc::get $arpNdResults -TxArpRequestCount]
                            set tx_arp_reply [::sth::sthCore::invoke stc::get $arpNdResults -TxArpReplyCount]
                        }
                        ##Add unsubscribe here
                        ::sth::sthCore::invoke stc::unsubscribe $arpdataset
                        set raw_pkt_count [expr $total_pkts + $tx_na_count + $tx_ns_count + $tx_arp_request + $tx_arp_reply]
                        keylset new_ret $port.aggregate.$aggregatekey.raw_pkt_count $raw_pkt_count
                    }
                }
            }
        }
    }

    return $new_ret
}

proc ::wrapper::macAddressToStcFormat {mac_value} {
    # Handling all format of MAC address input. Like with space, without space, colon, dash and dot.
    if {[llength [split $mac_value {[\:|.|\-|\s]}]] != 6 && [llength $mac_value] != 6} {
        if {[llength [split $mac_value {[\:|.|\-|\s]}]] != 3} {
            if {[llength [split $mac_value {.|:}]] != 1} {
                return -code 1 -errorcode -1 "Error: Invalid mac ($mac_value)"
            }
        }
        regsub -all {[\:|.|\-|\s]} $mac_value "" newMac
        if {[string length $newMac] != 12} {
            return -code 1 -errorcode -1 "Error: Invalid mac ($mac_value)"
        }
        set newMac_tmp ""
        for {set idx 0} {$idx <= 11} {incr idx 2} {
            set tmp [string range $newMac $idx [expr "$idx+1"]]
            set newMac_tmp "${newMac_tmp}:${tmp}"
        }
        set newMac [string trimleft $newMac_tmp :]
    } else {
        regsub -all {[\:|.|\-|\s]} $mac_value : newMac
    }

    return $newMac
}

# proc incrementMacAddress to increment a given MAC address by the increment value
proc ::wrapper::incrMacAddress {address {incrValue 00.00.00.00.00.01}} {
    set ipList   [split $address    ".:-"]
    if {[llength $ipList] < 6} {
        set joinedmac [join $ipList ""]
        set joinedmaclen [string length $joinedmac]
        set tmpmac ""
        for {set i 0} {$i < $joinedmaclen} {incr i 2} {
            set j [expr $i + 1]
            lappend tmpmac [string range $joinedmac $i $j]
            set ipList $tmpmac
        }
    }
    set incrVals [split $incrValue ".:-"]
    set o6 [expr 0x[lindex $ipList 5] + 0x[lindex $incrVals 5]]
    set o5 [expr 0x[lindex $ipList 4] + 0x[lindex $incrVals 4]]
    set o4 [expr 0x[lindex $ipList 3] + 0x[lindex $incrVals 3]]
    set o3 [expr 0x[lindex $ipList 2] + 0x[lindex $incrVals 2]]
    set o2 [expr 0x[lindex $ipList 1] + 0x[lindex $incrVals 1]]
    set o1 [expr 0x[lindex $ipList 0] + 0x[lindex $incrVals 0]]

    if {$o6 > 255} {incr o5; set o6 [expr $o6 - 256]}
    if {$o5 > 255} {incr o4; set o5 [expr $o5 - 256]}
    if {$o4 > 255} {incr o3; set o4 [expr $o4 - 256]}
    if {$o3 > 255} {incr o2; set o3 [expr $o3 - 256]}
    if {$o2 > 255} {incr o1; set o2 [expr $o2 - 256]}
    if {$o1 > 255} {
        puts "ERROR: Cannot increment mac past ff"
    }

    return "[format %02X $o1]:[format %02X $o2]:[format %02X $o3]:[format %02X $o4]:[format %02X $o5]:[format %02X $o6]"
}

namespace eval ::hltUtils:: {
}

proc ::hltUtils::enable_tgen_intf_vlan {args} {
    puts "here calling ::hltUtils::enable_tgen_intf_vlan definned in hltapiWrapper"
    variable ::spirent::port_convert

    set man_args {
        -handle                   ANY
    }

    set opt_args {
        -tgen_vendor              CHOICES ixia sth
                                  DEFAULT ixia
        -outer_vlan               ANY
        -inner_vlan               ANY
        -outer_pris               CHOICES 0-7
                                  DEFAULT 0
        -inner_pris               CHOICES 0-7
                                  DEFAULT 0
        -outer_tpid               ANY
                                  DEFAULT 0X8100
        -inner_tpid               ANY
                                  DEFAULT 0X8100
        -outer_connect_count      NUMERIC
                                  DEFAULT 1
        -inner_connect_count      NUMERIC
                                  DEFAULT 1
        -debug_mode               FLAG
                                  DEFAULT 0
    }
    sth::parse_dashed_args -args $args \
            -mandatory_args $man_args \
            -optional_args $opt_args

    global env

    set procName "[lindex [info level [info level]] 0]"

    if {[info exists env(DEBUG_LIST)]} {
        if {[lsearch $env(DEBUG_LIST) $procName] >= 0 } {
            set debug_mode 1
        }
    }

    if { [regexp {[0-9]+/[0-9]+/[0-9]+} $handle] } {
        set index [string first "/" $handle]
        set port [string range $handle [incr index] [string length $handle]]
        set handle $::spirent::port_convert($port)
    }

    # Find the corresponding Emulated Devices for this port.
    set devices [::sth::sthCore::invoke stc::get $handle -AffiliationPort-Sources]
    set devicelist ""
    foreach device $devices {
        if {[::sth::sthCore::invoke stc::get $device -name] eq "port_address"} {
            lappend devicelist $device
        }
    }

    set index 0
    for { set i 0 } { $i < $outer_connect_count } { incr i } {
        set device [lindex $devicelist $index]

        set current_outer_vlan [expr $outer_vlan + $i]
        set current_inner_vlan $inner_vlan

        set vlanIfList [::sth::sthCore::invoke stc::get $device -children-vlanif]
        set vlan_num [llength $vlanIfList]
        set ethIf [::sth::sthCore::invoke stc::get $device -children-EthIIIf]
        set ipIf [lindex [::sth::sthCore::invoke stc::get $device -children-ipv4If] 0]
        if {$ipIf eq ""} {
            set ipIf [lindex [::sth::sthCore::invoke stc::get $device -children-ipv6If] 0]
        }
        if { [info exists inner_vlan] } {
            ####set qinq by native API
            if {$vlan_num == 0} {
                set outerVlan [::sth::sthCore::invoke stc::create vlanif  -under $device -VlanId $current_outer_vlan -Priority $outer_pris \
                -Tpid [format %d $outer_tpid]]
                set innerVlan [::sth::sthCore::invoke stc::create vlanif  -under $device -VlanId $current_inner_vlan -Priority $inner_pris \
                -Tpid [format %d $inner_tpid]]
            }
            if {$vlan_num == 1} {

                ::sth::sthCore::invoke stc::config [lindex $vlanIfList 0] -VlanId $current_outer_vlan
                ::sth::sthCore::invoke stc::config [lindex $vlanIfList 0] -Priority $outer_pris
                ::sth::sthCore::invoke stc::config [lindex $vlanIfList 0] -Tpid [format %d $outer_tpid]
                set outerVlan [lindex $vlanIfList 0]
                set innerVlan [::sth::sthCore::invoke stc::create vlanif  -under $device -VlanId $current_inner_vlan -Priority $inner_pris \
                -Tpid [format %d $inner_tpid]]
            }
            if {$vlan_num > 1} {
                #config two vlan
                ::sth::sthCore::invoke stc::config [lindex $vlanIfList 0] -VlanId $current_outer_vlan
                ::sth::sthCore::invoke stc::config [lindex $vlanIfList 0] -Priority $outer_pris
                ::sth::sthCore::invoke stc::config [lindex $vlanIfList 0] -Tpid [format %d $outer_tpid]
                ::sth::sthCore::invoke stc::config [lindex $vlanIfList 1] -VlanId $current_inner_vlan
                ::sth::sthCore::invoke stc::config [lindex $vlanIfList 1] -Priority $inner_pris
                ::sth::sthCore::invoke stc::config [lindex $vlanIfList 1] -Tpid [format %d $inner_tpid]
                set innerVlan [lindex $vlanIfList 1]
                set outerVlan [lindex $vlanIfList 0]
            }

            ::sth::sthCore::invoke stc::config $innerVlan "-StackedOnEndpoint-targets $outerVlan"
            ::sth::sthCore::invoke stc::config $ipIf "-StackedOnEndpoint-targets $innerVlan"
            ::sth::sthCore::invoke stc::config $outerVlan "-StackedOnEndpoint-targets $ethIf"

        } else {

            ####set vlan by native API
            if {$vlan_num == 0} {
                #create  vlan
                set outerVlan [::sth::sthCore::invoke stc::create vlanif  -under $device -VlanId $current_outer_vlan -Priority $outer_pris \
                -Tpid [format %d $outer_tpid]]

            }

            if {$vlan_num > 0} {
                #create  vlan
                ::sth::sthCore::invoke stc::config [lindex $vlanIfList 0] -VlanId $current_outer_vlan
                ::sth::sthCore::invoke stc::config [lindex $vlanIfList 0] -Priority $outer_pris
                ::sth::sthCore::invoke stc::config [lindex $vlanIfList 0] -Tpid [format %d $outer_tpid]
                set outerVlan [lindex $vlanIfList 0]
            }

            ::sth::sthCore::invoke stc::config $ipIf "-StackedOnEndpoint-targets $outerVlan"
            ::sth::sthCore::invoke stc::config $outerVlan "-StackedOnEndpoint-targets $ethIf"
        }

        incr index
    }

    return $::sth::sthCore::SUCCESS
}


namespace eval ::viking_qos:: {
}

proc ::viking_qos::enable_ixia_intf_vlan {args} {
    puts "here calling ::viking_qos::enable_ixia_intf_vlan definned in hltapiWrapper"
    set cmd "::hltUtils::enable_tgen_intf_vlan $args"
    return [eval $cmd]
}


################################################################################
# checkpoint.tcl
# add chenling
# This  script is used to check  QOS return value in ixia whether exists in Hltapi


#####################################################
# this function is used to check  ixia::connect
proc ::spirent::check_connect {connect_device} {
     if {![keylget connect_device status]} {
         puts "the ixia::connect the retuen value of status is erro "
         puts "<error>"
     }
}


##############################################################
## The following is the series of ::ixia::interface

## -mode config
proc ::spirent::check_interface_config {interface_config} {
     if {![keylget interface_config status]} {
         puts "the ::ixia::interface_config -mode config is failure"
         puts "<error>"
         exit
    } else {
         set  interface_handle [keylget interface_config interface_handle ]
         set result [regexp -nocase {host} $interface_handle match]
         if {!$result} {
            puts "the  interface_handle is not exist "
            puts "<error>"
        }
    }
}


#####  - mode config -arp_send_req 1  -port_handle [concat $handleport_src $handleport_dest]
proc ::spirent::check_interface_arp_send_req_double {port arp_send_req} {
    variable port_spirent_ixia_agt
    if {[keylget arp_send_req status]} {
         set  interface_handle [keylget arp_send_req interface_handle]
         set result [regexp -nocase {host} $interface_handle match]
         if {!$result} {
            puts "the  interface_handle is not exist "
            puts "<error>"
        }
        foreach port_hdl $port {
            set port_handle  $port_spirent_ixia_agt($port_hdl)
            set arp_request_success [keylget arp_send_req ${port_handle}.arp_request_success]
            if {![info exists arp_request_success]} {
                puts " interface config  $port  -arp_send_req arp_request_success is not exit"
                puts "<error>"
            }
        }
    } else {
         puts " interface config -arp_send_req he status is wrong"
         puts "<error>"
    }
}

###::ixia::interface_stats
proc ::spirent::check_interface_stats_single {interface_stats} {
     if {![keylget interface_stats status]} {
         puts "the ::ixia::interface_stats  status is wrong"
         puts "<error>"
     }
}


##############################################################
## The following is the series of packet_config

## ::ixia::packet_config_filter -port_handle 1/6/8
proc ::spirent::check_packet_config_filter {packet_config_filter} {
     if {![keylget packet_config_filter status]} {
         puts "the ::ixia::packet_config_filter  status is wrong"
         puts "<error>"
     }
}

## ::ixia::packet_config_triggers -port_handle 1/6/8
proc ::spirent::check_packet_config_triggers {packet_config_triggers} {
     if {![keylget packet_config_triggers status]} {
         puts "the ::ixia::packet_config_triggers  status is wrong"
         puts "<error>"
     }
}


##############################################################
## The following is the series of ixia::traffic_config

## -mode reset  modify remove  destroy
proc ::spirent::check_traffic_config_reset {traffic_config_reset} {
     if {![keylget traffic_config_reset status]} {
         puts "the  return value of ixia::traffic_config -port_handle  -mode reset or modify or remove  is wrong"
         puts "<error>"
     }
}

## -mode config -connected_count  -vlan_id_count
proc ::spirent::check_traffic_config_config {traffic_config_config} {
     if {![keylget traffic_config_config status]} {
         puts "the return value of ::ixia::interface_config -mode config is failure, the status is wrong"
         puts "<error>"
     } else {
         set  interface_handle [keylget traffic_config_config interface_handle ]
         set result [regexp -nocase {host} $interface_handle match]
         if {!$result} {
            puts "the  interface_handle is not exist "
            puts "<error>"
        }
    }
}

## -mode create -bidirectional 0
proc ::spirent::check_traffic_config_create_single {port traffic_config_create_single} {
     if {![keylget traffic_config_create_single status] || ! [keylget traffic_config_create_single stream_id]} {
         puts "the return value of  ::ixia::traffic_config  -mode create is failure, the status or stream_id is wrong "
         puts "<error>"
     } else {
         if { [string equal $port "port1"]} {
             lappend ::spirent::src_stream_id  [keylget traffic_config_create_single stream_id]
        } else {
             lappend ::spirent::dst_stream_id  [keylget traffic_config_create_single stream_id]
         }
     }
}

## -mode create -port_handle $handleport_src -port_hdl $handleport_dest -bidirectional 1

proc ::spirent::check_traffic_config_create_double {port traffic_config_create_double } {
     if {![keylget traffic_config_create_double  status] } {
         puts "the return value  of  ::ixia::traffic_config  -mode create  -bidirectional 1  is wrong "
         puts "<error>"
     } else {
         variable port_spirent_ixia_agt
         foreach port_hdl $port {
            set port_handle  $port_spirent_ixia_agt($port_hdl)
            #variable stream_id
            if { [string equal $port_hdl "port1"]} {
                lappend ::spirent::src_stream_id  [keylget traffic_config_create_double   stream_id.$port_handle]
            } else {
                lappend ::spirent::dst_stream_id  [keylget traffic_config_create_double   stream_id.$port_handle]
            }
        }
    }
}





##############################################################
## The following is the series of ::ixia::traffic_control

### -action stop
proc ::spirent::check_traffic_control_stop {traffic_control_stop} {
     if {![keylget traffic_control_stop status] || ! [keylget traffic_control_stop stopped]} {
     puts "the traffic stop is failure ,the return value of status or stopped is wrong "
     puts "<error>"
     }
}

###  -action sync_run or -action run
proc ::spirent::check_traffic_control_sync_run {traffic_control_sync_run} {
     if {![keylget traffic_control_sync_run status] || [keylget traffic_control_sync_run stopped]} {
         puts "the traffic sync_run or run is failure ,the return value is wrong "
         puts "<error>"
     }
}


### -action clear_stats poll
proc ::spirent::check_traffic_control_clear_stats {traffic_control_clear_stats} {
     if {![keylget traffic_control_clear_stats status] } {
          puts "the traffic clear_stats or poll is failure ,the return value is wrong "
          puts "<error>"
     }
}



##############################################################
## The following is the series of ::ixia::traffic_stats

###-port_handle $handleport_src $handleport_dest -mode streams
proc ::spirent::check_traffic_stats_streams_double {stream} {
     variable port_spirent_ixia_agt
     set handleport_src   $port_spirent_ixia_agt(port1)
     set handleport_dest  $port_spirent_ixia_agt(port2)
     foreach port_handle [concat $handleport_src $handleport_dest] {
         if { [string equal $port_handle "$handleport_src"]} {
             set stream_id $::spirent::src_stream_id
         } else {
             set stream_id $::spirent::dst_stream_id
        }
         set clicks     [keylget  stream  clicks]
         set seconds    [keylget  stream clicks]
         set status     [keylget  stream status]
         if {$status && [info exists clicks] && [info exists seconds]} {
            foreach stream_id $stream_id {
                 set rx.total_pkts          [keylget stream $port_handle.stream.$stream_id.rx.total_pkts]
                 set rx.avg_delay           [keylget stream $port_handle.stream.$stream_id.rx.avg_delay]
                 set rx.max_delay           [keylget stream $port_handle.stream.$stream_id.rx.max_delay]
                 set rx.min_delay           [keylget stream $port_handle.stream.$stream_id.rx.min_delay]
                 set rx.total_pkt_bit_rate  [keylget stream $port_handle.stream.$stream_id.rx.total_pkt_bit_rate]
                 set rx.total_pkt_bytes     [keylget stream $port_handle.stream.$stream_id.rx.total_pkt_bytes]
                 set tx.total_pkts          [keylget stream $port_handle.stream.$stream_id.tx.total_pkts]
                 if {![info exists rx.total_pkts]||![info exists rx.avg_delay] ||![info exists rx.max_delay]||![info exists rx.min_delay]||![info exists rx.total_pkt_bit_rate]||![info exists rx.total_pkt_bytes]||![info exists tx.total_pkts]} {
                     puts "the traffic_stats stream  is failure ,the rx.total_pkts or rx.avg_delay  or rx.max_delay or rx.min_delay  or rx.total_pkt_bit_rate or  rx.total_pkt_bytes or tx.total_pkts is wrong ,should exit "
                     puts "<error>"
                 }
             }
         } else {
             puts "the traffic_stats stream  is failure ,the status or clicks or seconds  is wrong  "
            puts "<error>"
         }
    }
}


### -port_handle 1/6/8 -mode streams -stream {1 2 3 4 5}

proc ::spirent::check_traffic_stats_streams_stream {port stream_id stream} {
    variable port_spirent_ixia_agt
     foreach port_hdl $port {
        set port_handle  $port_spirent_ixia_agt($port_hdl)
        set clicks     [keylget  stream  clicks]
        set seconds    [keylget  stream clicks]
        set status     [keylget  stream status]
        if {$status && [info exists clicks] && [info exists seconds]} {
            foreach stream_id $stream_id {
                set rx.total_pkts          [keylget stream $port_handle.stream.$stream_id.rx.total_pkts]
                set rx.avg_delay           [keylget stream $port_handle.stream.$stream_id.rx.avg_delay]
                set rx.max_delay           [keylget stream $port_handle.stream.$stream_id.rx.max_delay]
                set rx.min_delay           [keylget stream $port_handle.stream.$stream_id.rx.min_delay]
                set rx.total_pkt_bit_rate  [keylget stream $port_handle.stream.$stream_id.rx.total_pkt_bit_rate]
                set rx.total_pkt_bytes     [keylget stream $port_handle.stream.$stream_id.rx.total_pkt_bytes]
                set tx.total_pkts          [keylget stream $port_handle.stream.$stream_id.tx.total_pkts]
                if {![info exists rx.total_pkts]||![info exists rx.avg_delay] ||![info exists rx.max_delay]||![info exists rx.min_delay]||![info exists rx.total_pkt_bit_rate]||![info exists rx.total_pkt_bytes]||![info exists tx.total_pkts]} {
                    puts "the traffic_stats stream  is failure ,the rx.total_pkts or rx.avg_delay  or rx.max_delay or rx.min_delay  or rx.total_pkt_bit_rate or  rx.total_pkt_bytes or tx.total_pkts is wrong ,should exit "
                    puts "<error>"
                }
            }
        } else {
            puts "the traffic_stats stream  is failure ,the status or clicks or seconds  is wrong  "
            puts "<error>"
        }
    }
}


###-port_handle $handleport_src $handleport_dest -mode all or -mode aggregate
proc ::spirent::check_traffic_stats_all_double {port aggregate } {
     variable port_spirent_ixia_agt
     foreach port_hdl $port {
         set port_handle  $port_spirent_ixia_agt($port_hdl)
         set clicks  [keylget aggregate clicks]
         set seconds [keylget aggregate seconds]
         set status  [keylget aggregate status]
         if {$status && [info exists clicks] && [info exists seconds]} {
             set tx.pkt_bit_rate      [keylget aggregate  $port_handle.aggregate.tx.pkt_bit_rate]
             set tx.pkt_count         [keylget aggregate  $port_handle.aggregate.tx.pkt_count]
             set tx.raw_pkt_count     [keylget aggregate  $port_handle.aggregate.tx.raw_pkt_count]
             set tx.total_pkts        [keylget aggregate  $port_handle.aggregate.tx.total_pkts]
             set rx.pkt_bit_rate      [keylget aggregate  $port_handle.aggregate.rx.pkt_bit_rate ]
             #set rx.uds1_count       [keylget aggregate  $port_handle.aggregate.rx.uds1_count]
             for { set i 0 } { $i <8 } { incr i  } {
             set rx.qos${i}_count       [keylget aggregate $port_handle.aggregate.rx.qos${i}_count]
             }
            if {![info exists tx.pkt_bit_rate] || ![info exists tx.pkt_count ] \
                        || ![info exists tx.raw_pkt_count] || ![info exists tx.total_pkts ] \
                        || ![info exists rx.pkt_bit_rate ]} {
                puts "the traffic_stats aggregate  is failure ,the return tx or rx is wrong "
                puts "<error>"
            }
        } else {
            puts "the traffic_stats aggregate  is failure ,the status or clicks or seconds  is wrong "
            puts "<error>"
        }
     }
}

##############################################################
## The following is the series of ::ixia::cleanup_session

### -port_handle {1/6/7 1/6/8} -reset
proc ::spirent::check_cleanup_session {cleanup_session} {
    if {![keylget cleanup_session status] } {
        puts "the cleanup_session reset is failure ,the return value is wrong "
        puts "<error>"
    }
}

proc ::ixia_sleep {duration} {
   after $duration
}
#==============================================================================
proc ::spirent::TraceEnter { args } {
    variable logfilename
        set fh [open $logfilename a]
        puts $fh "[GetTimestamp] $args"
        close $fh
    return
}
#==============================================================================
proc ::spirent::TraceLeave { args } {
    variable logfilename
        set fh [open $logfilename a]
        puts $fh "[GetTimestamp] $args"
        close $fh
    return
}
#==============================================================================
proc ::spirent::GetTimestamp {} {
    if {[info exists ::sth::sthCore::iEnableTimeStamp] && $::sth::sthCore::iEnableTimeStamp} {
        return [clock format [clock scan now] -format {%Y-%m-%d_%H:%M:%S}]
    } else {
        return ""
    }
}


###Add by West in 26th Jul 2016 for Ixia NGPF convertion.
namespace eval ::ixiangpf:: {

}
###mapping between port handle and topology handle
array set ::spirent::portHdl_topoHdl {}
array set ::spirent::topoHdl_portHdl {}
set ::spirent::topoInd 1
set ::spirent::deviceGroupInd 1
set ::spirent::currentTopoHdl ""

###mapping between devicegroup handle and topology handle
array set ::spirent::topoHdl_devicegroupHdl {}

###record the multiple string, which will be handle in protocol functions
array set ::spirent::multivalueHdl {}
set ::spirent::multivalueInd 1

proc ::ixiangpf::connect { args } {
    set args [eval ::spirent::port_converter $args]
    
    ###clear global variables
    variable ::spirent::portHdl_topoHdl
    variable ::spirent::topoHdl_portHdl
    variable ::spirent::topoInd
    variable ::spirent::deviceGroupInd
    variable ::spirent::topoHdl_devicegroupHdl
    variable ::spirent::multivalueHdl
    variable ::spirent::multivalueInd
    variable ::spirent::currentTopoHdl
    
    array unset ::spirent::portHdl_topoHdl
    array unset ::spirent::topoHdl_portHdl
    array unset ::spirent::topoHdl_devicegroupHdl
    array unset ::spirent::multivalueHdl
    array unset ::sth::Pppox::PPPOXCLIENTROBJTYPE
    array set ::spirent::portHdl_topoHdl {}
    array set ::spirent::topoHdl_portHdl {}
    set ::spirent::topoInd 1
    set ::spirent::deviceGroupInd 1
    array set ::spirent::topoHdl_devicegroupHdl {}
    array set ::spirent::multivalueHdl {}
    set ::spirent::multivalueInd 1
    set ::spirent::currentTopoHdl ""
    array set ::sth::Pppox::PPPOXCLIENTROBJTYPE {}
    
    foreach deviceGroup [::sth::sthCore::invoke stc::get project1 -children-devicegroup] {
        ::sth::sthCore::invoke stc::delete $deviceGroup
    }
    
    set ixia_only_args "close_server_on_disconnect tcl_proxy_username"
    set args [wrapper::shield_args -total $args -unsupported $ixia_only_args]
	set retval [::spirent::connect $args]
	keylset retval vport_protocols_handle [stc::get project1 -children-port]
	keylset retval vport_list [stc::get project1 -children-port]
    return $retval
}

proc ::ixiangpf::test_control { args } {
    set args [eval ::spirent::port_converter $args]
    keylset result status 1
	##save as xmlfile here
	stc::perform saveasxml -filename stc_startDevice.xml
    
    if {([lsearch $args "-action"] > -1)} {
        set action [lindex $args [expr {[lsearch $args "-action"] + 1}]]
        ##only handle start_all_protocols|stop_all_protocols for the time being
        switch -- $action {
			start_protocol -
            start_all_protocols {
                return [::sth::start_devices]
            }
			stop_protocol -
            stop_all_protocols {
                return [::sth::stop_devices]
            }
            default {
                puts "action $action is not supported in ::ixiangpf::test_control yet\n"
            }
        }
    }
    return $result
}

proc ::ixiangpf::traffic_control { args } {
    set args [eval ::spirent::port_converter $args]
    keylset result status 1
    stc::perform saveasxml -filename stc_traffic.xml
	
	set ixia_only_args "traffic_generator"
    set args [wrapper::shield_args -total $args -unsupported $ixia_only_args]
	
	if {([lsearch $args "-handle"] < 0) && ([lsearch $args "-stream_handle"] < 0) && ([lsearch $args "-port_handle"] < 0)} {
		set args "$args -port_handle [list [::sth::sthCore::invoke stc::get project1 -children-port]]"
	}
    if {[lsearch $args "-handle"] > -1} {
		if {$::spirent::traffic_bidirectional == 1} {
			##start all
			set ixia_only_args "handle"
			set args [wrapper::shield_args -total $args -unsupported $ixia_only_args]
			set args "$args -port_handle [list [::sth::sthCore::invoke stc::get project1 -children-port]]"
		} else {
			set index [lsearch $args "-handle"]
			set args [lreplace $args $index $index "-stream_handle"]
		}
    }
        set sblist ""
    if {[lsearch $args "-stream_handle"] > -1} {
        set stream_handle [lindex $args [expr {[lsearch $args "-stream_handle"] + 1}]]
        for {set i [expr [lsearch $args $stream_handle] + 1 ]} {$i< [llength $args]} {incr i} {
            set stream [lindex $args $i]
            if {![regexp -nocase {^-[^\s]*| -[^\s]*} $stream]} {
                lappend stream_handle $stream
            } else {
                    break
               }
            }
        foreach stream $stream_handle {
            if {![regexp -nocase "streamblock" $stream]} {
                lappend sblist "streamblock$stream"
            } else {
            lappend sblist "$stream"
        }
        }
        set index [expr [lsearch $args "-stream_handle"] + 1]
        set args [lreplace $args $index [expr [llength $stream_handle] + $index -1 ] "$sblist"]
    }

    if {[lsearch $args "-action"] > -1} {
        set action [lindex $args [expr {[lsearch $args "-action"] + 1}]]
        if {[regexp -nocase "run" $action]} {
            if {[lsearch $args "-stream_handle"] > -1} {
                set stream_handle [lindex $args [expr {[lsearch $args "-stream_handle"] + 1}]]
                foreach stream $stream_handle {
                    ::sth::sthCore::invoke stc::config $stream -active TRUE
                }
            }
            set cmdName "sth::traffic_control -port_handle all -action clear_stats"
            ::spirent::process_cmd $cmdName
            
            ::sth::sthCore::invoke stc::perform ArpNdStart -HandleList $sblist
        }
    }
        
    set cmdName "sth::traffic_control $args"
    set result [::spirent::process_cmd $cmdName]
    
    if {[lsearch $args "-action"] > -1} {
        set action [lindex $args [expr {[lsearch $args "-action"] + 1}]]
        if {[regexp -nocase "stop" $action]} {
            if {[lsearch $args "-stream_handle"] > -1} {
                set stream_handle [lindex $args [expr {[lsearch $args "-stream_handle"] + 1}]]
                foreach stream $stream_handle {
                    ::sth::sthCore::invoke stc::config $stream -active FALSE
                }
            }
            keylset result stopped 1
        } else {
            keylset result stopped 0
        }
    }
    if {[lsearch $args "-action"] > -1} {
        set action [lindex $args [expr {[lsearch $args "-action"] + 1}]]
        if {[regexp -nocase "reset" $action]} {
            if {[lsearch $args "-stream_handle"] > -1} {
                set stream_handle [lindex $args [expr {[lsearch $args "-stream_handle"] + 1}]]
                foreach stream $stream_handle {
                    ::sth::sthCore::invoke stc::delete $stream
                }
            } else {
            set cmdName "sth::traffic_control -port_handle all -action reset"
            ::spirent::process_cmd $cmdName
            }	
        }
    } 
 
    return $result
}

proc ::ixiangpf::topology_config { args } {
    set args [eval ::spirent::port_converter $args]
    keylset result status 1
    variable ::spirent::portHdl_topoHdl
    variable ::spirent::topoHdl_portHdl
    variable ::spirent::topoInd
    variable ::spirent::deviceGroupInd
    variable ::spirent::topoHdl_devicegroupHdl
    variable ::spirent::currentTopoHdl
    if {([lsearch $args "-port_handle"] > -1)} {
        set port_handle [lindex $args [expr {[lsearch $args "-port_handle"] + 1}]]
        if {([lsearch $args "-topology_name"] > -1)} {
            set topology_name [::wrapper::get_value_list $args "-topology_name"]
			puts $topology_name
			if {[regexp {^Topology [0-9]+} $topology_name]} {
			    regsub -all " " $topology_name "_" topology_name
		    } else {
		        set topology_name "Topology_Wrapper_$::spirent::topoInd"
		        incr ::spirent::topoInd
				}
        }
        lappend ::spirent::portHdl_topoHdl($port_handle) "$topology_name"
        set ::spirent::topoHdl_portHdl($topology_name) "$port_handle"
        keylset result topology_handle "$topology_name"
        set ::spirent::currentTopoHdl $topology_name
    } elseif {([lsearch $args "-topology_handle"] > -1)} {
        set topology_handle [lindex $args [expr {[lsearch $args "-topology_handle"] + 1}]]
        set port $::spirent::topoHdl_portHdl($topology_handle)
        ###via wizard, create group devices
        set device_group_multiplier 10
        if {([lsearch $args "-device_group_multiplier"] > -1)} {
            set device_group_multiplier [lindex $args [expr {[lsearch $args "-device_group_multiplier"] + 1}]]
        }
        set device_group_enabled 1
        if {([lsearch $args "-device_group_enabled"] > -1)} {
            set device_group_enabled [lindex $args [expr {[lsearch $args "-device_group_enabled"] + 1}]]
        }
        if {([lsearch $args "-device_group_name"] > -1)} {
            set device_group_name [::wrapper::get_value_list $args "-device_group_name"]
            regsub -all " " $device_group_name "_" device_group_name
        } else {
            set device_group_name "DeviceGroup_Wrapper_$::spirent::deviceGroupInd"
            incr ::spirent::deviceGroupInd
        }
        ### make BlockMode is ONE_NETWORK_PER_BLOCK for the time being
        ### since no code use seperate device/eth/protocol handle
        set emulateddevicegen [::sth::sthCore::invoke stc::create EmulatedDeviceGenParams \
                                -under project1 \
                                -SelectedPort-targets $port \
                                -Count $device_group_multiplier \
                                -BlockMode ONE_NETWORK_PER_BLOCK \
                                -DeviceName "GroupDevice"]
                                ###here to mark all ngpf device name as GroupDevice
        set emulateddevicegroupgen [::sth::sthCore::invoke stc::create DeviceGenGroupParams \
                                -under $emulateddevicegen \
                                -GroupName $device_group_name]
        set devicegeneth [::sth::sthCore::invoke stc::create DeviceGenEthIIIfParams \
                                -under $emulateddevicegen]
        set devicegroup_oldlist [::sth::sthCore::invoke stc::get project1 -children-devicegroup]
        ::sth::sthCore::invoke stc::perform DeviceGenConfigExpand -DeleteExisting no -GenParams $emulateddevicegen
        set devicegroup_newlist [::sth::sthCore::invoke stc::get project1 -children-devicegroup]
        set devicegroup_newadd ""
        foreach devicegroup_tmp $devicegroup_newlist {
            if {![regexp -nocase $devicegroup_tmp $devicegroup_oldlist]} {
                set devicegroup_newadd $devicegroup_tmp
                break
            }
        }
        keylset result device_group_handle $devicegroup_newadd
        set ::spirent::topoHdl_devicegroupHdl($topology_handle) [keylget result device_group_handle]
    } else {
        keylset result status 0
        keylset result log "-port_handle|-topology_handle is mandatory for ::ixiangpf::topology_config"
    }
    return $result
}

###this func is used to configure correct stack
proc ::spirent::update_device_stack { device } {
    set ethif [::sth::sthCore::invoke stc::get $device -children-ethiiif]
    set vlanifList [::sth::sthCore::invoke stc::get $device -children-vlanif]
    set vlans [llength $vlanifList]
    set ipv4if [::sth::sthCore::invoke stc::get $device -children-ipv4if]
    set ipv6ifList [::sth::sthCore::invoke stc::get $device -children-ipv6if]
    
    ##for pppoe
    set pppoe 0
    if {"" != [::sth::sthCore::invoke stc::get $device -children-PppoeClientBlockConfig]} {
        set pppoe 1
        set pppoeif [::sth::sthCore::invoke stc::get $device -children-pppoeif]
        set pppifList [::sth::sthCore::invoke stc::get $device -children-pppif]
        ::sth::sthCore::invoke stc::config $pppoeif -stackedonendpoint-Sources $pppifList
    }
    if {$ipv6ifList != ""} {
        set ipv6if [lindex $ipv6ifList 0]
        set ipv6iflocal [lindex $ipv6ifList 1]
    }
    set stack4ip $ethif
    if {2 == $vlans} {
        set vlanif1 [lindex $vlanifList 0]
        set vlanif2 [lindex $vlanifList 1]
        ::sth::sthCore::invoke stc::config $vlanif1 -stackedonendpoint-targets $vlanif2
        ::sth::sthCore::invoke stc::config $vlanif2 -stackedonendpoint-targets $ethif
        set stack4ip $vlanif1
        if {$pppoe == 1} {
            ::sth::sthCore::invoke stc::config $pppoeif -stackedonendpoint-Targets $vlanif1
        }
    } elseif {1 == $vlans} {
        set vlanif1 [lindex $vlanifList 0]
        ::sth::sthCore::invoke stc::config $vlanif1 -stackedonendpoint-targets $ethif
        set stack4ip $vlanif1
        if {$pppoe == 1} {
            ::sth::sthCore::invoke stc::config $pppoeif -stackedonendpoint-Targets $vlanif1
        }
    } else {
        if {$pppoe == 1} {
            ::sth::sthCore::invoke stc::config $pppoeif -stackedonendpoint-Targets $ethif
        }
    }
    
    if {($ipv4if != "") && ($ipv6ifList != "")} {
        if {$pppoe == 1} {
            ::sth::sthCore::invoke stc::config $device -primaryif-targets "$ipv4if $ipv6if $ipv6iflocal"
            ::sth::sthCore::invoke stc::config $device -toplevelif-targets "$ipv4if $ipv6if $ipv6iflocal"
            ::sth::sthCore::invoke stc::config $ipv4if -stackedonendpoint-targets [lindex $pppifList 0]
            ::sth::sthCore::invoke stc::config $ipv6if -stackedonendpoint-targets [lindex $pppifList 1]
            ::sth::sthCore::invoke stc::config $ipv6iflocal -stackedonendpoint-targets [lindex $pppifList 2]
        } else {
            ::sth::sthCore::invoke stc::config $device -primaryif-targets "$ipv4if $ipv6if $ipv6iflocal"
            ::sth::sthCore::invoke stc::config $device -toplevelif-targets "$ipv4if $ipv6if $ipv6iflocal"
            ::sth::sthCore::invoke stc::config $ipv4if -stackedonendpoint-targets $stack4ip
            ::sth::sthCore::invoke stc::config $ipv6if -stackedonendpoint-targets $stack4ip
            ::sth::sthCore::invoke stc::config $ipv6iflocal -stackedonendpoint-targets $stack4ip
        }
        ::sth::sthCore::invoke stc::apply
        return
    }
    if {$ipv4if != ""} {
        if {$pppoe == 1} {
            ::sth::sthCore::invoke stc::config $device -primaryif-targets "$ipv4if"
            ::sth::sthCore::invoke stc::config $device -toplevelif-targets "$ipv4if"
            ::sth::sthCore::invoke stc::config $ipv4if -stackedonendpoint-targets [lindex $pppifList 0]
        } else {
            ::sth::sthCore::invoke stc::config $device -primaryif-targets "$ipv4if"
            ::sth::sthCore::invoke stc::config $device -toplevelif-targets "$ipv4if"
            ::sth::sthCore::invoke stc::config $ipv4if -stackedonendpoint-targets $stack4ip
        }
        ::sth::sthCore::invoke stc::apply
        return
    }
    if {$ipv6ifList != ""} {
        if {$pppoe == 1} {
            ::sth::sthCore::invoke stc::config $device -primaryif-targets "$ipv6if $ipv6iflocal"
            ::sth::sthCore::invoke stc::config $device -toplevelif-targets "$ipv6if $ipv6iflocal"
            ::sth::sthCore::invoke stc::config $ipv6if -stackedonendpoint-targets [lindex $pppifList 0]
            ::sth::sthCore::invoke stc::config $ipv6iflocal -stackedonendpoint-targets [lindex $pppifList 1]
        } else {
            ::sth::sthCore::invoke stc::config $device -primaryif-targets "$ipv6if $ipv6iflocal"
            ::sth::sthCore::invoke stc::config $device -toplevelif-targets "$ipv6if $ipv6iflocal"
            ::sth::sthCore::invoke stc::config $ipv6if -stackedonendpoint-targets $stack4ip
            ::sth::sthCore::invoke stc::config $ipv6iflocal -stackedonendpoint-targets $stack4ip
        }
        ::sth::sthCore::invoke stc::apply
        return
    }

}

###West Jan 2016###
###This funciton will clear non-necessary modifier, like not input XXXXX_count or eq 1
proc ::spirent::count_traffic_config_modifier {args} {
    set ret ""
    set modifier_key_list "mac_dst mac_src mac_dst2 mac_src2 mpls_labels
    mpls_cos mpls_ttl vpi vci vlan_id vlan_user_priority vlan_id_outer vlan_id_other
    ip_precedence ip_tos ip_dscp ip_dst ip_src ipv6_dst ipv6_src ip_dst_outer
    ip_src_outer ipv6_dst_outer ipv6_src_outer arp_src_hw arp_dst_hw
    tcp_src_port tcp_dst_port udp_dst_port udp_src_port mac_discovery_gw
    igmp_group inner_ip_dst inner_ip_src inner_ip_gw inner_mac_dst
    inner_mac_src inner_vlan_id inner_vlan_priority inner_vlan_id_outer"
    foreach modifier_key $modifier_key_list {
        if {[lsearch $args "-$modifier_key\_count"] > -1} {
            set count [lindex $args [expr [lsearch $args "-$modifier_key\_count"] + 1]]
            if {$count > 1} {
                set ret "$ret $modifier_key"
            }
        }
    }
    return $ret
}

proc ::spirent::traffic_config_step_power2 {args} {
    set ret ""
    keylset ret flag 1
    keylset ret key ""
    set modifier_key_list "ip_dst ip_src"
    foreach modifier_key $modifier_key_list {
        if {[lsearch $args "-$modifier_key\_step"] > -1} {
            set step [lindex $args [expr [lsearch $args "-$modifier_key\_step"] + 1]]
            set stepVal [::wrapper::ConvertIpAddressAsInteger $step]
            if {0 != [expr $stepVal & $stepVal - 1]} {
                keylset ret flag 0
                keylset ret key $modifier_key
                return $ret
            }
        }
    }
    return $ret
}

###This funciton will clear non-necessary modifier, like not input XXXXX_count
proc ::spirent::handle_traffic_config_modifier {args} {
    set argstemp $args
    set modifier_key_list "mac_src_ mac_dst2_ mac_src2_ mpls_labels_
    mpls_cos_ mpls_ttl_ vpi_ vci_ vlan_id_ vlan_priority_ vlan_id_outer_ vlan_id_other_
    ip_precedence_ ip_tos_ ip_dscp_ ip_dst_ ip_src_ ipv6_dst_ ipv6_src_ ip_dst_outer_
    ip_src_outer_ ipv6_dst_outer_ ipv6_src_outer_ arp_src_hw_ arp_dst_hw_
    tcp_src_port_ tcp_dst_port_ udp_dst_port_ udp_src_port_ mac_discovery_gw_
    igmp_group_ inner_ip_dst_ inner_ip_src_ inner_ip_gw_ inner_mac_dst_
    inner_mac_src_ inner_vlan_id_ inner_vlan_priority_ inner_vlan_id_outer_"
    foreach modifier_key $modifier_key_list {
        if {[lsearch $args "-$modifier_key\count"] > -1} {
            continue
        }
        set argstemp [::wrapper::shield_args -total $argstemp -unsupported "$modifier_key\mode $modifier_key\step"]
    }
    return $argstemp
}


proc ::ixiangpf::interface_config { args } {
    keylset result status 1
    variable ::spirent::multivalueHdl
    ###interface config here will configure protocol by protocol(vlan|ipv4|ipv6)
    set protocol_type "ethernet"
    if {([lsearch $args "-intf_ip_addr"] > -1)} {
        set protocol_type "ipv4"
    }
    
    ##ixia arp_req_retries default is 2, while STC is 3. It can help speed up 1 s.
    if {([lsearch $args "-arp_req_retries"] == -1)} {
        set arpconfig [::sth::sthCore::invoke stc::get project1 -children-arpndconfig]
        ::sth::sthCore::invoke stc::config $arpconfig -RetryCount 2
    }
    ##ixia arp_req_timeout default is 10, while STC is 1000. It can help speed up 1 s.
    if {([lsearch $args "-arp_req_timeout"] == -1)} {

        set arpconfig [::sth::sthCore::invoke stc::get project1 -children-arpndconfig]
        ::sth::sthCore::invoke stc::config $arpconfig -TimeOut 10
    }
    
    if {([lsearch $args "-ipv6_intf_addr"] > -1)} {
        set protocol_type "ipv6"
    }
    
    if {([lsearch $args "-protocol_handle"] > -1)} {
        set protocol_handle [lindex $args [expr {[lsearch $args "-protocol_handle"] + 1}]]
    } else {
        keylset result status 1
        keylset result log "not found protocol_handle in ::ixiangpf::interface_config"
        return $result
    }
    ::spirent::listToArray $args argArray
    
    if {[info exist argArray(-vlan)] && ( $argArray(-vlan) == 0)} {
        array unset argArray -vlan_id
        array unset argArray -vlan_id_step
        array unset argArray -vlan_user_priority
        array unset argArray -vlan_id_count
        array unset argArray -vlan_tpid
        array unset argArray -vlan_user_priority_step
    }
    
    if {[info exist argArray(-vlan_user_priority_step)]} {
        unset argArray(-vlan_user_priority_step)
    }
    
    if {[info exist argArray(-src_mac_addr)]} {
        set argArray(-mac_addr) $argArray(-src_mac_addr)
        unset argArray(-src_mac_addr)
    }
    if {[info exist argArray(-src_mac_addr_step)]} {
        set argArray(-mac_addr_step) $argArray(-src_mac_addr_step)
        unset argArray(-src_mac_addr_step)
    }
    if {[info exist argArray(-vlan_user_priority)]} {
        set argArray(-vlan_user_pri) $argArray(-vlan_user_priority)
        unset argArray(-vlan_user_priority)
    }
    
    set vlannum 0
    set vlans_count 0
    set vlan_outer_type 0x8100
    set vlan_type 0x8100
    if {[info exist argArray(-vlan_id_count)]} {
        set vlans_count $argArray(-vlan_id_count)
        if {$argArray(-vlan_id_count) == 2} {
            if {[info exist argArray(-vlan_id)]} {
                set tempval [split $argArray(-vlan_id) ","]
                set argArray(-vlan_id) [lindex $tempval 1]
                set argArray(-vlan_outer_id) [lindex $tempval 0]
            }
            if {[info exist argArray(-vlan_id_step)]} {
                set tempval [split $argArray(-vlan_id_step) ","]
                set argArray(-vlan_id_step) [lindex $tempval 1]
                set argArray(-vlan_outer_id_step) [lindex $tempval 0]
            }
            if {[info exist argArray(-vlan_user_pri)]} {
                set tempval [split $argArray(-vlan_user_pri) ","]
                set argArray(-vlan_user_pri) [lindex $tempval 1]
                set argArray(-vlan_outer_user_pri) [lindex $tempval 0]
            }
            if {[info exist argArray(-vlan_user_priority_step)]} {
                unset argArray(-vlan_user_priority_step)
            }
            if {[info exist argArray(-vlan_tpid)]} {
                set tempval [split $argArray(-vlan_tpid) ","]
                set vlan_type [lindex $tempval 1]
                set vlan_outer_type [lindex $tempval 0]
                unset argArray(-vlan_tpid)
            }
        } elseif {$argArray(-vlan_id_count) == 1} {
            if {[info exist argArray(-vlan_tpid)]} {
                set vlan_type $argArray(-vlan_tpid)
                unset argArray(-vlan_tpid)
            }
        }
        set vlannum $argArray(-vlan_id_count)
        unset argArray(-vlan_id_count)
    } elseif {[info exist argArray(-vlan_tpid)]} {
        set vlan_type $argArray(-vlan_tpid)
        unset argArray(-vlan_tpid)
        set vlannum 1
    }
    
    array unset argArray -protocol_handle
    array unset argArray -protocol_name
    array unset argArray -vlan
    #array unset argArray -mtu
    set mtu 1500
    if {[info exist argArray(-mtu)]} {
        set mtu $argArray(-mtu)
        unset argArray(-mtu)
    }
    array unset argArray -use_vpn_parameters
    array unset argArray -site_id
    array unset argArray -ipv6_multiplier
    array unset argArray -ipv4_multiplier
    
    switch -- $protocol_type {
        ethernet {
            ###modify Ether/vlan protocol
            set deviceList [::sth::sthCore::invoke stc::get $protocol_handle -groupmembership-Targets]
            set etherHdlList ""
            foreach device $deviceList {
                set process_args [array get argArray]
                set vlans [llength [::sth::sthCore::invoke stc::get $device -children-vlanif]]
                for {set i 0} {$i < [expr $vlannum - $vlans]} {incr i} {
                    ::sth::sthCore::invoke stc::create vlanif -under $device
                }
                ::spirent::update_device_stack $device
                lappend process_args "-handle" $device "-mode" modify
                set cmdName "sth::emulation_device_config $process_args"
                set ret [::spirent::process_cmd $cmdName]
                lappend etherHdlList [::sth::sthCore::invoke stc::get $device -children-ethiiif]
                
                set Vlanlist [::sth::sthCore::invoke stc::get $device -children-vlanif]
                if {$vlannum == 2} {
                    ::sth::sthCore::invoke stc::config [lindex $Vlanlist 1] -Tpid $vlan_outer_type
                    ::sth::sthCore::invoke stc::config [lindex $Vlanlist 0] -Tpid $vlan_type
                } elseif {$vlannum == 1} {
                    ::sth::sthCore::invoke stc::config [lindex $Vlanlist 0] -Tpid $vlan_type
                }
                
                set port [::sth::sthCore::invoke stc::get $device -affiliationport-Targets]
                set portphy [::sth::sthCore::invoke stc::get $port -activephy-Targets]
				if {$portphy ne ""} {
					::sth::sthCore::invoke stc::config $portphy -mtu $mtu
				}
            }
            keylset result ethernet_handle $etherHdlList
            keylset result interface_handle $etherHdlList
        }
        ipv4 {
            ###Add ipv4 protocol
            set device [::sth::sthCore::invoke stc::get $protocol_handle -parent]
            if {"" == [::sth::sthCore::invoke stc::get $device -children-ipv4if]} {
                ::sth::sthCore::invoke stc::create ipv4if -under $device
                ::spirent::update_device_stack $device
            }
            if {[info exist argArray(-intf_ip_addr)]} {
                if {[regexp -nocase "multivalue" $argArray(-intf_ip_addr)]} {
                    ::spirent::listToArray $::spirent::multivalueHdl($argArray(-intf_ip_addr)) multivalueArray
                    set argArray(-intf_ip_addr) $multivalueArray(-counter_start)
                    set argArray(-intf_ip_addr_step) $multivalueArray(-counter_step)
                } 
            }
            if {[info exist argArray(-gateway)]} {
                set argArray(-gateway_ip_addr) $argArray(-gateway)
                unset argArray(-gateway)
            }
            if {[info exist argArray(-gateway_step)]} {
                set argArray(-gateway_ip_addr_step) $argArray(-gateway_step)
                unset argArray(-gateway_step)
            }
            if {[info exist argArray(-netmask)]} {
                set argArray(-intf_prefix_len) [::sth::Session::getPrefixLength 4 $argArray(-netmask)]
                unset argArray(-netmask)
            }
            if {[info exist argArray(-ipv4_resolve_gateway)]} {
                set argArray(-resolve_gateway_mac) $argArray(-ipv4_resolve_gateway)
                unset argArray(-ipv4_resolve_gateway)
                if {$argArray(-resolve_gateway_mac) == 1} {
                    set argArray(-resolve_gateway_mac) "true"
                } else {
                    set argArray(-resolve_gateway_mac) "false"
                }
            }
            if {[info exist argArray(-ipv4_manual_gateway_mac)]} {
                set argArray(-gateway_mac) $argArray(-ipv4_manual_gateway_mac)
                unset argArray(-ipv4_manual_gateway_mac)
            }
            if {[info exist argArray(-ipv4_manual_gateway_mac_step)]} {
                unset argArray(-ipv4_manual_gateway_mac_step)
            }
            
            set process_args [array get argArray]
            lappend process_args "-handle" $device "-mode" modify
            set cmdName "sth::emulation_device_config $process_args"
            set ret [::spirent::process_cmd $cmdName]
            set ipv4Hdl [::sth::sthCore::invoke stc::get $device -children-ipv4if]
            keylset result ipv4_handle $ipv4Hdl
            keylset result interface_handle $ipv4Hdl
        }
        ipv6 {
            ###Add ipv6 protocol
            set device [::sth::sthCore::invoke stc::get $protocol_handle -parent]
            if {"" == [::sth::sthCore::invoke stc::get $device -children-ipv6if]} {
                ::sth::sthCore::invoke stc::create ipv6if -under $device
                set linklocal [::sth::sthCore::invoke stc::create ipv6if -under $device -Address fe80::1]
                ::sth::sthCore::invoke stc::config $linklocal -AllocateEui64LinkLocalAddress true 
                ::spirent::update_device_stack $device
            }
            if {[info exist argArray(-ipv6_intf_addr)]} {
                if {[regexp -nocase "multivalue" $argArray(-ipv6_intf_addr)]} {
                    ::spirent::listToArray $::spirent::multivalueHdl($argArray(-ipv6_intf_addr)) multivalueArray
                    set argArray(-intf_ipv6_addr) $multivalueArray(-counter_start)
                    set argArray(-intf_ipv6_addr_step) $multivalueArray(-counter_step)
                } else {
                    set argArray(-intf_ipv6_addr) $argArray(-ipv6_intf_addr)
                }
                unset argArray(-ipv6_intf_addr)
            }
            if {[info exist argArray(-ipv6_gateway)]} {
                if {[regexp -nocase "multivalue" $argArray(-ipv6_gateway)]} {
                    ::spirent::listToArray $::spirent::multivalueHdl($argArray(-ipv6_gateway)) multivalueArray
                    set argArray(-gateway_ipv6_addr) $multivalueArray(-counter_start)
                    set argArray(-gateway_ipv6_addr_step) $multivalueArray(-counter_step)
                } else {
                set argArray(-gateway_ipv6_addr) $argArray(-ipv6_gateway)
                }
                unset argArray(-ipv6_gateway)
            }
            if {[info exist argArray(-ipv6_gateway_step)]} {
                set argArray(-gateway_ipv6_addr_step) $argArray(-ipv6_gateway_step)
                unset argArray(-ipv6_gateway_step)
            }
            if {[info exist argArray(-ipv6_prefix_length)]} {
                set argArray(-intf_ipv6_prefix_len) $argArray(-ipv6_prefix_length)
                unset argArray(-ipv6_prefix_length)
            }
            if {[info exist argArray(-ipv6_resolve_gateway)]} {
                set argArray(-ipv6_resolve_gateway_mac) $argArray(-ipv6_resolve_gateway)
                unset argArray(-ipv6_resolve_gateway)
                if {$argArray(-ipv6_resolve_gateway_mac) == 1} {
                    set argArray(-ipv6_resolve_gateway_mac) "true"
                } else {
                    set argArray(-ipv6_resolve_gateway_mac) "false"
                }
            }
            if {[info exist argArray(-ipv6_manual_gateway_mac)]} {
                set argArray(-ipv6_gateway_mac) $argArray(-ipv6_manual_gateway_mac)
                unset argArray(-ipv6_manual_gateway_mac)
            }
            if {[info exist argArray(-ipv6_manual_gateway_mac_step)]} {
                unset argArray(-ipv6_manual_gateway_mac_step)

            }
            if {[info exist argArray(-ipv6_intf_addr_step)]} {
                set argArray(-intf_ipv6_addr_step) $argArray(-ipv6_intf_addr_step)
                unset argArray(-ipv6_intf_addr_step)
            }
            
            set process_args [array get argArray]
            lappend process_args "-handle" $device "-mode" modify
            set cmdName "sth::emulation_device_config $process_args"
            set ret [::spirent::process_cmd $cmdName]
            set ipv6Hdl [lindex [::sth::sthCore::invoke stc::get $device -children-ipv6if] 0]
            keylset result ipv6_handle $ipv6Hdl
            keylset result interface_handle $ipv6Hdl        
        }
    }
    return $result
}

proc ::ixiangpf::multivalue_config { args } {
    keylset result status 1
    ::spirent::listToArray $args argArray
    ##only supports -pattern : counter for the time being
    variable ::spirent::multivalueHdl
    variable ::spirent::multivalueInd
    set modifier ""
    set modifierName "multivalue$::spirent::multivalueInd"
    incr ::spirent::multivalueInd
    if {[info exist argArray(-counter_start)]} {
        lappend modifier "-counter_start" $argArray(-counter_start)
    }
    if {[info exist argArray(-counter_step)]} {
        lappend modifier "-counter_step" $argArray(-counter_step)
    }
    set ::spirent::multivalueHdl($modifierName) $modifier
    keylset result multivalue_handle $modifierName
    return $result
}

proc ::ixiangpf::pppox_config { args } {
    ::spirent::listToArray $args argArray
    set device ""
    keylset result status 1
    if {[info exist argArray(-handle)]} {
        set device [::sth::sthCore::invoke stc::get $argArray(-handle) -parent]
        unset argArray(-handle)
    } else {
        variable ::spirent::topoHdl_devicegroupHdl
        variable ::spirent::currentTopoHdl
        set deviceGroup $::spirent::topoHdl_devicegroupHdl($::spirent::currentTopoHdl)
        set device [::sth::sthCore::invoke stc::get $deviceGroup -groupmembership-Targets]
    }
    set port [::sth::sthCore::invoke stc::get $device -affiliationport-Targets]
    set argArray(-handle) $device
    set dual_stack 0
    
    if {[info exist argArray(-ip_cp)]} {
        switch -- $argArray(-ip_cp) {
            dual_stack {
                set argArray(-ip_cp) "ipv4v6_cp"
                set dual_stack 1
            }
            default {
                ##keep same for ipv4_cp|ipv6_cp
            }
        }
    } else {
        set argArray(-ip_cp) "ipv4_cp"
    }
    
    ###check and create ipif if needed
    set ipv4if ""
    set ipv6if ""
    if {[regexp -nocase "4" $argArray(-ip_cp)]} {
        if {"" == [::sth::sthCore::invoke stc::get $device -children-ipv4if]} {
            set ipv4if [::sth::sthCore::invoke stc::create ipv4if -under $device]
            ::spirent::update_device_stack $device
        } else {
            set ipv4if [::sth::sthCore::invoke stc::get $device -children-ipv4if]
        }
    }
    if {[regexp -nocase "6" $argArray(-ip_cp)]} {
        if {"" == [::sth::sthCore::invoke stc::get $device -children-ipv6if]} {
            set ipv6if [::sth::sthCore::invoke stc::create ipv6if -under $device]
            set linklocal [::sth::sthCore::invoke stc::create ipv6if -under $device -Address fe80::1]
            ::sth::sthCore::invoke stc::config $linklocal -AllocateEui64LinkLocalAddress true
            ::spirent::update_device_stack $device
        } else {
            set ipv6if [lindex [::sth::sthCore::invoke stc::get $device -children-ipv6if] 0]
        }
    }
    
    if {![info exist ::sth::Pppox::PPPOXCLIENTROBJTYPE($port)]} {
        set pppox_client_handle [::sth::sthCore::invoke stc::create PppoeClientBlockConfig -under $device]
        if {"" != $ipv4if} {
            ::sth::sthCore::invoke stc::config $pppox_client_handle -usesif-Targets $ipv4if
            if {$dual_stack == 1} {
                ::sth::sthCore::invoke stc::create pppif -under $device
                ::sth::sthCore::invoke stc::create pppif -under $device -ProtocolId PPP_PROTOCOL_ID_IPV6
                ::sth::sthCore::invoke stc::create pppif -under $device -ProtocolId PPP_PROTOCOL_ID_IPV6
            } else {
                ::sth::sthCore::invoke stc::create pppif -under $device
            }
        } else {
            ::sth::sthCore::invoke stc::config $pppox_client_handle -usesif-Targets $ipv6if
            ::sth::sthCore::invoke stc::create pppif -under $device -ProtocolId PPP_PROTOCOL_ID_IPV6
            ::sth::sthCore::invoke stc::create pppif -under $device -ProtocolId PPP_PROTOCOL_ID_IPV6
        }
        ::sth::sthCore::invoke stc::create pppoeif -under $device
        ::spirent::update_device_stack $device
        set ::sth::Pppox::PPPOXCLIENTROBJTYPE($port) "pppoe"
    }
    array unset argArray -mode
    set argArray(-mode) "modify"
    
    array unset argArray -protocol_name
    array unset argArray -client_wins_options
    array unset argArray -client_wins_primary_address
    array unset argArray -client_dns_secondary_address
    array unset argArray -client_wins_secondary_address
    array unset argArray -client_dns_primary_address
    array unset argArray -chap_secret
    if {[info exist argArray(-chap_name)]} {
        set argArray(-username) $argArray(-chap_name)
        unset argArray(-chap_name)
    }
    if {[info exist argArray(-actual_rate_upstream)]} {
        set argArray(-attempt_rate) $argArray(-actual_rate_upstream)
        unset argArray(-actual_rate_upstream)
    }
    if {[info exist argArray(-actual_rate_downstream)]} {
        set argArray(-disconnect_rate) $argArray(-actual_rate_downstream)
        unset argArray(-actual_rate_downstream)
    }
    ##only support data_link as ethernet
    array unset argArray -data_link
    array unset argArray -client_ipv4_ncp_configuration
    array unset argArray -client_ipv6_ncp_configuration
    array unset argArray -client_netmask_options
    array unset argArray -client_netmask
    
    ##valid only when lcp_enable_accm is true
    ##and STC doesn't support accm/dns/client settting
    array unset argArray -lcp_accm
    
    array unset argArray -enable_max_payload
    array unset argArray -desired_mru_rate
    ##port_role access|network means PPPoXclient|server
    ##Since script is always use access, unset it here
    array unset argArray -port_role
    
    ###From ixia default value
    set max_payload 1492
    if {[info exist argArray(-max_payload)]} {
        set max_payload $argArray(-max_payload)
        unset argArray(-max_payload)
    }
    
    set process_args [array get argArray]
    set cmdName "sth::pppox_config $process_args"
    set ret [::spirent::process_cmd $cmdName]
    set pppox_client_handle [::sth::sthCore::invoke stc::get $device -children-PppoeClientBlockConfig]
    ::sth::sthCore::invoke stc::config $pppox_client_handle -MaxPayloadBytes $max_payload
    keylset result pppox_client_handle $pppox_client_handle
    keylset result handle $pppox_client_handle
    return $result
}

proc ::ixiangpf::emulation_dhcp_group_config { args } {
    ::spirent::listToArray $args argArray
    set device ""
    keylset result status 1
    if {[info exist argArray(-handle)]} {
        set device [::sth::sthCore::invoke stc::get $argArray(-handle) -parent]
        unset argArray(-handle)
    } else {
        variable ::spirent::topoHdl_devicegroupHdl
        variable ::spirent::currentTopoHdl
        set deviceGroup $::spirent::topoHdl_devicegroupHdl($::spirent::currentTopoHdl)
        set device [::sth::sthCore::invoke stc::get $deviceGroup -groupmembership-Targets]
    }
    set port [::sth::sthCore::invoke stc::get $device -affiliationport-Targets]
    set argArray(-handle) $device
	
	##Add enable_auto_retry default value to make HLTAPI work
	#if {![info exist argArray(-enable_auto_retry)]} {
	#	set argArray(-enable_auto_retry) "false"
	#}
	
	regsub -all "ipv" $argArray(-dhcp_range_ip_type) "" argArray(-dhcp_range_ip_type)
    
    ###check and create ipif if needed
    set ipv4if ""
    set ipv6if ""
    if {[regexp -nocase "4" $argArray(-dhcp_range_ip_type)]} {
        if {"" == [::sth::sthCore::invoke stc::get $device -children-ipv4if]} {
            set ipv4if [::sth::sthCore::invoke stc::create ipv4if -under $device]
		::sth::sthCore::invoke stc::config $ipv4if -Gateway 130.1.0.1
            ::spirent::update_device_stack $device
        } else {
            set ipv4if [::sth::sthCore::invoke stc::get $device -children-ipv4if]
        }
    }
    if {[regexp -nocase "6" $argArray(-dhcp_range_ip_type)]} {
        if {"" == [::sth::sthCore::invoke stc::get $device -children-ipv6if]} {
            set ipv6if [::sth::sthCore::invoke stc::create ipv6if -under $device]
            set linklocal [::sth::sthCore::invoke stc::create ipv6if -under $device -Address fe80::1]
            ::sth::sthCore::invoke stc::config $linklocal -AllocateEui64LinkLocalAddress true
            ::spirent::update_device_stack $device
        } else {
            set ipv6if [lindex [::sth::sthCore::invoke stc::get $device -children-ipv6if] 0]
        }
    }
    
    
    array unset argArray -mode
    set argArray(-mode) "enable"
    
    array unset argArray -protocol_name
    
    set process_args [array get argArray]
    set cmdName "sth::emulation_dhcp_group_config $process_args"
    set ret [::spirent::process_cmd $cmdName]
    if {$ipv4if != ""} {
        keylset result dhcpv4client_handle [::sth::sthCore::invoke stc::get $device -children-Dhcpv4BlockConfig]
        #keylset result dhcpv4client_handle $device
    } elseif { $ipv6if != "" } {
        keylset result dhcpv6client_handle [::sth::sthCore::invoke stc::get $device -children-Dhcpv6BlockConfig]
        #keylset result dhcpv6client_handle $device
    }
    return $result
}

proc ::ixiangpf::traffic_config { args } {
    keylset result status 1
	if {[lsearch $args "-bidirectional"] > -1} {
		set ::spirent::traffic_bidirectional 1
        set index [lsearch $args "-bidirectional"]
        set bidirectional [lindex $args [expr $index + 1]]
			if {($bidirectional == 1) && ([lsearch $args "-port_handle2"] < 0)} {
				##Add port_handle2 for bidirectional
				if {[lsearch $args "-emulation_dst_handle"] > -1} {
					set index [lsearch $args "-emulation_dst_handle"]
					set emulation_dst_handle [lindex $args [expr $index + 1]]
					if {[regexp -nocase "devicegroup" $emulation_dst_handle] } {
						set device [::sth::sthCore::invoke stc::get $emulation_dst_handle -groupmembership-Targets]
						if {$device ne ""} {
							set args "$args -port_handle2 [::sth::sthCore::invoke stc::get $device -affiliationport-Targets]"
						}
					}
				}
			}
			
			if {($bidirectional == 1) && ([lsearch $args "-port_handle"] < 0)} {
				##Add port_handle for bidirectional
				if {[lsearch $args "-emulation_src_handle"] > -1} {
					set index [lsearch $args "-emulation_src_handle"]
					set emulation_src_handle [lindex $args [expr $index + 1]]
					if {[regexp -nocase "devicegroup" $emulation_src_handle] } {
						set device [::sth::sthCore::invoke stc::get $emulation_src_handle -groupmembership-Targets]
						if {$device ne ""} {
							set args "$args -port_handle [::sth::sthCore::invoke stc::get $device -affiliationport-Targets]"
						}
					}
				}
			}
	}
    set cmdName "::ixia::traffic_config $args"
    set ret [eval $cmdName]
	
	##skip here since the Ericsson frame work doesn't for return vlaue is list 
	if {0} {
		set streamlist [keylget ret stream_id]
		set streamlistret ""
		if {[regexp -nocase "port" [keylkeys streamlist]]} {
			foreach key [keylkeys streamlist] {
				lappend streamlistret [keylget streamlist $key]
			}
		}
		keylset ret stream_id $streamlistret
	}
	if {1} {
		##add for the 1st script here 30 Jul 2016
		if {[lsearch $args "-port_handle"] > -1} {
			set index [lsearch $args "-port_handle"]
			set port_handle [lindex $args [expr $index + 1]]
			set streamlist [keylget ret stream_id]
			if {[regexp -nocase "port" [keylkeys streamlist]]} {
				keylset ret stream_id [keylget ret stream_id.$port_handle]
			}
		}
	}
	return $ret
}

proc ::ixia::uds_config { args} {

	################################################
    ##
    ## step 1: set variables
    ## step 2: convert args vlaues to STC style
    ## step 3: Unset variables which is not is STC
    ##
    ################################################


    #########################
    ## step 1: set variables
    #########################

    global return_list
    array set argArray {}
    
    ############################################
    ## step 2: convert args values to STC style
    ############################################
    
    ## convert physical port
    set args [eval ::spirent::port_converter $args]
    ## List to Array
    ::spirent::listToArray $args argArray

    ###############################################
    ## step 3: Unset variables which is not is STC
    ###############################################
	
    array unset argArray 
	
}

proc ::ixia::uds_filter_pallette_config { args} {

    #puts $args
    return [eval ::spirent::packet_config_filter $args]

}

proc ::ixiangpf::cleanup_session { args } {
    catch {
    keylset result status 1
    
    set ixia_only_args "reset"
    set args [wrapper::shield_args -total $args -unsupported $ixia_only_args]
    
    ###clear global variables
    variable ::spirent::portHdl_topoHdl
    variable ::spirent::topoHdl_portHdl
    variable ::spirent::topoInd
    variable ::spirent::deviceGroupInd
    variable ::spirent::topoHdl_devicegroupHdl
    variable ::spirent::multivalueHdl
    variable ::spirent::multivalueInd
    variable ::spirent::currentTopoHdl
    
    array unset ::spirent::portHdl_topoHdl
    array unset ::spirent::topoHdl_portHdl
    array unset ::spirent::topoHdl_devicegroupHdl
    array unset ::spirent::multivalueHdl
    array set ::spirent::portHdl_topoHdl {}
    array set ::spirent::topoHdl_portHdl {}
    set ::spirent::topoInd 1
    set ::spirent::deviceGroupInd 1
    array set ::spirent::topoHdl_devicegroupHdl {}
    array set ::spirent::multivalueHdl {}
    set ::spirent::multivalueInd 1
    set ::spirent::currentTopoHdl ""
    
    foreach deviceGroup [::sth::sthCore::invoke stc::get project1 -children-devicegroup] {
        ::sth::sthCore::invoke stc::delete $deviceGroup
    }
    
    ##clear all counter and index added NGPF
    if {([lsearch $args "-port_handle"] > -1)} {
        set cmdName "::spirent::cleanup_session $args"
    } elseif {[::sth::sthCore::invoke stc::get project1 -children-port] != ""} {
        set args "$args -port_handle [list [::sth::sthCore::invoke stc::get project1 -children-port]]"
        set cmdName "::spirent::cleanup_session $args"
    } else {
        return $result
    }
    return [eval $cmdName]
    }
}

proc ::ixiangpf::traffic_stats { args } {

    set stream_count 0
    set port_list [::sth::sthCore::invoke stc::get project1 -children-port]
    
    foreach item "$port_list project1" {
        set streamList [::sth::sthCore::invoke stc::get $item -children-streamblock]
        set stream_count [expr $stream_count + [llength $streamList]] 
    }

    #-mode {traffic_item} -measure_mode {mixed} -traffic_generator {ixnetwork_540}
    ##Just convert it into -mode all -port_handle all ports
    set args "-mode all -port_handle $port_list"
    
    set cmdName "::ixia::traffic_stats $args"
    set result [eval $cmdName]
    
    keylset result measure_mode "mixed"
    
    keylset ngpfagg tx ""
    keylset ngpfagg rx ""
    
    foreach port $port_list {
        ##copy all stream info from ports into traffic_item
        if {([lsearch [keylkeys result $port] "stream"] > -1)} {
            foreach streamblock [keylkeys result $port.stream] {
                if {($streamblock ne "unknown") &&([::sth::sthCore::invoke stc::get streamblock$streamblock -parent] eq "$port")} {
                    ##calculate loss_percent and add it
                    if {[keylget result $port.stream.$streamblock.tx.total_pkts] == 0} {
                        keylset result $port.stream.$streamblock.rx.loss_percent 0
                    } else {
                        keylset result $port.stream.$streamblock.rx.loss_percent \
                        [expr 100 * double([expr [keylget result $port.stream.$streamblock.tx.total_pkts] \
                        - [keylget result $port.stream.$streamblock.rx.total_pkts]])/ \
                        double([keylget result $port.stream.$streamblock.tx.total_pkts])]
                    }
                    keylset result traffic_item.$streamblock [keylget result $port.stream.$streamblock]
                }
            }
        }
        
        ##add aggregate info from ports into traffic_item
        foreach key [keylkeys result $port.aggregate.rx] {
            if {([lsearch [keylkeys ngpfagg rx] $key] > -1)} {
                if {([lsearch [keylget result $port.aggregate.rx.$key] "null"] < 0)} {
                    keylset ngpfagg rx.$key [expr [keylget ngpfagg rx.$key] + [keylget result $port.aggregate.rx.$key]]
                }
            } else {
                keylset ngpfagg rx.$key [keylget result $port.aggregate.rx.$key]
            }
        }
        foreach key [keylkeys result $port.aggregate.tx] {
            if {([lsearch [keylkeys ngpfagg tx] $key] > -1)} {
                if {([lsearch [keylget result $port.aggregate.tx.$key] "null"] < 0) && ([keylget ngpfagg tx.$key] != "")} {
                    keylset ngpfagg tx.$key [expr [keylget ngpfagg tx.$key] + [keylget result $port.aggregate.tx.$key]]
                }
            } else {
                keylset ngpfagg tx.$key [keylget result $port.aggregate.tx.$key]
            }
        }
        
    }
    
    ##expand aggregare into sum+avg+max+min+count
    foreach key [keylkeys ngpfagg rx] {
        set temp ""
        keylset temp sum [keylget ngpfagg rx.$key]
        keylset temp avg [keylget ngpfagg rx.$key]
        keylset temp max [keylget ngpfagg rx.$key]
        keylset temp min [keylget ngpfagg rx.$key]
        keylset temp count $stream_count
        keylset ngpfagg rx.$key $temp
    }
    foreach key [keylkeys ngpfagg tx] {
        set temp ""
        keylset temp sum [keylget ngpfagg tx.$key]
        keylset temp avg [keylget ngpfagg tx.$key]
        keylset temp max [keylget ngpfagg tx.$key]
        keylset temp min [keylget ngpfagg tx.$key]
        keylset temp count $stream_count
        keylset ngpfagg tx.$key $temp
    }
    
    set temp ""
    keylset temp count $stream_count
    keylset ngpfagg tx.last_tstamp $temp
    keylset ngpfagg tx.first_tstamp $temp
    
    keylset result traffic_item.aggregate $ngpfagg
    
    ##delete legacy keys of port level
    foreach port $port_list {
        keyldel result $port
    } 
    return $result
}
# Help procs end
} szError]} {
   global errorInfo
   puts "Error:\t$szError"
   puts "Trace:\t$errorInfo"
}
proc ::ixiangpf::emulation_dhcp_control {args} {
    set ixia_only_args "abort_async restart_down send_ping start_realy_agent stop_relay_agent"
    set args [wrapper::shield_args -total $args -unsupported $ixia_only_args]
    ::spirent::listToArray $args argArray
    set devicelist ""
    #keylset result status 1
    if {[info exists argArray(-port_handle)]} {
        set devicelist [::sth::sthCore::invoke stc::get $argArray(-port_handle) -affiliationport-sources]
        unset argArray(-port_handle)
    } elseif  {[info exists argArray(-handle)]} {
	    foreach handle $argArray(-handle) {
		    lappend devicelist [::sth::sthCore::invoke stc::get $handle -parent]		
		}
        unset argArray(-handle)
    }
    if {[info exists argArray(-action)]} {
        set action $argArray(-action)
        unset argArray(-action)
    }
    foreach device $devicelist {
        set ip_version ""
        set cmdName ""
        if {[regexp -nocase "4" [::sth::sthCore::invoke stc::get $device -children-dhcpv4blockconfig]] } {
            set ip_version 4
        } elseif {[regexp -nocase "6" [::sth::sthCore::invoke stc::get $device -children-dhcpv6blockconfig]]} {
            set ip_version 6
        } else {
            continue
        }
        set cmdName "::sth::emulation_dhcp_control -handle $device -action $action -ip_version $ip_version"
        set result [::spirent::process_cmd $cmdName]
    }
    return $result
}


